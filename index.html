<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, maximum-scale=1.0, minimum-scale=1.0, target-densitydpi=device-dpi">
  <title>乞丐生存 - 卡牌生存游戏</title>
  <!-- Tailwind CSS v3 -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Font Awesome -->
  
  <!-- 加载自定义字体 -->
  <style>
    @font-face {
      font-family: 'HuiWenMingChaoTi';
      src: url('字体/汇文明朝体.otf') format('opentype');
    }
  </style>

  <!-- GSAP 动画库 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <!-- Tailwind 配置 -->
  <!-- Tailwind配置 -->
  <script>
    // 显示钱币不足弹窗
    function showNoMoneyModal() {
      const modal = document.createElement('div');
      modal.className = 'no-money-modal active';
      modal.innerHTML = `
        <div class="no-money-modal-content ink-border">
          <h2 class="no-money-modal-title ink-text">钱币不足</h2>
          <div class="ink-decoration">
            <p class="no-money-modal-text">你还没有10个钱币，无法获得线索</p>
          </div>
          <div class="no-money-modal-button ink-button ink-button-primary" id="closeNoMoneyModal">关闭</div>
        </div>
      `;

document.body.appendChild(modal);

// 添加样式
      const style = document.createElement('style');
      style.textContent = `
        .no-money-modal {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 1000;
          opacity: 0;
          pointer-events: none;
          transition: opacity 0.3s ease;
        }

  .no-money-modal.active {
          opacity: 1;
          pointer-events: auto;
        }
        /* 红色边框阴影警示样式 */
        .garbage-grid-item.danger-tip {
          box-shadow: 0 0 10px 3px red, inset 0 0 10px 3px rgba(255, 0, 0, 0.3);
          border: 3px solid red;
          animation: danger-pulse 1.5s infinite;
          z-index: 10;
        }

/* 危险警示动画效果 */
        @keyframes danger-pulse {
          0% { box-shadow: 0 0 10px 3px red, inset 0 0 10px 3px rgba(255, 0, 0, 0.3); }
          50% { box-shadow: 0 0 15px 5px red, inset 0 0 15px 5px rgba(255, 0, 0, 0.5); }
          100% { box-shadow: 0 0 10px 3px red, inset 0 0 10px 3px rgba(255, 0, 0, 0.3); }

/* 状态框警告脉冲动画 */
        @keyframes pulse {
          0% { box-shadow: 0 0 15px rgba(229, 62, 62, 0.8); }
          50% { box-shadow: 0 0 25px rgba(229, 62, 62, 1); }
          100% { box-shadow: 0 0 15px rgba(229, 62, 62, 0.8); }

.no-money-modal-content {
          background-color: #FFFDF7;
          padding: 2rem;
          box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
          width: 300px;
          text-align: center;
          border-radius: 0.25rem;

.no-money-modal-title {
          font-size: 1.5rem;
          font-weight: normal;
          color: #5D4037;
          margin-bottom: 1rem;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }

.no-money-modal-text {
          color: #7D6E63;
          margin-bottom: 1.5rem;
          line-height: 1.5;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }

.no-money-modal-button {
          background-color: #8D6E63;
          color: white;
          padding: 0.75rem 1.5rem;
          border-radius: 0.375rem;
          cursor: pointer;
          font-weight: normal;
          transition: background-color 0.2s;
          display: inline-block;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }

.no-money-modal-button:hover {
          background-color: #6D4C41;
        }
      `;

document.head.appendChild(style);

// 关闭按钮事件
      const closeNoMoneyModal = document.getElementById('closeNoMoneyModal');
      if (closeNoMoneyModal) {
        closeNoMoneyModal.addEventListener('click', function() {
          modal.classList.remove('active');
          setTimeout(function() {
            if (modal.parentNode) {
              if (modal.parentNode) {
        modal.parentNode.removeChild(modal);
      }
            }
            if (style.parentNode) {
              if (style.parentNode === document.head) {
        style.parentNode.removeChild(style);
      }
            }
          }, 300);
        });
      }

// 点击弹窗外部关闭
      modal.addEventListener('click', function(e) {
        if (e.target === modal) {
          modal.classList.remove('active');
          setTimeout(function() {
            if (modal.parentNode) {
              modal.parentNode.removeChild(modal);
            }
            if (style.parentNode) {
              style.parentNode.removeChild(style);
            }
          }, 300);
        }
      });
    }
  </script>
  <style type="text/tailwindcss">
    @layer utilities {
      .text-shadow {
        text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
      }
      .card-border {
        border-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4"><path d="M0 0h4v4H0z" fill="none" stroke="%23A0AEC0" stroke-width="1"/></svg>') 1 repeat;
      }
      .ink-splash {
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><circle cx="50" cy="50" r="40" fill="rgba(160, 174, 192, 0.1)"/></svg>');
        background-repeat: no-repeat;
        background-position: center;
        background-size: contain;
      }
      .scroll-bg {
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M0 0h20v20H0z" fill="none" stroke="%23A0AEC0" stroke-width="1" stroke-dasharray="2,2"/></svg>');
        background-repeat: repeat;
      }
      .card-drag {
        cursor: grab;
      }
      .card-drag:active {
        cursor: grabbing;
      }
      .card-stack {
        position: relative;
      }
      .card-stack > div {
        position: absolute;
        transition: all 0.3s ease;
      }
      .card-stack > div:nth-child(1) { transform: translate(0, 0) rotate(0deg); z-index: 1; }
      .card-stack > div:nth-child(2) { transform: translate(8px, 8px) rotate(2deg); z-index: 2; }
      .card-stack > div:nth-child(3) { transform: translate(16px, 16px) rotate(4deg); z-index: 3; }
      .card-stack > div:nth-child(4) { transform: translate(24px, 24px) rotate(6deg); z-index: 4; }
      .card-stack > div:nth-child(5) { transform: translate(32px, 32px) rotate(8deg); z-index: 5; }
      .card-stack > div:nth-child(n+6) { transform: translate(40px, 40px) rotate(10deg); z-index: 6; }
    }
  </style>
  <style>
    /* 移除外部字体引用，使用系统默认字体 */

body {
        font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif, 'Microsoft YaHei', '微软雅黑';
        background-color: #F7FAFC;
        /* 使用伪元素创建虚化背景 */
        position: relative;
        overflow-x: hidden;
    }

    body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url('UI/背景6.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        filter: blur(1px); /* 10% 虚化效果 */
        z-index: -1;
    }

.card {
      transition: all 0.3s ease;
      border-radius: 12px; /* 弧形圆角 */
      overflow: hidden;
      border: 2px solid #8D6E63; /* 棕色边框 */
      box-shadow: 
        0 0 15px rgba(141, 110, 99, 0.3), /* 柔光外发光 */
        0 4px 8px rgba(139, 69, 19, 0.2), /* 常规阴影 */
        inset 0 1px 2px rgba(255, 255, 255, 0.3); /* 内发光 */
      background: linear-gradient(135deg, rgba(255, 253, 247, 0.95) 0%, rgba(255, 253, 247, 0.85) 100%);
    }

.card:hover {
      transform: translateY(-5px);
      box-shadow: 
        0 0 20px rgba(141, 110, 99, 0.5), /* 更强的柔光 */
        0 6px 12px rgba(139, 69, 19, 0.3),
        inset 0 1px 3px rgba(255, 255, 255, 0.4);
      border-radius: 14px; /* 悬停时圆角稍微增大 */
    }

.card.resource {
      background: linear-gradient(135deg, rgba(255, 253, 247, 0.95) 0%, rgba(255, 253, 247, 0.85) 100%);
      border: 2px solid #8D6E63;
    }

.card.location {
      background: linear-gradient(135deg, rgba(255, 253, 247, 0.95) 0%, rgba(255, 253, 247, 0.85) 100%);
      border: 2px solid #8D6E63;
    }

.location-details {
      display: flex;
      justify-content: space-between;
      margin-top: 0.5rem;
      font-size: 0.75rem;
    }

.resource-type, .danger-level, .action-cost {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

.danger-level.low {
      color: #38A169;
    }

.danger-level.medium {
      color: #ECC94B;
    }

.danger-level.high {
      color: #E53E3E;
    }

.location-card.current {
      border-color: #38A169;
      box-shadow: 0 0 15px rgba(56, 161, 105, 0.5);
    }

.card.status {
      background: linear-gradient(135deg, rgba(255, 253, 247, 0.95) 0%, rgba(255, 253, 247, 0.85) 100%);
      border: 2px solid #8D6E63;
    }

.card.action {
      background: linear-gradient(135deg, rgba(255, 253, 247, 0.95) 0%, rgba(255, 253, 247, 0.85) 100%);
      border: 2px solid #8D6E63;
    }

.card-image {
      width: 100%;
      height: 120px;
      object-fit: cover;
      background-color: #E2E8F0;
    }

.location-card .card-image {
      height: 60px;
    }

.action-card .card-image {
      height: 60px;
    }

    .action-card .card-content {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100%;
    }

    .action-card .card-title {
      text-align: center;
      margin: 0;
      font-weight: normal;
      font-size: 1.1rem;
    }

.card-content {
      padding: 0.75rem;
    }

.card-title {
      font-weight: normal;
      font-size: 1.2rem;
      margin-bottom: 0.25rem;
    }

.map-card-title {
      font-weight: normal;
      font-size: 1.6rem;
      margin-bottom: 0.25rem;
      text-align: center;
    }

/* 资源卡牌特定样式 - 缩小尺寸以适应更多卡牌 */
    .resource-card {
      width: 80px;
    }

.resource-card .card-image {
      height: 80px;
    }

.resource-card .card-title {
      font-size: 1.1rem;
    }

.card-description {
      font-size: 0.75rem;
      color: #4A5568;
    }

.card-footer {
      padding: 0.25rem 0.5rem;
      border-top: 1px solid #E2E8F0;
      font-size: 0.75rem;
      color: #4A5568;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

.resource-count {
      background-color: #E2E8F0;
      border-radius: 9999px;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      font-weight: normal;
    }

.progress-bar {
      height: 4px;
      background-color: transparent;
      border-radius: 9999px;
      overflow: hidden;
    }

.progress-bar-fill {
      height: 100%;
      background-color: #805AD5;
      border-radius: 9999px;
      transition: width 0.3s ease;
    }

.location-card {
      cursor: pointer;
    }

.resource-card {
      cursor: grab;
    }

.resource-card:active {
      cursor: grabbing;
    }

.resource-card.dragging {
      opacity: 0.5;
      transform: scale(1.1);
      z-index: 1000;
    }

    /* 固定卡牌的视觉样式 */
    .resource-card.pinned {
      border-color: #38A169;
      box-shadow: 
        0 0 15px rgba(56, 161, 105, 0.3),
        0 4px 8px rgba(56, 161, 105, 0.2),
        inset 0 0 0 2px rgba(56, 161, 105, 0.3);
    }

    .resource-card.pinned:hover {
      border-color: #38A169;
      box-shadow: 
        0 0 20px rgba(56, 161, 105, 0.5),
        0 6px 12px rgba(56, 161, 105, 0.3),
        inset 0 0 0 2px rgba(56, 161, 105, 0.5);
    }

.status-card {
      cursor: default;
    }

.action-card {
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
    }

.dragging {
      opacity: 0.8;
      transform: scale(1.05);
      z-index: 100;
    }

.dropzone {
      border: 2px dashed #E2E8F0;
      border-radius: 0.5rem;
      padding: 1rem;
      min-height: 100px;
      transition: all 0.3s ease;
    }

    /* 雨滴样式 */
    .raindrop {
      position: absolute;
      width: 2px;
      height: 15px;
      background: linear-gradient(to bottom, rgba(174, 194, 224, 0) 0%, rgba(174, 194, 224, 0.8) 50%, rgba(174, 194, 224, 0) 100%);
      border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
      opacity: 0.8;
      animation: fall linear infinite;
    }

    /* 雨滴落在水面上的晕圈效果 */
    .ripple {
      position: absolute;
      border-radius: 50%;
      background-color: rgba(174, 194, 224, 0.6);
      transform: scale(0);
      animation: ripple-animation 1s ease-out;
      pointer-events: none;
    }

    /* 雨滴下落动画 */
    @keyframes fall {
      0% {
        transform: translateY(-10px) translateX(0);
        opacity: 0;
      }
      10% {
        opacity: 0.8;
      }
      90% {
        opacity: 0.8;
      }
      100% {
        transform: translateY(calc(100vh - 20px)) translateX(10px);
        opacity: 0;
      }
    }

    /* 晕圈扩散动画 */
    @keyframes ripple-animation {
      0% {
        transform: scale(0);
        opacity: 0.8;
      }
      50% {
        transform: scale(1.5);
        opacity: 0.4;
      }
      100% {
        transform: scale(2.5);
        opacity: 0;
      }
    }

    /* 雨天背景效果 */
    .weather-rainy .main-content {
      backdrop-filter: blur(2px) brightness(0.95);
      transition: backdrop-filter 0.3s ease, brightness 0.3s ease;
    }

.dropzone.active {
      border-color: #805AD5;
      background-color: rgba(128, 90, 213, 0.05);
    }

.game-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
    }

.header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 0;
      margin-bottom: 1rem;
      border-bottom: 1px solid #E2E8F0;
    }

.header-title {
      font-size: 1.5rem;
      font-weight: normal;
      color: #2D3748;
    }

.header-info {
        .info-item-value {
          font-weight: normal;
          color: #2D3748;
        }
        .sidebar-section-title {
          font-size: 1rem;
          font-weight: normal;
          margin-bottom: 0.75rem;
          color: #2D3748;
        }
      display: flex;
      gap: 1rem;
    }

.info-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      color: #4A5568;
    }

.info-item-value {
      font-weight: normal;
      color: #2D3748;
    }

.main-content {
      display: grid;
      grid-template-columns: 250px 1fr;
      gap: 1rem;
    }

.sidebar {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      width: 250px;
      max-width: 250px;
    }

.sidebar-section {
      background-color: transparent;
      border: 1px solid #E2E8F0;
      border-radius: 0.5rem;
      padding: 1rem;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
    }

.sidebar-section-title {
      font-size: 1rem;
      font-weight: normal;
      margin-bottom: 0.75rem;
      color: #2D3748;
    }

.status-grid {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

.resource-container {
      width: 600px; /* 固定宽度 */
      position: relative;
    }

    .resource-grid {
      display: flex;
      gap: 0.5rem;
      padding: 0.5rem;
      height: 200px; /* 固定高度 */
      overflow-x: scroll;
      overflow-y: hidden;
      width: 100%;
      flex-wrap: nowrap; /* 一行排列，超出滚动 */
      box-sizing: border-box;
      scrollbar-width: none; /* 隐藏默认滚动条 */
      -ms-overflow-style: none; /* IE隐藏滚动条 */
    }

    /* 隐藏WebKit浏览器默认滚动条 */
    .resource-grid::-webkit-scrollbar {
      display: none;
    }

    /* 自定义滚动条容器 */
    .resource-scrollbar {
      width: 100%;
      height: 6px;
      background-color: #f7fafc;
      border-radius: 3px;
      margin-top: 0.5rem;
      position: relative;
      cursor: pointer;
    }

    /* 滚动条滑块 */
    .resource-scrollbar-thumb {
      height: 100%;
      background-color: #cbd5e0;
      border-radius: 3px;
      position: absolute;
      left: 0;
      top: 0;
      cursor: grab;
      transition: background-color 0.2s ease;
    }

    .resource-scrollbar-thumb:hover {
        background-color: #a0aec0;
    }
    
    .resource-scrollbar-thumb.dragging {
        background-color: #718096;
        cursor: grabbing;
    }

/* 确保资源卡牌保持固定大小 */
.resource-grid .resource-card {
      flex: 0 0 100px;
      width: 100px;
      min-width: 100px;
      max-width: 100px;
    }

    /* 背包栏标签按钮字体增大 */
    .inventory-tab {
      font-size: 1.2rem;
    }

.main-area {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      width: 100%;
      max-width: 100%;
    }

.location-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.75rem;
    }

.action-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.5rem;
      height: 100px; /* 固定高度 */
      width: 100%; /* 保持宽度自适应 */
      max-width: 600px; /* 最大宽度限制 */
    }

.combination-area {
      background-color: #F7FAFC;
      border: 1px solid #E2E8F0;
      border-radius: 0.5rem;
      padding: 1rem;
      min-height: 200px;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

.combination-title {
      font-size: 1rem;
      font-weight: normal;
      color: #2D3748;
    }

.combination-slots {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

.combination-slot {
      width: 80px;
      height: 120px;
      border: 2px dashed #E2E8F0;
      border-radius: 0.5rem;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: all 0.3s ease;
    }

.combination-slot.active {
      border-color: #805AD5;
      background-color: rgba(128, 90, 213, 0.05);
    }

/* 制作窗口样式 */
    .crafting-modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.5);
    }

.crafting-modal.active {
      display: block;
    }

.crafting-modal-content {
      background-color: #F7FAFC;
      margin: 5% auto;
      padding: 0;
      border: 1px solid #E2E8F0;
      border-radius: 0.5rem;
      width: 90%;
      max-width: 800px;
      max-height: 50vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

.crafting-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

.crafting-modal-title {
      font-size: 1.4rem;
      font-weight: normal;
      margin: 0;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
    }

.crafting-modal-close {
      color: white;
      font-size: 1.75rem;
      font-weight: normal;
      background: none;
      border: none;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }

.crafting-modal-close:hover,
    .crafting-modal-close:focus {
      color: #E2E8F0;
      text-decoration: none;
      cursor: pointer;
    }

.crafting-modal-body {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

.crafting-left,
    .crafting-right {
      padding: 1rem;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

.crafting-left {
      width: 50%;
      border-right: 1px solid #E2E8F0;
    }

.crafting-right {
      width: 50%;
    }

.crafting-section-title {
      font-size: 1.2rem;
      font-weight: normal;
      color: #2D3748;
      margin-bottom: 1rem;
    }

.crafting-inventory {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 0.5rem;
      background-color: rgba(0, 0, 0, 0.02);
      border-radius: 0.5rem;
    }

/* 卡牌和插槽的基础尺寸变量 */
    :root {
      --card-base-width: 80px;
      --card-base-height: 120px;
    }

.crafting-inventory-card {
      width: var(--card-base-width) !important;
      height: var(--card-base-height) !important;
      border: 2px solid #8D6E63 !important;
      border-radius: 12px !important; /* 弧形圆角 */
      background: linear-gradient(135deg, rgba(255, 253, 247, 0.95) 0%, rgba(255, 253, 247, 0.85) 100%) !important;
      display: flex !important;
      flex-direction: column !important;
      align-items: center !important;
      padding: 0.5rem !important;
      cursor: pointer !important;
      transition: all 0.2s ease !important;
      box-shadow: 
        0 0 15px rgba(141, 110, 99, 0.3), /* 柔光外发光 */
        0 4px 8px rgba(139, 69, 19, 0.2), /* 常规阴影 */
        inset 0 1px 2px rgba(255, 255, 255, 0.3) !important; /* 内发光 */
    }

.crafting-inventory-card:hover {
      transform: scale(1.05) !important;
      box-shadow: 
        0 0 20px rgba(141, 110, 99, 0.5), /* 更强的柔光 */
        0 6px 12px rgba(139, 69, 19, 0.3),
        inset 0 1px 3px rgba(255, 255, 255, 0.4) !important;
      border-radius: 14px !important; /* 悬停时圆角稍微增大 */
    }

.crafting-card-image {
      width: 100% !important;
      height: 70px !important;
      background-size: cover !important;
      background-position: center !important;
      border-radius: 0.25rem !important;
      margin-bottom: 0.5rem !important;
      background-color: #E2E8F0 !important;
    }

.crafting-card-title {
      font-size: 0.75rem !important;
      font-weight: normal !important;
      color: #2D3748 !important;
      text-align: center !important;
      margin-bottom: 0.25rem !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      white-space: nowrap !important;
      width: 100% !important;
    }

.crafting-card-count {
      font-size: 0.625rem !important;
      color: #4A5568 !important;
      font-weight: normal !important;
    }

.crafting-slots {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 0.5rem;
    }

.crafting-slot {
      width: var(--card-base-width);
      height: var(--card-base-height);
      border: 2px dashed #8D6E63;
      border-radius: 0.5rem;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: all 0.3s ease;
    }

.crafting-slot.active {
      border-color: #805AD5;
      background-color: rgba(128, 90, 213, 0.05);
    }

.crafting-slot .card {
      width: 100% !important;
      height: 100% !important;
      font-size: 0.75rem !important;
      display: flex !important;
      flex-direction: column !important;
    }

.crafting-slot .card .card-image {
      height: 70% !important;
    }

.crafting-slot .card .card-content {
      padding: 0.5rem !important;
      flex-grow: 1 !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
    }

.crafting-slot .card .card-title {
      font-size: 0.75rem !important;
      text-align: center !important;
      white-space: nowrap !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
    }

/* 响应式设计 - 小屏幕适配 */
    @media (max-width: 600px) {
      :root {
        --card-base-width: 60px;
        --card-base-height: 90px;
      }

.crafting-inventory-card {
        padding: 0.25rem !important;
      }

.crafting-card-title {
        font-size: 0.625rem !important;
      }

.crafting-card-count {
        font-size: 0.5rem !important;
      }
    }

.crafting-result {
      min-height: 100px;
      margin-bottom: 0.25rem;
      padding: 0.75rem;
      background-color: rgba(0, 0, 0, 0.02);
      border-radius: 0.5rem;
      text-align: center;
    }

.crafting-buttons {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-bottom: 1rem;
    }

.crafting-button {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 0.5rem;
      background-color: #805AD5;
      color: white;
      font-weight: normal;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

.crafting-button:hover {
      background-color: #6B46C1;
      transform: translateY(-2px);
      box-shadow: 
        0 0 35px rgba(141, 110, 99, 0.7),
        0 6px 16px rgba(139, 69, 19, 0.4),
    }

    .event-result-modal-confirm {
      background-color: #805AD5;
      color: white;
      border: none;
      border-radius: 0.375rem;
      padding: 0.5rem 1.5rem;
      font-weight: normal;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    .event-result-modal-confirm:hover {
      background-color: #6B46C1;
      transform: translateY(-2px);
      box-shadow: 
        0 0 35px rgba(141, 110, 99, 0.7),
        0 6px 16px rgba(139, 69, 19, 0.4),
        inset 0 1px 4px rgba(255, 255, 255, 0.5),
        inset 0 -3px 6px rgba(0, 0, 0, 0.3);
    }

.crafting-button:active {
      transform: translateY(0);
      box-shadow: 
        0 0 15px rgba(141, 110, 99, 0.3),
        0 2px 6px rgba(139, 69, 19, 0.2),
        inset 0 1px 2px rgba(255, 255, 255, 0.2),
        inset 0 -1px 3px rgba(0, 0, 0, 0.2);
    }

.crafting-button:disabled {
      background-color: #CBD5E0;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

/* 地图模态框样式 */
    .map-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

.map-modal.active {
      opacity: 1;
      visibility: visible;
    }

.map-modal-content {
      position: relative;
      width: 900px;
      height: 600px;
      background-image: url('UI/地图.jpg') !important;
      background-size: contain !important;
      background-repeat: no-repeat !important;
      background-position: center !important;
      border: none !important;
      border-radius: 0;
      box-shadow: none !important;
      transform: translateY(-20px);
      transition: all 0.3s ease;
      overflow: hidden;
    }

    /* 覆盖ink-border类的背景设置 */
    .map-modal-content.ink-border {
      background: url('UI/地图.jpg') center/contain no-repeat !important;
      border: none !important;
      border-radius: 0;
      box-shadow: none !important;
    }
    
    /* 隐藏ink-border的伪元素 */
    .map-modal-content.ink-border::before,
    .map-modal-content.ink-border::after {
      display: none !important;
    }

.map-modal.active .map-modal-content {
      transform: translateY(0);
    }

.map-modal-header {
      position: absolute;
      top: 10px;
      right: 180px;
      z-index: 10;
    }

.map-modal-title {
      font-size: 1.8rem;
      font-weight: normal;
      color: #2D3748;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
    }

.map-modal-close {
      background: none;
      border: none;
      font-size: 1.25rem;
    }

.tutorial-modal-title {
      font-size: 1.25rem;
    }

.event-result-modal-title {
      font-size: 1.25rem;
      font-weight: normal;
      color: #2D3748;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
    }

.event-result-modal-close {
      background: none;
      border: none;
      font-size: 1.25rem;
    }

.game-over-modal-title {
      font-size: 1.5rem;
      font-weight: normal;
      color: #2D3748;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
    }

.recipe-modal-title {
      font-size: 1.25rem;
      font-weight: normal;
      color: #2D3748;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
    }

.recipe-modal-close {
      background: none;
      border: none;
      font-size: 1.25rem;
    }

.event-modal-title {
      font-size: 1.25rem;
      font-weight: normal;
      color: #2D3748;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
    }

.event-modal-close {
      background: none;
      border: none;
      font-size: 1.25rem;
      cursor: pointer;
      color: #4A5568;
    }

.map-modal-body {
      position: relative;
      width: 100%;
      height: 100%;
    }

    #mapLocationGrid {
      position: relative;
      width: 100%;
      height: 100%;
    }

    /* 地点卡牌样式 */
    .map-location-card {
      position: absolute;
      width: 100px;
      height: 50px;
      background-color: rgba(128, 0, 0, 0.8); /* 红色，带透明度 */
      color: white;
      border-radius: 5px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      text-align: center;
      padding: 5px;
      border: 1px solid rgba(255, 255, 255, 0.3); /* 添加淡白色边框增强视觉效果 */
    }

    .map-location-card:hover {
      transform: scale(1.1);
      background-color: rgba(128, 0, 0, 1); /* 不透明的红色 */
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      z-index: 10;
    }

.event-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

.event-modal.active {
      opacity: 1;
      visibility: visible;
    }

.event-modal-content {
      background-color: #F7FAFC;
      border: 1px solid #E2E8F0;
      border-radius: 0.5rem;
      max-width: 500px;
      width: 90%;
      padding: 1.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      transform: translateY(-20px);
      transition: all 0.3s ease;
    }

.event-modal.active .event-modal-content {
      transform: translateY(0);
    }

.event-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

.event-modal-title {
      font-size: 1.25rem;
      font-weight: normal;
      color: #2D3748;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
    }

.event-modal-close {
      background: none;
      border: none;
      font-size: 1.25rem;
      cursor: pointer;
      color: #4A5568;
    }

.event-modal-body {
      margin-bottom: 1.5rem;
    }

.event-modal-text {
      margin-bottom: 1rem;
      color: #2D3748;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
    }

.event-modal-options {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

.event-modal-option {
      background: linear-gradient(135deg, #8D6E63 0%, #6D4C41 100%) !important;
      border: 2px solid #5D4037 !important;
      border-radius: 16px !important;
      padding: 0.75rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 
        0 0 25px rgba(141, 110, 99, 0.5),
        0 4px 12px rgba(139, 69, 19, 0.3),
        inset 0 1px 3px rgba(255, 255, 255, 0.4),
        inset 0 -2px 4px rgba(0, 0, 0, 0.2) !important;
      position: relative;
      overflow: hidden;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
      font-weight: normal !important;
      color: white !important;
      text-align: center;
      margin-bottom: 0.5rem;
    }

    .event-modal-option:hover {
      background: linear-gradient(135deg, #7D6E63 0%, #5D4037 100%) !important;
      transform: translateY(-2px) !important;
      box-shadow: 
        0 0 35px rgba(141, 110, 99, 0.7),
        0 6px 16px rgba(139, 69, 19, 0.4),
        inset 0 1px 4px rgba(255, 255, 255, 0.5),
        inset 0 -3px 6px rgba(0, 0, 0, 0.3) !important;
      border-radius: 18px !important;
    }

    .event-modal-option:active {
      transform: translateY(0) !important;
      box-shadow: 
        0 0 15px rgba(141, 110, 99, 0.3),
        0 2px 6px rgba(139, 69, 19, 0.2),
        inset 0 1px 2px rgba(255, 255, 255, 0.2),
        inset 0 -1px 3px rgba(0, 0, 0, 0.2) !important;
    }

    .event-modal-option-text {
      font-weight: normal;
      margin-bottom: 0.25rem;
      color: white;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif;
      text-shadow: 1px 1px 2px rgba(93, 64, 55, 0.2);
    }

    .event-modal-option-description {
      font-size: 0.75rem;
      color: #f0f0f0;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif;
    }

.tooltip {
      position: relative;
      display: inline-block;
    }

.tooltip .tooltip-text {
      visibility: hidden;
      width: 200px;
      background-color: #2D3748;
      color: #fff;
      text-align: center;
      border-radius: 0.25rem;
      padding: 0.5rem;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 0.75rem;
    }

.tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }

.season-indicator {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 1.1rem;
      color: #4A5568;
    }

.season-icon {
      font-size: 1rem;
    }

.day-indicator {
      font-size: 1.5rem;
      color: #4A5568;
      text-align: center;
      font-weight: normal;
    }

.day-number {
      font-weight: normal;
      color: #2D3748;
    }

.notification {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background-color: #F7FAFC;
      border: 1px solid #E2E8F0;
      border-radius: 0.5rem;
      padding: 1rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.3s ease;
      z-index: 1000;
      max-width: 300px;
      width: 90%;
    }

.notification.active {
      transform: translateY(0);
      opacity: 1;
    }

.notification.central {
      top: 50% !important;
      left: 50% !important;
      bottom: auto !important;
      right: auto !important;
      transform: translate(-50%, -50%) scale(0.9) !important;
      padding: 1.5rem;
      max-width: 400px;
      text-align: center;
    }

.notification.central.active {
      transform: translate(-50%, -50%) scale(1);
    }

.notification-title {
      font-size: 1rem;
      font-weight: normal;
      margin-bottom: 0.25rem;
      color: #2D3748;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
    }

.notification-message {
      font-size: 0.875rem;
      color: #4A5568;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
    }

.notification-close {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background: none;
      border: none;
      font-size: 1.25rem;
      cursor: pointer;
      color: #4A5568;
    }

    .notification-actions {
      margin-top: 1rem;
    }

    .notification-button {
      background: linear-gradient(135deg, #8D6E63 0%, #6D4C41 100%) !important;
      border: 2px solid #5D4037 !important;
      border-radius: 16px !important;
      padding: 0.5rem 1.5rem !important;
      font-size: 0.875rem !important;
      font-weight: normal !important;
      cursor: pointer !important;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
      color: white !important;
      text-shadow: none !important;
      letter-spacing: 1px !important;
      overflow: hidden !important;
      box-shadow: 
        0 0 25px rgba(141, 110, 99, 0.5),
        0 4px 12px rgba(139, 69, 19, 0.3),
        inset 0 1px 3px rgba(255, 255, 255, 0.4),
        inset 0 -2px 4px rgba(0, 0, 0, 0.2) !important;
      transition: all 0.3s ease !important;
    }

    .notification-button:hover {
      background: linear-gradient(135deg, #7D6E63 0%, #5D4037 100%) !important;
      transform: translateY(-2px) !important;
      box-shadow: 
        0 0 35px rgba(141, 110, 99, 0.7),
        0 6px 16px rgba(139, 69, 19, 0.4),
        inset 0 1px 4px rgba(255, 255, 255, 0.5),
        inset 0 -3px 6px rgba(0, 0, 0, 0.3) !important;
      border-radius: 18px !important;
    }

    .notification-button:active {
      transform: translateY(0) !important;
      box-shadow: 
        0 0 15px rgba(141, 110, 99, 0.3),
        0 2px 6px rgba(139, 69, 19, 0.2),
        inset 0 1px 2px rgba(255, 255, 255, 0.2),
        inset 0 -1px 3px rgba(0, 0, 0, 0.2) !important;
    }

.recipe-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1100;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

.recipe-modal.active {
      opacity: 1;
      visibility: visible;
    }

.recipe-modal-content {
      background-color: #F7FAFC;
      border: 1px solid #E2E8F0;
      border-radius: 0.5rem;
      max-width: 800px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      padding: 1.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      transform: translateY(-20px);
      transition: all 0.3s ease;
    }

.recipe-modal.active .recipe-modal-content {
      transform: translateY(0);
    }

.recipe-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

.recipe-modal-title {
      font-size: 1.25rem;
      font-weight: normal;
      color: #2D3748;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
    }

.recipe-modal-close {
      background: none;
      border: none;
      font-size: 1.25rem;
      cursor: pointer;
      color: #4A5568;
    }

.recipe-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 1rem;
    }

.recipe-card {
      background-color: #F7FAFC;
      border: 1px solid #E2E8F0;
      border-radius: 0.5rem;
      padding: 1rem;
      transition: all 0.3s ease;
    }

.recipe-card:hover {
      background-color: #EDF2F7;
      border-color: #CBD5E0;
    }

.recipe-card-title {
      font-size: 1rem;
      font-weight: normal;
      margin-bottom: 0.5rem;
      color: #2D3748;
    }

        .game-over-stats-title {
          font-size: 1rem;
          font-weight: normal;
          margin-bottom: 0.5rem;
          color: #2D3748;
        }

    .start-screen-title {
      font-size: 2rem;
      font-weight: normal;
      margin-bottom: 1rem;
      color: #2D3748;
    }

.recipe-card-ingredients {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

.recipe-card-ingredient {
      background-color: #EDF2F7;
      border-radius: 9999px;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      color: #4A5568;
    }

.recipe-card-description {
      font-size: 0.75rem;
      color: #4A5568;
    }

.recipe-card-discovered {
      font-size: 0.75rem;
      color: #805AD5;
      font-weight: normal;
    }

.recipe-card-undiscovered {
      font-size: 0.75rem;
      color: #A0AEC0;
    }

/* 事件结果模态框样式 */
    .event-result-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

.event-result-modal.active {
      opacity: 1;
      visibility: visible;
    }

.event-result-modal.closing {
      opacity: 0;
    }

.event-result-modal-content {
      background-color: #F7FAFC;
      border: 1px solid #E2E8F0;
      border-radius: 0.5rem;
      max-width: 500px;
      width: 90%;
      padding: 1.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      transform: translateY(-20px);
      transition: all 0.3s ease;
    }

.event-result-modal.active .event-result-modal-content {
      transform: translateY(0);
    }

.event-result-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

.event-result-modal-title {
      font-size: 1.25rem;
      font-weight: normal;
      color: #2D3748;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
    }

.event-result-modal-close {
      background: none;
      border: none;
      font-size: 1.25rem;
      cursor: pointer;
      color: #4A5568;
      transition: all 0.3s ease;
    }

.event-result-modal-close:hover {
      color: #2D3748;
    }

.event-result-modal-body {
      margin-bottom: 1rem;
    }

.event-result-modal-footer {
      display: flex;
      justify-content: center;
      margin-top: 1rem;
    }

.event-result-modal-confirm {
      background-color: #805AD5;
      color: white;
      border: none;
      border-radius: 0.375rem;
      padding: 0.5rem 1.5rem;
      font-weight: normal;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

.event-result-modal-confirm:hover {
      background-color: #6B46C1;
    }

.event-result-section {
      margin-bottom: 1rem;
    }

.event-result-section:last-child {
      margin-bottom: 0;
    }

.event-result-list {
      margin-top: 0.5rem;
      padding-left: 1.5rem;
      list-style-type: disc;
    }

.event-result-list li {
      margin-bottom: 0.25rem;
      color: #2D3748;
    }

.start-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #F7FAFC;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      transition: all 0.5s ease;
    }

.start-screen-content {
      text-align: center;
      max-width: 600px;
      padding: 2rem;
    }

.start-screen-title {
      font-size: 2rem;
      font-weight: normal;
      margin-bottom: 1rem;
      color: #2D3748;
    }

.start-screen-subtitle {
      font-size: 1.25rem;
      margin-bottom: 2rem;
      color: #4A5568;
    }

.start-screen-image {
      width: 100%;
      max-width: 400px;
      margin: 0 auto 2rem;
      border-radius: 0.5rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

.start-screen-description {
      margin-bottom: 2rem;
      color: #4A5568;
    }

.start-screen-button {
      background-color: #805AD5;
      color: white;
      border: none;
      border-radius: 0.5rem;
      padding: 1rem 2rem;
      font-size: 1rem;
      font-weight: normal;
      cursor: pointer;
      transition: all 0.3s ease;
    }

.start-screen-button:hover {
      background-color: #6B46C1;
      transform: translateY(-2px);
      box-shadow: 
        0 0 35px rgba(141, 110, 99, 0.7),
        0 6px 16px rgba(139, 69, 19, 0.4),
        inset 0 1px 4px rgba(255, 255, 255, 0.5),
        inset 0 -3px 6px rgba(0, 0, 0, 0.3);
    }

.tutorial-button {
      background-color: #805AD5;
      color: white;
      border: none;
      border-radius: 0.5rem;
      padding: 0.75rem 1.5rem;
      font-size: 0.875rem;
      font-weight: normal;
      cursor: pointer;
      transition: all 0.3s ease;
    }

.tutorial-button:hover {
      background-color: #6B46C1;
      transform: translateY(-2px);
      box-shadow: 
        0 0 35px rgba(141, 110, 99, 0.7),
        0 6px 16px rgba(139, 69, 19, 0.4),
        inset 0 1px 4px rgba(255, 255, 255, 0.5),
        inset 0 -3px 6px rgba(0, 0, 0, 0.3);
    }

.start-screen-button:active {
      transform: translateY(0);
      box-shadow: 
        0 0 15px rgba(141, 110, 99, 0.3),
        0 2px 6px rgba(139, 69, 19, 0.2),
        inset 0 1px 2px rgba(255, 255, 255, 0.2),
        inset 0 -1px 3px rgba(0, 0, 0, 0.2);
    }

.tutorial-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

.tutorial-modal.active {
      opacity: 1;
      visibility: visible;
    }

.tutorial-modal-content {
      background-color: #F7FAFC;
      border: 1px solid #E2E8F0;
      border-radius: 0.5rem;
      max-width: 800px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      padding: 1.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      transform: translateY(-20px);
      transition: all 0.3s ease;
    }

.tutorial-modal.active .tutorial-modal-content {
      transform: translateY(0);
    }

.tutorial-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

.tutorial-modal-title {
      font-size: 1.25rem;
      font-weight: normal;
      color: #2D3748;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
    }

.tutorial-modal-close {
      background: none;
      border: none;
      font-size: 1.25rem;
      cursor: pointer;
      color: #4A5568;
    }

.tutorial-step {
      margin-bottom: 1.5rem;
      display: block !important;
    }

.tutorial-step-title {
      font-size: 1rem;
      font-weight: normal;
      margin-bottom: 0.5rem;
      color: #2D3748;
    }

.tutorial-step-content {
      margin-bottom: 0.5rem;
      color: #4A5568;
    }

.tutorial-step-image {
      width: 100%;
      max-width: 400px;
      margin: 0 auto 1rem;
      border-radius: 0.5rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

.start-screen-button {
      background-color: #805AD5;
      color: white;
      border: none;
      border-radius: 0.5rem;
      padding: 1rem 2rem;
      font-size: 1rem;
      font-weight: normal;
      cursor: pointer;
      transition: all 0.3s ease;
    }

.tutorial-navigation {
      display: flex;
      justify-content: center;
      margin-top: 1.5rem;
    }

.tutorial-button {
      background-color: #805AD5;
      color: white;
      border: none;
      border-radius: 0.5rem;
      padding: 0.75rem 1.5rem;
      font-size: 0.875rem;
      font-weight: normal;
      cursor: pointer;
      transition: all 0.3s ease;
    }

.tutorial-button:hover {
      background-color: #6B46C1;
      transform: translateY(-2px);
      box-shadow: 
        0 0 35px rgba(141, 110, 99, 0.7),
        0 6px 16px rgba(139, 69, 19, 0.4),
        inset 0 1px 4px rgba(255, 255, 255, 0.5),
        inset 0 -3px 6px rgba(0, 0, 0, 0.3);
    }

.tutorial-button:active {
      transform: translateY(0);
      box-shadow: 
        0 0 15px rgba(141, 110, 99, 0.3),
        0 2px 6px rgba(139, 69, 19, 0.2),
        inset 0 1px 2px rgba(255, 255, 255, 0.2),
        inset 0 -1px 3px rgba(0, 0, 0, 0.2);
    }

.tutorial-button:disabled {
      background-color: #A0AEC0;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

.game-over-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 500;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

.game-over-modal.active {
      opacity: 1;
      visibility: visible;
    }

.game-over-modal-content {
      background-color: #FFFDF7;
      border-radius: 0.25rem;
      max-width: 600px;
      width: 90%;
      padding: 1.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
      transform: translateY(-20px);
      transition: all 0.3s ease;
    }

.game-over-modal.active .game-over-modal-content {
      transform: translateY(0);
    }

.game-over-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

.game-over-modal-title {
      font-size: 1.5rem;
      font-weight: normal;
      color: #2D3748;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
    }

.game-over-modal-body {
      margin-bottom: 1.5rem;
    }

.game-over-modal-text {
      margin-bottom: 1rem;
      color: #2D3748;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
    }

.game-over-stats {
      background-color: #EDF2F7;
      border-radius: 0.5rem;
      padding: 1rem;
      margin-bottom: 1.5rem;
    }

.game-over-stats-title {
      font-size: 1rem;
      font-weight: normal;
      margin-bottom: 0.5rem;
      color: #2D3748;
    }

.game-over-stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
    }

.game-over-stat {
      display: flex;
      justify-content: space-between;
      font-size: 0.875rem;
      color: #4A5568;
    }

.game-over-stat-value {
      font-weight: normal;
      color: #2D3748;
    }

.game-over-modal-options {
      display: flex;
      gap: 1rem;
      justify-content: center;
    }

.game-over-button {
      background-color: #805AD5;
      color: white;
      border: none;
      border-radius: 0.5rem;
      padding: 0.75rem 1.5rem;
      font-size: 0.875rem;
      font-weight: normal;
      cursor: pointer;
      transition: all 0.3s ease;
    }

.game-over-button:hover {
      background-color: #6B46C1;
    }

.achievement-modal {
      position: fixed;
      top: 1rem;
      right: 1rem;
      background-color: #FFFDF7;
      border-radius: 0.25rem;
      padding: 1rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2), 0 2px 4px -1px rgba(0, 0, 0, 0.1);
      transform: translateX(100%);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 1000;
      max-width: 300px;
      display: flex;
      align-items: center;
      gap: 1rem;
    }

.achievement-modal.active {
      transform: translateX(0);
      opacity: 1;
    }

.achievement-icon {
      font-size: 1.5rem;
      color: #805AD5;
    }

.achievement-content {
      flex: 1;
    }

.achievement-title {
      font-size: 1rem;
      font-weight: normal;
      margin-bottom: 0.25rem;
      color: #5D4037;
    }

.achievement-description {
      font-size: 0.875rem;
      color: #7D6E63;
    }

.achievement-close {
      background: none;
      border: none;
      font-size: 0.875rem;
      cursor: pointer;
      color: #4A5568;
    }

/* 水墨画风格的特殊效果 */
    .ink-border {
      position: relative;
      border: 2px solid #8D6E63;
      border-radius: 0.25rem;
      box-shadow: 0 0 15px rgba(141, 110, 99, 0.2);
      background: linear-gradient(135deg, rgba(255, 253, 247, 0.95) 0%, rgba(255, 253, 247, 0.8) 100%);
    }

.ink-border::before {
      content: '';
      position: absolute;
      top: -3px;
      left: -3px;
      right: -3px;
      bottom: -3px;
      border: 1px solid #8D6E63;
      border-radius: 0.375rem;
      z-index: -1;
      opacity: 0.5;
    }
    
.ink-border::after {
      content: '◆';
      position: absolute;
      top: -12px;
      left: 50%;
      transform: translateX(-50%);
      color: #8D6E63;
      font-size: 16px;
      background-color: #FFFDF7;
      padding: 0 8px;
      z-index: 1;
    }

.ink-bg {
      background-color: #FFFDF7;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><rect width="100" height="100" fill="none" stroke="%238D6E63" stroke-width="0.3" stroke-dasharray="5,5" opacity="0.2"/></svg>');
      background-repeat: repeat;
    }

.ink-text {
      position: relative;
      display: inline-block;
      color: #5D4037;
      font-weight: normal;
      text-shadow: 1px 1px 2px rgba(93, 64, 55, 0.2);
    }

.ink-text::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      width: 100%;
      height: 2px;
      background-color: #8D6E63;
      transform: scaleX(0.8) translateX(10%);
      opacity: 0.7;
    }

/* 古风装饰元素 */
.ink-decoration {
      position: relative;
      padding: 1rem;
      margin: 0.5rem 0;
      border-left: 3px solid #8D6E63;
      background: linear-gradient(90deg, rgba(141, 110, 99, 0.1) 0%, rgba(141, 110, 99, 0) 100%);
    }

/* 统一简约风格按钮样式 */
.ink-button {
  background: linear-gradient(135deg, #8D6E63 0%, #6D4C41 100%) !important;
  border: 2px solid #5D4037 !important;
  border-radius: 16px !important;
  padding: 0.75rem 1.5rem;
  font-size: 1rem;
  font-weight: normal !important;
  cursor: pointer;
  transition: all 0.3s ease;
  font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
  color: white !important;
  text-shadow: none !important;
  letter-spacing: 1px !important;
  overflow: hidden !important;
  box-shadow: 
    0 0 25px rgba(141, 110, 99, 0.5),
    0 4px 12px rgba(139, 69, 19, 0.3),
    inset 0 1px 3px rgba(255, 255, 255, 0.4),
    inset 0 -2px 4px rgba(0, 0, 0, 0.2) !important;
}

.ink-button:hover {
  background: linear-gradient(135deg, #7D6E63 0%, #5D4037 100%) !important;
  transform: translateY(-2px) !important;
  box-shadow: 
    0 0 35px rgba(141, 110, 99, 0.7),
    0 6px 16px rgba(139, 69, 19, 0.4),
    inset 0 1px 4px rgba(255, 255, 255, 0.5),
    inset 0 -3px 6px rgba(0, 0, 0, 0.3) !important;
  border-radius: 18px !important;
}

.ink-button:active {
  transform: translateY(0) !important;
  box-shadow: 
    0 0 15px rgba(141, 110, 99, 0.3),
    0 2px 6px rgba(139, 69, 19, 0.2),
    inset 0 1px 2px rgba(255, 255, 255, 0.2),
    inset 0 -1px 3px rgba(0, 0, 0, 0.2) !important;
}

.event-result-modal-confirm {
      background: linear-gradient(135deg, #8D6E63 0%, #6D4C41 100%) !important;
      border: 2px solid #5D4037 !important;
      border-radius: 16px !important;
      padding: 0.5rem 1.5rem;
      font-weight: normal !important;
      cursor: pointer;
      font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
      color: white !important;
      text-shadow: none !important;
      letter-spacing: 1px !important;
      overflow: hidden !important;
      box-shadow: 
        0 0 25px rgba(141, 110, 99, 0.5),
        0 4px 12px rgba(139, 69, 19, 0.3),
        inset 0 1px 3px rgba(255, 255, 255, 0.4),
        inset 0 -2px 4px rgba(0, 0, 0, 0.2) !important;
      transition: all 0.3s ease !important;
    }

    .event-result-modal-confirm:hover {
      background: linear-gradient(135deg, #7D6E63 0%, #5D4037 100%) !important;
      transform: translateY(-2px) !important;
      box-shadow: 
        0 0 35px rgba(141, 110, 99, 0.7),
        0 6px 16px rgba(139, 69, 19, 0.4),
        inset 0 1px 4px rgba(255, 255, 255, 0.5),
        inset 0 -3px 6px rgba(0, 0, 0, 0.3) !important;
      border-radius: 18px !important;
    }

    .event-result-modal-confirm:active {
      transform: translateY(0) !important;
      box-shadow: 
        0 0 15px rgba(141, 110, 99, 0.3),
        0 2px 6px rgba(139, 69, 19, 0.2),
        inset 0 1px 2px rgba(255, 255, 255, 0.2),
        inset 0 -1px 3px rgba(0, 0, 0, 0.2) !important;
    }

/* 小号按钮 */
.ink-button-small {
  border-radius: 14px !important;
  padding: 0.4rem 0.9rem !important;
  font-size: 0.875rem !important;
}

.ink-button-small:hover {
  border-radius: 16px !important;
}

.ink-button-small:active {
  transform: translateY(0) !important;
  box-shadow: 
    0 0 15px rgba(141, 110, 99, 0.3),
    0 2px 6px rgba(139, 69, 19, 0.2),
    inset 0 1px 2px rgba(255, 255, 255, 0.2),
    inset 0 -1px 3px rgba(0, 0, 0, 0.2) !important;
}

/* 主要按钮 */
.ink-button-primary {
  background: linear-gradient(135deg, #8D6E63 0%, #6D4C41 100%) !important;
  border: 2px solid #5D4037 !important;
  border-radius: 16px !important;
  box-shadow: 
    0 0 25px rgba(141, 110, 99, 0.5),
    0 4px 12px rgba(139, 69, 19, 0.3),
    inset 0 1px 3px rgba(255, 255, 255, 0.4),
    inset 0 -2px 4px rgba(0, 0, 0, 0.2) !important;
  font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
  font-weight: normal !important;
  color: white !important;
}

.ink-button-primary:hover {
  background: linear-gradient(135deg, #7D6E63 0%, #5D4037 100%) !important;
  transform: translateY(-2px) !important;
  box-shadow: 
    0 0 35px rgba(141, 110, 99, 0.7),
    0 6px 16px rgba(139, 69, 19, 0.4),
    inset 0 1px 4px rgba(255, 255, 255, 0.5),
    inset 0 -3px 6px rgba(0, 0, 0, 0.3) !important;
  border-radius: 18px !important;
}

.ink-button-primary:active {
  transform: translateY(0) !important;
  box-shadow: 
    0 0 15px rgba(141, 110, 99, 0.3),
    0 2px 6px rgba(139, 69, 19, 0.2),
    inset 0 1px 2px rgba(255, 255, 255, 0.2),
    inset 0 -1px 3px rgba(0, 0, 0, 0.2) !important;
}

/* 次要按钮 */
.ink-button-secondary {
  background: linear-gradient(135deg, #8D6E63 0%, #6D4C41 100%) !important;
  border: 2px solid #5D4037 !important;
  border-radius: 16px !important;
  box-shadow: 
    0 0 25px rgba(141, 110, 99, 0.5),
    0 4px 12px rgba(139, 69, 19, 0.3),
    inset 0 1px 3px rgba(255, 255, 255, 0.4),
    inset 0 -2px 4px rgba(0, 0, 0, 0.2) !important;
  font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
  font-weight: normal !important;
  color: white !important;
  text-shadow: none !important;
  letter-spacing: 1px !important;
  overflow: hidden !important;
}

.ink-button-secondary:hover {
  background: linear-gradient(135deg, #7D6E63 0%, #5D4037 100%) !important;
  transform: translateY(-2px) !important;
  box-shadow: 
    0 0 35px rgba(141, 110, 99, 0.7),
    0 6px 16px rgba(139, 69, 19, 0.4),
    inset 0 1px 4px rgba(255, 255, 255, 0.5),
    inset 0 -3px 6px rgba(0, 0, 0, 0.3) !important;
  border-radius: 18px !important;
}

.ink-button-secondary:active {
  transform: translateY(0) !important;
  box-shadow: 
    0 0 15px rgba(141, 110, 99, 0.3),
    0 2px 6px rgba(139, 69, 19, 0.2),
    inset 0 1px 2px rgba(255, 255, 255, 0.2),
    inset 0 -1px 3px rgba(0, 0, 0, 0.2) !important;
}

/* 简约风格"下一天"按钮（保持与主样式一致） */
.ink-button-carved {
  background: linear-gradient(135deg, #8D6E63 0%, #6D4C41 100%) !important;
  border: 2px solid #5D4037 !important;
  border-radius: 16px !important;
  box-shadow: 
    0 0 25px rgba(141, 110, 99, 0.5),
    0 4px 12px rgba(139, 69, 19, 0.3),
    inset 0 1px 3px rgba(255, 255, 255, 0.4),
    inset 0 -2px 4px rgba(0, 0, 0, 0.2) !important;
  font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
  font-weight: normal !important;
  color: white !important;
  text-shadow: none !important;
  letter-spacing: 1px !important;
  overflow: hidden !important;
}

.ink-button-carved:hover {
  background: linear-gradient(135deg, #7D6E63 0%, #5D4037 100%) !important;
  transform: translateY(-2px) !important;
  box-shadow: 
    0 0 35px rgba(141, 110, 99, 0.7),
    0 6px 16px rgba(139, 69, 19, 0.4),
    inset 0 1px 4px rgba(255, 255, 255, 0.5),
    inset 0 -3px 6px rgba(0, 0, 0, 0.3) !important;
  border-radius: 18px !important;
}

.ink-button-carved:active {
  transform: translateY(0) !important;
  box-shadow: 
    0 0 15px rgba(141, 110, 99, 0.3),
    0 2px 6px rgba(139, 69, 19, 0.2),
    inset 0 1px 2px rgba(255, 255, 255, 0.2),
    inset 0 -1px 3px rgba(0, 0, 0, 0.2) !important;
}

.ink-button-carved.ink-button-small {
  border-radius: 14px !important;
  padding: 0.4rem 0.9rem !important;
}

.ink-button-carved.ink-button-small:hover {
  border-radius: 16px !important;
}

/* 响应式设计 */
    @media (max-width: 1024px) {
      .location-grid {
        grid-template-columns: repeat(2, 1fr);
      }

      .action-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

@media (max-width: 640px) {
      .location-grid {
        grid-template-columns: 1fr;
      }

.action-grid {
        grid-template-columns: 1fr;
      }

.status-grid {
        grid-template-columns: 1fr;
      }

.header {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
      }

.header-info {
        width: 100%;
        justify-content: space-between;
      }
    }
  </style>
<!-- 添加iOS特定的旋转支持 -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <style>
    /* 防止iOS上的双击缩放 */
    * {
      touch-action: manipulation;
    }

/* 滑块小游戏样式 */
    .slider-game-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

.slider-game-modal.active {
      opacity: 1;
      visibility: visible;
    }

.slider-game-content {
      background-color: #FFFDF7;
      border-radius: 0.25rem;
      max-width: 600px;
      width: 90%;
      padding: 1.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
      transform: translateY(-20px);
      transition: all 0.3s ease;
    }

.slider-game-modal.active .slider-game-content {
      transform: translateY(0);
    }

.slider-game-title {
      font-size: 1.5rem;
      font-weight: normal;
      color: #5D4037;
      text-align: center;
      margin-bottom: 1.5rem;
    }

.slider-game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

/* 时间倒数条 */
    .timer-bar-container {
      width: 100%;
      height: 10px;
      background-color: #E2E8F0;
      border-radius: 5px;
      margin-bottom: 2rem;
      overflow: hidden;
    }

.timer-bar {
      height: 100%;
      width: 100%;
      background-color: #E53E3E;
      transition: width 0.1s linear;
    }

/* 滑块轨道 */
    .slider-track {
      position: relative;
      width: 100%;
      height: 40px;
      background-color: #E2E8F0;
      border-radius: 0;
      overflow: hidden;
      margin-bottom: 1rem;
      display: flex;
    }

/* 目标区域 */
    .target-area {
      position: absolute;
      background-color: #48BB78;
      height: 100%;
      border-radius: 0;
      transition: width 0.3s ease, left 0.3s ease;
    }

/* 非目标区域 */
    .non-target-area {
      background-color: #D69E2E;
      height: 100%;
      flex: 1;
    }

/* 三角形滑块 */
    .slider-triangle {
      position: absolute;
      width: 0;
      height: 0;
      border-left: 15px solid transparent;
      border-right: 15px solid transparent;
      border-top: 25px solid #2D3748;
      /* 滑块覆盖一部分轨道上方，基于容器定位 */
      top: -25px; /* 覆盖轨道5px */
      left: 0;
      transition: left 0.1s linear;
      transform-origin: center bottom;
    }

/* 控制按钮 */
    .slider-controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 2rem;
    }

/* 滑块按钮已使用古风样式，无需单独定义 */
.slider-button {
      margin-bottom: 1rem;
    }

.slider-instructions {
      font-size: 0.875rem;
      color: #4A5568;
      text-align: center;
    }

/* 响应式设计 */
    @media (max-width: 640px) {
      .slider-track {
        width: 300px;
      }
    }

/* 横屏模式样式调整 */
    @media screen and (orientation: landscape) {
      /* 调整卡片网格在横屏时的布局 */
      .card-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 10px;
      }

/* 调整游戏容器在横屏时的布局 */
      .game-container {
        flex-direction: row;
        height: 100vh;
      }

/* 确保重要元素在横屏时有合适的大小 */
      .card {
        max-height: 200px;
      }

/* 调整资源栏在横屏时的布局 */
      .resources-grid {
        max-width: 400px;
      }
    }
  </style>
</head>
<body class="ink-bg" onresize="checkOrientation()">
  <!-- 添加屏幕方向检测脚本 -->
  <script>
    // 检测屏幕方向变化
    function checkOrientation() {
      const isLandscape = window.innerWidth > window.innerHeight;
      const gameContainer = document.querySelector('.game-container');

if (isLandscape) {
        document.body.classList.add('landscape-mode');
        document.body.classList.remove('portrait-mode');
      } else {
        document.body.classList.add('portrait-mode');
        document.body.classList.remove('landscape-mode');
      }

// 重新渲染游戏元素以适应新的方向
      if (typeof renderLocations === 'function') renderLocations();
      if (typeof renderResources === 'function') renderResources();
      if (typeof renderActions === 'function') renderActions();
    }

// 页面加载时检查初始方向
    window.addEventListener('load', checkOrientation);
    // 设备旋转时检查方向
    window.addEventListener('orientationchange', checkOrientation);
  </script>
  <!-- 开始屏幕 -->
  <div class="start-screen ink-bg" id="startScreen">
    <div class="start-screen-content ink-border">
      <h1 class="start-screen-title ink-text">论一个乞丐如何在古代挣扎求生</h1>
      <img src="UI/封面.jpg" alt="游戏背景" class="start-screen-image">
      <p class="start-screen-description">
        开局一只碗，宏图霸业一朝揽
      </p>
      <button class="start-screen-button ink-button ink-button-primary" id="startGameButton">开始游戏</button>
      <div class="start-screen-save-load" style="display: flex; justify-content: center; flex-wrap: wrap; margin-top: 1.5rem;">

      </div>
      </div>
  </div>

  <!-- 教程模态框 -->
  <div class="tutorial-modal" id="tutorialModal">
    <div class="tutorial-modal-content ink-border">
      <div class="tutorial-modal-header">
        <h2 class="tutorial-modal-title ink-text">游戏教程</h2>
        <button class="tutorial-modal-close ink-button ink-button-small" id="closeTutorialButton">&times;</button>
      </div>
      <div class="tutorial-steps">
        <div class="tutorial-step" id="tutorialStep1">
          <h3 class="tutorial-step-title">欢迎来到乞丐生存</h3>
          <p class="tutorial-step-content">在这个游戏中，你将扮演一名古代乞丐，通过收集资源、制作工具和应对各种事件来生存下去。</p>
          <p class="tutorial-step-content">游戏的核心是卡牌系统，所有的资源、地点、状态和行动都以卡牌形式呈现。</p>
        </div>
        <div class="tutorial-step" id="tutorialStep2">
          <h3 class="tutorial-step-title">背包管理</h3>
          <p class="tutorial-step-content">你需要管理背包中的多种物品，包括食物、钱币、材料和工具。这些物品可以通过探索地点、乞讨或制作获得。</p>
          <p class="tutorial-step-content">注意：食物会随着时间消耗，你需要保持足够的食物来维持生存。</p>
        </div>
        <div class="tutorial-step" id="tutorialStep3">
          <h3 class="tutorial-step-title">卡牌组合</h3>
          <p class="tutorial-step-content">将不同的卡牌拖放到组合区域可以创建新的物品或执行特定行动。例如：</p>
          <ul class="tutorial-step-content">
            <li>将"破碗"和"东西市"组合可以进行乞讨</li>
            <li>将"残羹剩饭"和"破碗"组合可以食用</li>
            <li>将"破布"和"木棍"组合可以制作简易拐杖</li>
          </ul>
          <p class="tutorial-step-content">尝试不同的组合来发现新的配方！</p>
        </div>
        <div class="tutorial-step" id="tutorialStep4">
          <h3 class="tutorial-step-title">状态管理</h3>
          <p class="tutorial-step-content">你的角色有多种状态需要关注：</p>
          <ul class="tutorial-step-content">
            <li>饱食：需要残羹剩饭来增加饱食度</li>
            <li>水分：需要饮用补充水分</li>
            <li>体温：需要保暖物品维持正常体温</li>
            <li>健康：避免生病，保持良好状态</li>
            <li>精神：影响你的乞讨效率和决策能力</li>
            <li>声望：影响NPC对你的态度和可访问的地点</li>
          </ul>
          <p class="tutorial-step-content">状态过低会影响你的生存能力，甚至导致死亡。</p>
        </div>
        <div class="tutorial-step" id="tutorialStep5">
          <h3 class="tutorial-step-title">探索地点</h3>
          <p class="tutorial-step-content">不同的地点提供不同的资源和事件：</p>
          <ul class="tutorial-step-content">
            <li>东西市：乞讨的主要地点</li>
            <li>灰坑：寻找食物残渣和材料</li>
            <li>万佛寺：可以获得免费残羹剩饭和休息</li>
            <li>锣鼓巷：乞讨效率高但风险大</li>
            <li>鸡毛房：与其他乞丐互动</li>
          </ul>
          <p class="tutorial-step-content">点击地点卡牌可以探索该地点，获得资源或触发事件。</p>
        </div>
        <div class="tutorial-step" id="tutorialStep6">
          <h3 class="tutorial-step-title">时间与季节</h3>
          <p class="tutorial-step-content">游戏以回合制进行，每个回合代表一天。时间的流逝会影响：</p>
          <ul class="tutorial-step-content">
            <li>资源消耗：残羹剩饭和保暖物品会随时间消耗</li>
            <li>季节变化：不同季节有不同的生存挑战</li>
            <li>事件触发：某些事件只在特定时间或季节发生</li>
          </ul>
          <p class="tutorial-step-content">合理规划你的时间，为即将到来的季节做好准备。</p>
        </div>
        <div class="tutorial-step" id="tutorialStep7">
          <h3 class="tutorial-step-title">目标与结局</h3>
          <p class="tutorial-step-content">游戏有多种可能的结局，取决于你的选择和行动：</p>
          <ul class="tutorial-step-content">
            <li>生存结局：尽可能长时间地活下去</li>
            <li>财富结局：积累足够的财富摆脱乞丐身份</li>
            <li>声望结局：获得足够的声望成为乞丐之王</li>
            <li>知识结局：学习足够的技能找到工作</li>
            <li>死亡结局：因饱食度过低、体温异常、疾病或其他原因死亡</li>
          </ul>
          <p class="tutorial-step-content">你的每一个选择都会影响最终的结局。</p>
        </div>
        <div class="tutorial-step" id="tutorialStep8">
          <h3 class="tutorial-step-title">开始你的生存之旅</h3>
          <p class="tutorial-step-content">现在你已经了解了游戏的基本机制，是时候开始你的生存之旅了。</p>
          <p class="tutorial-step-content">记住：在这个残酷的世界中，每一个选择都至关重要。祝你好运！</p>
        </div>
      </div>
      <div class="tutorial-navigation">
        <button class="tutorial-button ink-button ink-button-primary" id="closeTutorialBtn">关闭</button>
      </div>
      </div>
  </div>

  <!-- 游戏容器 -->
  <div class="game-container" id="gameContainer" style="display: none;">
    <!-- 帮助按钮 -->
    <button class="help-button ink-button ink-button-small" id="helpButton" style="position: absolute; top: 1rem; left: 1rem; border-radius: 50%; width: 2rem; height: 2rem; display: flex; align-items: center; justify-content: center; font-size: 1.25rem; z-index: 1000;">?</button>
    <!-- 天气效果容器 -->
    <div id="weatherEffectsContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 999;"></div>
    <!-- 头部 -->
    <header class="header">
      <h1 class="header-title ink-text">乞丐生存</h1>
      <div class="header-info">
        <div class="day-indicator" style="display: flex; align-items: center; gap: 1rem;">
          第 <span class="day-number" id="dayNumber">1</span> 天 <span class="time-of-day" id="timeOfDay">清晨</span>
          <button id="nextDayButton" onclick="goToNextDay()" class="ink-button-carved ink-button-small" style="white-space: nowrap; position: relative; overflow: hidden;">
            <span class="button-text">下一天</span>
            <!-- 祥云花纹装饰 -->
            <div class="carved-pattern carved-clouds"></div>
            <!-- 梅花花纹装饰 -->
            <div class="carved-pattern carved-plum"></div>
            <!-- 竹叶花纹装饰 -->
            <div class="carved-pattern carved-bamboo"></div>
          </button>
        </div>

        <button id="startScreenSaveButton" class="ink-button ink-button-primary" style="margin-right: 0.5rem;">
          保存游戏进度
        </button>
        <button id="gameScreenLoadButton" class="ink-button ink-button-secondary" onclick="handleLoadGame()" style="margin-right: 0.5rem;">
          加载游戏进度
        </button>
        <!-- 返回按钮已禁用 -->
      <!-- <button id="backToStartButton" onclick="handleBackToStart()" style="padding: 0.5rem 1rem; background-color: #718096; color: white; border: none; border-radius: 0.5rem; cursor: pointer; font-size: 0.875rem; font-weight: 600; transition: background-color 0.2s ease;">
            返回开始界面
          </button> -->
      </div>
    </header>

    <!-- 主要内容 -->
    <div class="main-content">
      <!-- 左侧状态栏 -->
      <div class="sidebar">
        <div class="sidebar-section ink-border">
          <h2 class="sidebar-section-title ink-text">人物状态</h2>
          <!-- 季节和天气显示 -->
          <div class="season-weather-indicator" style="display: flex; align-items: center; justify-content: center; gap: 1rem; margin-bottom: 1rem; font-size: 1.1rem;">
            <div class="season-indicator" style="display: flex; align-items: center; gap: 0.5rem;">
              <span class="season-icon" id="seasonIcon">🌱</span>
              <span id="seasonName" style="font-weight: 600; color: #2D3748;">春季</span>
            </div>
            <div class="weather-indicator" style="display: flex; align-items: center; gap: 0.5rem;">
              <span class="weather-icon" id="weatherIcon">☀️</span>
              <span id="weatherName" style="font-weight: 600; color: #2D3748;">晴天</span>
            </div>
          </div>
          <!-- 状态栏控制按钮 -->
          <div class="status-controls" style="display: flex; gap: 0.5rem; margin-bottom: 1rem; justify-content: center; font-size: 1.5rem;">
            <button id="equipmentButton" class="ink-button ink-button-small" style="margin: 0.25rem; font-size: 1.1rem;">
              装备
            </button>
            <button id="skillsButton" class="ink-button ink-button-small" style="margin: 0.25rem; font-size: 1.1rem;">
              技能
            </button>
            <button id="mapButton" class="ink-button ink-button-small" style="margin: 0.25rem; font-size: 1.1rem;">
              地图
            </button>
          </div>
          <div class="status-grid">
            <!-- 血量 -->
            <div class="card status" id="bloodCard">
              <div class="card-content">
                <div class="card-title" style="font-size: 0.875rem;">
                  血量
                  <span class="status-percentage" id="bloodPercentage" style="font-size: 0.875rem;">100%</span>
                </div>
                <div class="progress-bar">
                  <div class="progress-bar-fill" id="bloodBar" style="width: 100%; background-color: #E53E3E;"></div>
                </div>
              </div>
            </div>
            <!-- 饱食 -->
            <div class="card status" id="hungerCard">
              <div class="card-content">
                <div class="card-title" style="font-size: 0.875rem;">
                  饱食
                  <span class="status-percentage" id="hungerPercentage" style="font-size: 0.875rem;">50%</span>
                </div>
                <div class="progress-bar">
                  <div class="progress-bar-fill" id="hungerBar" style="width: 50%; background-color: #48BB78;"></div>
                </div>
              </div>
            </div>
            <!-- 水分 -->
            <div class="card status" id="thirstCard">
              <div class="card-content">
                <div class="card-title" style="font-size: 0.875rem;">
                  水分
                  <span class="status-percentage" id="thirstPercentage" style="font-size: 0.875rem;">100%</span>
                </div>
                <div class="progress-bar">
                  <div class="progress-bar-fill" id="thirstBar" style="width: 100%; background-color: #3182CE;"></div>
                </div>
              </div>
            </div>
            <!-- 精神 -->
            <div class="card status" id="spiritCard">
              <div class="card-content">
                <div class="card-title" style="font-size: 0.875rem;">
                  精神
                  <span class="status-percentage" id="spiritPercentage" style="font-size: 0.875rem;">70%</span>
                </div>
                <div class="progress-bar">
                  <div class="progress-bar-fill" id="spiritBar" style="width: 70%; background-color: #805AD5;"></div>
                </div>
              </div>
            </div>
            <!-- 健康 -->
            <div class="card status" id="healthCard">
              <div class="card-content">
                <div class="card-title" style="font-size: 0.875rem;">
                  健康
                  <span class="status-percentage" id="healthPercentage" style="font-size: 0.875rem;">80%</span>
                </div>
                <div class="progress-bar">
                  <div class="progress-bar-fill" id="healthBar" style="width: 80%; background-color: #38A169;"></div>
                </div>
              </div>
            </div>
            <!-- 体温 -->
            <div class="card status" id="coldCard">
              <div class="card-content">
                <div class="card-title" style="font-size: 0.875rem;">
                  体温
                  <span class="status-percentage" id="coldPercentage" style="font-size: 0.875rem;">36℃</span>
                </div>
                <div class="progress-bar">
                  <div class="progress-bar-fill" id="coldBar" style="width: 31.25%; background-color: #3182CE;"></div>
                </div>
              </div>
            </div>
            <!-- 声望 -->
            <div class="card status" id="reputationCard">
              <div class="card-content">
                <div class="card-title" style="font-size: 0.875rem;">
                  声望
                  <span class="status-percentage" id="reputationPercentage" style="font-size: 0.875rem;">20%</span>
                </div>
                <div class="progress-bar">
                  <div class="progress-bar-fill" id="reputationBar" style="width: 20%; background-color: #D69E2E;"></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 主要区域 -->
      <div class="main-area">
        <!-- 行动区域 -->
        <div class="sidebar-section ink-border">
          <h2 class="sidebar-section-title ink-text">行动 <span id="actionPointsValue" style="font-size: 1rem; font-weight: normal;">(行动点 20/20)</span></h2>
          
          <div class="action-grid" id="actionGrid">
            <!-- 行动卡牌将通过JavaScript动态生成 -->
          </div>
        </div>

        <!-- 背包区域 -->
        <div class="sidebar-section ink-border">
          <div class="flex justify-between items-center">
            <h2 class="sidebar-section-title ink-text">背包</h2>
            <button id="craftingButton" class="ink-button ink-button-small" style="font-size: 1.1rem;">制作</button>
          </div>

          <!-- 分类标签 -->
          <div class="inventory-tabs" style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem; border-bottom: 1px solid #E2E8F0; padding-bottom: 0.5rem;">
            <button class="inventory-tab ink-button ink-button-small ink-button-primary active" data-category="all" style="font-size: 1.1rem;">全部</button>
            <button class="inventory-tab ink-button ink-button-small" data-category="food" style="font-size: 1.1rem;">食物</button>
            <button class="inventory-tab ink-button ink-button-small" data-category="material" style="font-size: 1.1rem;">基础材料</button>
            <button class="inventory-tab ink-button ink-button-small" data-category="equipment" style="font-size: 1.1rem;">装备</button>
            <button class="inventory-tab ink-button ink-button-small" data-category="other" style="font-size: 1.1rem;">其它</button>
          </div>

          <!-- 背包容器 -->
          <div class="resource-container">
            <!-- 背包网格 -->
            <div class="resource-grid" id="resourceGrid">
              <!-- 背包物品将通过JavaScript动态生成 -->
            </div>
            <!-- 独立滚动条 -->
            <div class="resource-scrollbar">
              <div class="resource-scrollbar-thumb" id="resourceScrollbarThumb"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

  <!-- 地图模态框 -->
  <div class="map-modal" id="mapModal">
    <div class="map-modal-content ink-border">
      <div class="map-modal-header">
        <button class="map-modal-close ink-button ink-button-small" id="closeMapButton">&times;</button>
      </div>
      <div class="map-modal-body">
        <div id="mapLocationGrid">
          <!-- 地点卡牌将通过JavaScript动态生成 -->
        </div>
      </div>
    </div>
  </div>

  <!-- 事件模态框 -->
  <div class="event-modal" id="eventModal">
    <div class="event-modal-content ink-border">
      <div class="event-modal-header">
        <h2 class="event-modal-title ink-text" id="eventTitle">事件</h2>
        <button class="event-modal-close ink-button ink-button-small" id="closeEventButton">&times;</button>
      </div>
      <div class="event-modal-body">
        <p class="event-modal-text" id="eventText">事件描述将显示在这里。</p>
        <div class="event-modal-options" id="eventOptions">
          <!-- 事件选项将通过JavaScript动态生成 -->
        </div>
      </div>
      </div>
  </div>

  <!-- 配方模态框 -->
  <div class="recipe-modal" id="recipeModal">
    <div class="recipe-modal-content ink-border">
      <div class="recipe-modal-header">
        <h2 class="recipe-modal-title ink-text">已知配方</h2>
        <button class="recipe-modal-close ink-button ink-button-small" id="closeRecipeButton">&times;</button>
      </div>
      <div class="recipe-grid" id="recipeGrid">
        <!-- 配方将通过JavaScript动态生成 -->
      </div>
      </div>
  </div>

  <!-- 制作窗口模态框 -->
  <div class="crafting-modal" id="craftingModal">
    <div class="crafting-modal-content ink-border">
      <div class="crafting-modal-header">
        <h2 class="crafting-modal-title ink-text" style="font-size: 1.6rem;">制作</h2>
        <button class="crafting-modal-close ink-button ink-button-small" id="closeCraftingButton">&times;</button>
      </div>
      <div class="crafting-modal-body">
        <!-- 左侧：背包卡牌列表 -->
        <div class="crafting-left">
          <h3 class="crafting-section-title" style="font-size: 1.3rem;">背包卡牌</h3>
          <div class="crafting-inventory" id="craftingInventory">
            <!-- 卡牌将通过JavaScript动态生成 -->
          </div>
        </div>

<!-- 右侧：组合区域 -->
        <div class="crafting-right">
          <h3 class="crafting-section-title" style="font-size: 1.3rem;">组合区域</h3>
          <div class="crafting-buttons">
            <button class="crafting-button ink-button ink-button-small" id="craftButton" disabled style="font-size: 1.1rem;">组合</button>
            <button class="crafting-button ink-button ink-button-small" id="craftRecipeButton" style="font-size: 1.1rem;">配方</button>
          </div>
          <div class="crafting-slots" id="craftingSlots">
            <div class="crafting-slot" data-slot="1"></div>
            <div class="crafting-slot" data-slot="2"></div>
            <div class="crafting-slot" data-slot="3"></div>
          </div>
        </div>
      </div>
      </div>
  </div>

  <!-- 游戏结束模态框 -->
  <div class="game-over-modal" id="gameOverModal">
    <div class="game-over-modal-content ink-border">
      <div class="game-over-modal-header">
        <h2 class="game-over-modal-title ink-text" id="gameOverTitle">游戏结束</h2>
      </div>
      <div class="game-over-modal-body">
        <div class="ink-decoration">
          <p class="game-over-modal-text" id="gameOverText">游戏结束原因将显示在这里。</p>
        </div>
        <div class="game-over-stats">
          <h3 class="game-over-stats-title ink-text">生存统计</h3>
          <div class="game-over-stats-grid">
            <div class="game-over-stat">
              <span>生存天数：</span>
              <span class="game-over-stat-value" id="daysSurvived">0</span>
            </div>
            <div class="game-over-stat">
              <span>最高声望：</span>
              <span class="game-over-stat-value" id="maxReputation">0%</span>
            </div>
            <div class="game-over-stat">
              <span>收集资源：</span>
              <span class="game-over-stat-value" id="resourcesCollected">0</span>
            </div>
            <div class="game-over-stat">
              <span>发现配方：</span>
              <span class="game-over-stat-value" id="recipesDiscovered">0</span>
            </div>
          </div>
        </div>
        <div class="game-over-modal-options">
          <button class="game-over-button ink-button ink-button-primary" id="exitGameButton">返回主页面</button>
        </div>
      </div>
    </div>
  </div>

  <!-- 通知 -->
  <div class="notification ink-border" id="notification">
    <button class="notification-close ink-button ink-button-small" id="closeNotificationButton">&times;</button>
    <h3 class="notification-title ink-text" id="notificationTitle">通知</h3>
    <div class="ink-decoration">
      <p class="notification-message" id="notificationMessage">通知内容将显示在这里。</p>
    </div>
    <div class="notification-actions">
      <button class="notification-button ink-button ink-button-small" id="notificationOKButton">知道了</button>
    </div>
  </div>

  <!-- 行动点不足提示窗口 -->
  <div class="action-points-modal" id="actionPointsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 2000; align-items: center; justify-content: center;">
    <div class="action-points-modal-content ink-border" style="padding: 2rem; max-width: 400px; text-align: center;">
      <div class="ink-decoration">
        <h3 class="action-points-modal-title ink-text">行动点不足</h3>
        <p class="action-points-modal-message">
          行动点不足，可以点击进入下一天即可恢复满行动点
        </p>
      </div>
      <div class="action-points-modal-actions" style="display: flex; gap: 1rem; justify-content: center;">
        <button class="action-points-modal-button ink-button ink-button-primary" id="closeActionPointsModal">
          关闭
        </button>
        <button class="action-points-modal-button ink-button-carved ink-button-small" id="endDayActionPointsModal" style="position: relative; overflow: hidden;">
          <span class="button-text">进入下一天</span>
          <!-- 祥云花纹装饰 -->
          <div class="carved-pattern carved-clouds"></div>
          <!-- 梅花花纹装饰 -->
          <div class="carved-pattern carved-plum"></div>
          <!-- 竹叶花纹装饰 -->
          <div class="carved-pattern carved-bamboo"></div>
        </button>
      </div>
      </div>
  </div>

  <!-- 成就通知 -->
  <div class="achievement-modal ink-border" id="achievementModal">
    <div class="achievement-icon">
      <i class="fa fa-trophy" aria-hidden="true"></i>
    </div>
    <div class="achievement-content">
      <h3 class="achievement-title ink-text" id="achievementTitle">成就解锁</h3>
      <p class="achievement-description" id="achievementDescription">成就描述将显示在这里。</p>
    </div>
    <button class="achievement-close ink-button ink-button-small" id="closeAchievementButton">&times;</button>
  </div>

  <!-- 滑块小游戏模态框 -->
  <div class="slider-game-modal" id="sliderGameModal">
    <div class="slider-game-content ink-border">
      <h2 class="slider-game-title ink-text">滑块小游戏</h2>
      <div class="slider-game-container">
        <!-- 滑块轨道和区域 -->
        <div class="slider-track" id="sliderTrack">
          <div class="target-area" id="targetArea"></div>
          <div class="non-target-area" id="nonTargetArea1"></div>
          <div class="non-target-area" id="nonTargetArea2"></div>
        </div>

<!-- 三角形滑块 -->
        <div class="slider-triangle" id="sliderTriangle"></div>

        <!-- 时间倒数条 -->
        <div class="timer-bar-container">
          <div class="timer-bar" id="timerBar"></div>
        </div>

<!-- 控制按钮 -->
        <div class="slider-controls">
          <button class="slider-button ink-button ink-button-primary" id="stopButton">停止</button>
          <div class="slider-instructions">按空格键或点击停止按钮</div>
        </div>
      </div>
      </div>
  </div>

  <script>
    // 全局变量 - 不可消耗的碗类卡牌
    const nonConsumableBowls = ['bowl', 'clay_bowl', 'pottery_bowl', 'silver_bowl', 'gold_bowl'];
    
    // 游戏数据
    const gameData = {
      day: 1,
      timeOfDay: 'early_morning', // early_morning, morning, afternoon, evening, night
      timeTurns: 0, // 当前时间段的回合数
      season: 'spring', // spring, summer, autumn, winter
      weather: 'sunny', // sunny, rainy, snowy
      begging_chance: 0, // 乞讨成功率加成
      fastingDayClaimed: false, // 放斋日是否已经领取过物品
      combinationSlots: { 0: null, 1: null, 2: null, 3: null },
      resources: {
        'cangenshengfan': { name: '残羹剩饭', description: '乞讨或搜寻获得的食物残渣，虽然能增加饱食度，但可能影响健康', amount: 0, image: 'UI/残羹剩饭.jpg', type: 'consumable', category: 'food' },
        'money': { name: '钱币', amount: 0, image: 'UI/钱币.jpg', category: 'material' },
        'cloth': { name: '破布', amount: 0, image: 'UI/破布.jpg', category: 'material' },
        'stick': { name: '木棍', amount: 0, image: 'UI/木棍.jpg', category: 'material' },
        'paper': { name: '废纸', amount: 0, image: 'UI/废纸.jpg', category: 'material' },
        'bowl': { name: '破碗', amount: 1, image: 'UI/破碗.jpg', category: 'material' },
        'medicine': { name: '灵药', description: '珍贵的草药，能恢复大量健康', amount: 0, image: 'UI/灵药.jpg', type: 'consumable', category: 'food' },
        'cornbread': { name: '窝窝头', description: '粗粮制成的干粮，能有效补充体力', amount: 0, image: 'UI/窝窝头.jpg', type: 'consumable', category: 'food' },
        'porridge': { name: '稀粥', description: '寺庙施舍的稀粥，能缓解饥饿', amount: 0, image: 'UI/稀粥.jpg', type: 'consumable', category: 'food' },
        // 新增资源定义
        'herb': { name: '草药', description: '可以用来制作药品的植物', amount: 0, image: 'UI/草药.jpg', category: 'material' },
        'pill': { name: '药丸', description: '由草药制成的药品，可恢复大量健康', amount: 0, image: 'UI/药丸.jpg', type: 'consumable', category: 'food' },
        'bamboo': { name: '竹子', description: '坚韧的竹子，可用于制作工具和武器', amount: 0, image: 'UI/竹子.jpg', category: 'material' },
        'bamboo_bow': { name: '竹弓', description: '用竹子和牛筋制成的弓，攻击力强', amount: 0, image: 'UI/竹弓.jpg', equipmentSlot: 'weapon', durability: 100, damage: 10, hitRate: 10, category: 'equipment' },
        'cow_tendon': { name: '牛筋', description: '坚韧的牛筋，用于制作弓弦等', amount: 0, image: 'UI/牛筋.jpg', category: 'material' },
        'wild_buffalo': { name: '野牛', description: '野生的水牛，可以获取生肉和牛筋', amount: 0, image: 'UI/野牛.jpg', category: 'other' },
        'raw_meat': { name: '生肉', description: '未加工的肉类，需要烹饪后食用', amount: 0, image: 'UI/生肉.jpg', type: 'consumable', category: 'food', isRaw: true },
        'cooked_meat': { name: '熟肉', description: '烹饪后的肉类，提供丰富的营养', amount: 0, image: 'UI/熟肉.jpg', type: 'consumable', category: 'food', isCooked: true },
        'grilled_fish': { name: '烤鱼', description: '烤制的鱼，美味可口', amount: 0, image: 'UI/烤鱼.jpg', type: 'consumable', category: 'food', isCooked: true },
        'porcelain_bowl': { name: '瓷碗', description: '精致的瓷碗，大幅提高乞讨成功率', amount: 0, image: 'UI/瓷碗.jpg', category: 'material' },

'pottery_bowl': { name: '陶碗', description: '坚固的陶碗，提高乞讨成功率', amount: 0, image: 'UI/陶碗.jpg', category: 'material' },

'silver_bowl': { name: '银碗', description: '珍贵的银碗，显著提高乞讨成功率', amount: 0, image: 'UI/银碗.jpg', category: 'material' },

'gold_bowl': { name: '金碗', description: '奢华的金碗，极大提高乞讨成功率和声望', amount: 0, image: 'UI/金碗.jpg', category: 'material' },
        'gold': { name: '金子', amount: 0, image: 'UI/金子.jpg', category: 'material' },

      },
      status: {
        hunger: 50, // 0-100, 越高越饱，越低越饿
        cold: 36.5,   // 30-50℃, 体温，正常范围36-37℃
        health: 80, // 0-100, 越低越不健康
        blood: 100, // 0-100, 血量，越低越危险
        spirit: 70, // 0-100, 越低精神越差
        reputation: 0, // 0-100, 越高声望越好
        thirst: 100, // 0-100, 越高水分越充足，越低越缺水
        actionPoints: 20 // 行动点，每回合重置
      },
      skills: {
        steal: { level: 0, experience: 0, maxLevel: 10, name: '偷窃' },
        medicine: { level: 0, experience: 0, maxLevel: 10, name: '医术' },
        martial: { level: 0, experience: 0, maxLevel: 10, name: '武术', power: 10 }, // 基础武力值10
        search: { level: 0, experience: 0, maxLevel: 10, name: '搜寻' } // 搜寻技能
      },
      buffs: {},
      skillExpRequired: [0, 10, 30, 60, 100, 150, 210, 280, 360, 450, 550], // 每级升级所需经验
      locations: [
        { 
          id: 'street', 
          name: '东西市', 
          description: '乞讨的主要地点，人流量大但竞争激烈。', 
          image: 'UI/东西市.jpg', 
          available: true,
          resourceType: 'money,food',
          dangerLevel: 'low',
          actionPointCost: 2,
          entryCondition: { reputation: { min: 0 } },
          currentLocation: true,
          actions: ['beg', 'search', 'rest', 'get_water'],
          nightActions: ['beg', 'search', 'rest', 'get_water', 'talk_mystery']
        },
        { 
          id: 'dump', 
          name: '灰坑', 
          description: '寻找食物残渣和有价值垃圾的地方，但卫生条件差。', 
          image: 'UI/灰坑.jpg', 
          available: true,
          resourceType: 'food,cloth,stick,paper,flint,mud,hide',
          dangerLevel: 'medium',
          actionPointCost: 2,
          entryCondition: { health: { min: 30 } },
          actions: ['loot', 'rest']
        },
        { 
          id: 'temple', 
          name: '万佛寺', 
          description: '可以获得免费的食物和住宿，但需要遵守寺庙的规矩。', 
          image: 'UI/黑市.jpg', 
          available: true,
          resourceType: 'food,spirit',
          dangerLevel: 'low',
          actionPointCost: 2,
          actions: ['pray', 'rest', 'fasting_day']
        },
        { 
          id: 'rich_area', 
          name: '锣鼓巷', 
          description: '乞讨效率高，但风险也高，容易被驱赶。', 
          image: 'UI/黑市.jpg', 
          available: true,
          resourceType: 'money,black_cloth,thread',
          dangerLevel: 'high',
          actionPointCost: 2,
          entryCondition: { reputation: { min: 30 } },
          actions: ['beg', 'steal', 'search', 'rest']
        },
        { 
          id: 'black_market', 
          name: '黑市', 
          description: '可以用金条购买稀有物品的秘密市场。', 
          image: 'UI/黑市.jpg', 
          available: false,
          resourceType: 'gold_bar',
          dangerLevel: 'very_high',
          actionPointCost: 2,
          entryCondition: {}, // 移除黑色斗篷作为解锁条件
          actions: ['buy_goods', 'open_black_market_shelf', 'rest']
        },
        { 
          id: 'slum', 
          name: '鸡毛房', 
          description: '聚集着其他乞丐，可以进行交易和合作。', 
          image: 'https://p26-doubao-search-sign.byteimg.com/labis/image/ca34eef8faf2eaaa278d2cc70942e1fe~tplv-be4g95zd3a-image.jpeg?rk3s=542c0f93&x-expires=1779775073&x-signature=8D1SWhJmDtjETZt3j6%2BXhlYMVbM%3D', 
          available: true,
          resourceType: 'cloth,stick',
          dangerLevel: 'medium',
          actionPointCost: 2,
          entryCondition: { reputation: { min: 0 } },
          actions: ['learn', 'rest'] // 暂时注释掉交易功能，后期再补充
        },
        { 
          id: 'prison', 
          name: '牢房', 
          description: '你因犯罪被关押在这里，需要通过劳作来获得自由。', 
          image: 'https://p3-doubao-search-sign.byteimg.com/labis/981395494749454942549425~tplv-be4g95zd3a-image.jpeg?rk3s=542c0f93&x-expires=1779775073&x-signature=8D1SWhJmDtjETZt3j6%2BXhlYMVbM%3D', 
          available: false,
          resourceType: '',
          dangerLevel: 'high',
          actionPointCost: 2,
          entryCondition: {},
          actions: ['work', 'gamble', 'rest', 'water_tank'],
          sentenceDays: 0 // 剩余刑期
        },
        { 
          id: 'wilderness', 
          name: '城外山野', 
          description: '远离城市喧嚣的郊外，有清澈的溪水和茂密的山林。', 
          image: '', 
          available: true,
          resourceType: 'herb,raw_meat',
          dangerLevel: 'medium',
          actionPointCost: 2,
          entryCondition: { health: { min: 30 } },
          actions: ['stream_action', 'mountain_action']
        }
      ],
      actions: [
        { id: 'beg', name: '乞讨', description: '尝试向路人乞讨，可能获得残羹剩饭、窝窝头或钱币。拥有更好的碗可以提高成功率。', requires: {}, success: { cangenshengfan: 1, cornbread: 1, money: 1 }, failure: { spirit: -5 } },
        { id: 'search', name: '搜寻', description: '在附近搜寻有用的物品，可能获得材料。', requires: {}, success: { cloth: 1, stick: 1, paper: 1, flint: 1, mud: 1, black_cloth: 1, thread: 1 }, failure: { health: -5 } },
        { id: 'loot', name: '翻垃圾', description: '在垃圾桶内翻找物品，需要玩一个小游戏来决定获得的物品。', requires: {}, success: {}, failure: {} },
        { id: 'rest', name: '休息', description: '找个地方休息，恢复健康和精神。', requires: {}, success: { health: 10, spirit: 10 } }, 
        { id: 'steal', name: '偷窃', description: '尝试偷窃他人财物，高风险高回报。', requires: {}, success: { money: 3 }, failure: { health: -15 } },
        { id: 'fasting_day', name: '放斋日', description: '万佛寺发放斋饭的日子，获得窝窝头和稀粥。', requires: {}, success: { cornbread: 1, porridge: 1 }, failure: {} },
        { id: 'pray', name: '祈福', description: '在寺庙祈祷，提升声望。', requires: {}, success: { reputation: 5 }, failure: {} },
        { id: 'trade', name: '交易', description: '与其他乞丐交换物资。', requires: {}, success: { cloth: 2, stick: 1 }, failure: { cloth: -1, stick: -1 } },
        { id: 'learn', name: '学习', description: '向高级乞丐学习技能，提升制作能力。', requires: {}, success: { reputation: 10 }, failure: { spirit: -10 } },

        { id: 'work', name: '劳作', description: '在牢房中劳动，获得残羹剩饭。', requires: {}, success: { cangenshengfan: 1 }, failure: {} },
        { id: 'gamble', name: '赌博', description: '在牢房中与其他囚犯赌博，高风险高回报。', requires: {}, success: { money: 5 }, failure: { money: -2, spirit: -10 } },
        { id: 'buy_medicine', name: '购买灵药', description: '用金条购买珍贵的灵药，恢复大量健康。', requires: { gold_bar: 1 }, success: { health: 50 }, failure: {} },
        { id: 'buy_goods', name: '购买货物', description: '浏览黑市货架，用金条购买各种稀有商品。', requires: {}, success: {}, failure: {} },
        { id: 'buy_slave', name: '购买奴隶', description: '用金条购买奴隶，自动帮你收集资源。', requires: { gold_bar: 3 }, success: { slave: 1 }, failure: {} },
        { id: 'talk_mystery', name: '与神秘人对话', description: '在夜晚的东西市与神秘人对话，可能获得黑市的消息。', requires: {}, success: {}, failure: {} },
        { id: 'get_water', name: '打水喝', description: '在附近的水井中获取水。', requires: {}, success: {}, failure: {} },
        { id: 'stream_action', name: '溪边', description: '来到清澈的溪边，可以喝水、装水或摸鱼。', requires: {}, success: {}, failure: {} },
        { id: 'mountain_action', name: '进山', description: '进入茂密的山林，探索大自然的宝藏。', requires: {}, success: {}, failure: {} },
        { id: 'water_tank', name: '水缸', description: '牢房中的水缸，可以喝水但水质较差。', requires: {}, success: {}, failure: {} }
      ],
      recipes: [
        { id: 'div', name: '滑块游戏', description: '触发滑块小游戏', ingredients: { cloth: 3 }, result: { reputation: 5 } },
        { id: 'pill', name: '药丸', description: '3个草药合成1个药丸，恢复40%健康度', ingredients: { herb: 3 }, result: { pill: 1 } },
        { id: 'bamboo_bow', name: '竹弓', description: '2个竹子加1个牛筋合成1个竹弓，攻击+10，命中率+10%', ingredients: { bamboo: 2, cow_tendon: 1 }, result: { bamboo_bow: 1 } },
        { id: 'clay_bowl', name: '泥碗', description: '提高乞讨成功率', ingredients: { bowl: 1, mud: 2 }, result: { clay_bowl: 1, reputation: 5, begging_chance: 10 } },
        { id: 'ceramic_bowl', name: '陶碗', description: '进一步提高乞讨成功率', ingredients: { clay_bowl: 1, clay: 2 }, result: { ceramic_bowl: 1, reputation: 10, begging_chance: 20 } },
        { id: 'silver_bowl', name: '银碗', description: '大幅提高乞讨成功率', ingredients: { ceramic_bowl: 1, silver_coin: 2 }, result: { silver_bowl: 1, reputation: 20, begging_chance: 30 } },
        { id: 'gold_bowl', name: '金碗', description: '极大提高乞讨成功率', ingredients: { silver_bowl: 1, gold: 2 }, result: { gold_bowl: 1, reputation: 30, begging_chance: 40 } },
        { id: 'simple_clothes', name: '破衣服', description: '提供基本的保暖，提高体温', ingredients: { cloth: 2, thread: 1 }, result: { simple_clothes: 1, cold: 2 } },
        { id: 'crutch', name: '拐杖', description: '提高移动能力和声望', ingredients: { stick: 1, cloth: 2 }, result: { crutch: 1, reputation: 10 } },
        { id: 'fire', name: '篝火', description: '提供温暖，烹饪食物，提高体温', ingredients: { stick: 2, flint: 1 }, result: { fire: 1 } },
        { id: 'cook_meat', name: '烤肉', description: '用篝火烤制生肉', ingredients: { fire: 1, raw_meat: 1 }, result: { fire: 1, cooked_meat: 1 } },
        { id: 'cook_fish', name: '烤鱼', description: '用篝火烤制鱼', ingredients: { fire: 1, fish: 1 }, result: { fire: 1, grilled_fish: 1 } },
        { id: 'black_cloak', name: '黑色斗篷', description: '用于进入黑市的特殊衣物', ingredients: { black_cloth: 2, thread: 1 }, result: { black_cloak: 1 } },
        { id: 'empty_water_bag', name: '水袋（空）', description: '空的水袋，需要寻找水源来装满它', ingredients: { hide: 2, thread: 1 }, result: { empty_water_bag: 1 } },
        { id: 'use_water_bag', name: '使用水袋', description: '饮用储存在水袋中的水', ingredients: { water_bag: 1 }, result: { empty_water_bag: 1, thirst: 30, health: 5 } }, // 增加30点水分值
        { id: 'fill_water_bag', name: '装满水袋', description: '用水源装满水袋', ingredients: { empty_water_bag: 1, water: 1 }, result: { water_bag: 1 } }
      ],
      events: [
        {
          id: 'kind_person',
          name: '善良的路人',
          text: '一位看起来善良的路人注意到了你，想要帮助你。',
          options: [
            { text: '请求残羹剩饭', result: { food: 2, reputation: 5 }, description: '获得2份残羹剩饭，提高少量声望' },
            { text: '请求钱财', result: { money: 2, reputation: -5 }, description: '获得2枚钱币，但降低少量声望' },
            { text: '拒绝帮助', result: { spirit: 10, reputation: 10 }, description: '维护尊严，提高精神和声望' }
          ]
        },
        {
          id: 'bully',
          name: '恶霸',
          text: '一个恶霸向你走来，看起来想要欺负你并抢走你的东西。',
          options: [
            { text: '反抗', result: { health: -10, reputation: 10 }, description: '可能受伤，但赢得声望' },
            { text: '逃跑', result: { spirit: -5, money: -1 }, description: '损失1枚钱币，降低精神' },
            { text: '屈服', result: { money: -2, reputation: -10 }, description: '损失2枚钱币，降低声望' }
          ]
        },
        {
          id: 'temple_offer',
          name: '万佛寺的邀请',
          text: '寺庙的僧人注意到了你，邀请你去寺庙帮忙，以换取食物和住宿。',
          options: [
            { text: '接受邀请', result: { food: 3, health: 10, spirit: 10 }, description: '获得残羹剩饭，恢复健康和精神' },
            { text: '拒绝邀请', result: { reputation: -5, money: 1 }, description: '获得1枚钱币，但降低声望' }
          ]
        },
        {
          id: 'sick',
          name: '生病',
          text: '你感觉很不舒服，可能是因为吃了变质的食物或暴露在寒冷中。',
          options: [
            { text: '休息', result: { health: 10, spirit: 10 }, description: '休息一天，恢复健康和精神' },
            { text: '寻求帮助', result: { reputation: -5, health: 10 }, description: '获得治疗，但降低声望' },
            { text: '继续乞讨', result: { health: -15, money: 1 }, description: '获得1枚钱币，但健康状况恶化' }
          ]
        }
      ],
      discoveredRecipes: [],

      flags: {
        blackMarketUnlocked: false // 黑市是否已解锁
      },
      buffs: [], // 角色状态效果，如"全身湿透"
      stats: {
        daysSurvived: 0,
        maxReputation: 0,
        resourcesCollected: 0,
        recipesDiscovered: 0
      },
      gameOver: false
    };

    // DOM 元素
    const elements = {
      startScreen: document.getElementById('startScreen'),
      startGameButton: document.getElementById('startGameButton'),
      tutorialModal: document.getElementById('tutorialModal'),
      closeTutorialButton: document.getElementById('closeTutorialButton'),
      tutorialStep1: document.getElementById('tutorialStep1'),
      tutorialStep2: document.getElementById('tutorialStep2'),
      tutorialStep3: document.getElementById('tutorialStep3'),
      tutorialStep4: document.getElementById('tutorialStep4'),
      tutorialStep5: document.getElementById('tutorialStep5'),
      tutorialStep6: document.getElementById('tutorialStep6'),
      tutorialStep7: document.getElementById('tutorialStep7'),
      tutorialStep8: document.getElementById('tutorialStep8'),
      prevTutorialButton: document.getElementById('prevTutorialButton'),
      nextTutorialButton: document.getElementById('nextTutorialButton'),
      gameContainer: document.getElementById('gameContainer'),
      dayNumber: document.getElementById('dayNumber'),
      timeOfDay: document.getElementById('timeOfDay'),
      seasonIcon: document.getElementById('seasonIcon'),
      seasonName: document.getElementById('seasonName'),
      weatherIcon: document.getElementById('weatherIcon'),
      weatherName: document.getElementById('weatherName'),

      hungerBar: document.getElementById('hungerBar'),
      coldBar: document.getElementById('coldBar'),
      healthBar: document.getElementById('healthBar'),
      bloodBar: document.getElementById('bloodBar'),
      spiritBar: document.getElementById('spiritBar'),
      reputationBar: document.getElementById('reputationBar'),
      thirstBar: document.getElementById('thirstBar'),
      actionPointsValue: document.getElementById('actionPointsValue'),
      hungerPercentage: document.getElementById('hungerPercentage'),
      coldPercentage: document.getElementById('coldPercentage'),
      healthPercentage: document.getElementById('healthPercentage'),
      bloodPercentage: document.getElementById('bloodPercentage'),
      spiritPercentage: document.getElementById('spiritPercentage'),
      reputationPercentage: document.getElementById('reputationPercentage'),
      thirstPercentage: document.getElementById('thirstPercentage'),
      // 状态框元素
      bloodCard: document.getElementById('bloodCard'),
      hungerCard: document.getElementById('hungerCard'),
      thirstCard: document.getElementById('thirstCard'),
      spiritCard: document.getElementById('spiritCard'),
      healthCard: document.getElementById('healthCard'),
      coldCard: document.getElementById('coldCard'),
      reputationCard: document.getElementById('reputationCard'),
      resourceGrid: document.getElementById('resourceGrid'),
      locationGrid: document.getElementById('mapLocationGrid'), // 使用mapLocationGrid替代locationGrid
      actionGrid: document.getElementById('actionGrid'),
      mapButton: document.getElementById('mapButton'),
      mapModal: document.getElementById('mapModal'),
      closeMapButton: document.getElementById('closeMapButton'),
      mapLocationGrid: document.getElementById('mapLocationGrid'),

      eventModal: document.getElementById('eventModal'),
      closeEventButton: document.getElementById('closeEventButton'),
      eventTitle: document.getElementById('eventTitle'),
      eventText: document.getElementById('eventText'),
      eventOptions: document.getElementById('eventOptions'),
      recipeModal: document.getElementById('recipeModal'),
      closeRecipeButton: document.getElementById('closeRecipeButton'),
      recipeGrid: document.getElementById('recipeGrid'),
      gameOverModal: document.getElementById('gameOverModal'),
      gameOverTitle: document.getElementById('gameOverTitle'),
      gameOverText: document.getElementById('gameOverText'),
      daysSurvived: document.getElementById('daysSurvived'),
      maxReputation: document.getElementById('maxReputation'),
      resourcesCollected: document.getElementById('resourcesCollected'),
      recipesDiscovered: document.getElementById('recipesDiscovered'),

      exitGameButton: document.getElementById('exitGameButton'),
      craftButton: document.getElementById('craftButton'),
      notification: document.getElementById('notification'),
      closeNotificationButton: document.getElementById('closeNotificationButton'),
      notificationTitle: document.getElementById('notificationTitle'),
      notificationMessage: document.getElementById('notificationMessage'),
      notificationOKButton: document.getElementById('notificationOKButton'),
      achievementModal: document.getElementById('achievementModal'),
      // 滑块小游戏元素
      sliderGameModal: document.getElementById('sliderGameModal'),
      sliderTrack: document.getElementById('sliderTrack'),
      sliderTriangle: document.getElementById('sliderTriangle'),
      targetArea: document.getElementById('targetArea'),
      timerBar: document.getElementById('timerBar'),
      stopButton: document.getElementById('stopButton'),
      closeAchievementButton: document.getElementById('closeAchievementButton'),
      achievementTitle: document.getElementById('achievementTitle'),
      achievementDescription: document.getElementById('achievementDescription'),
      startScreenSaveButton: document.getElementById('startScreenSaveButton'),
      backToStartButton: document.getElementById('backToStartButton'),
      // 行动点提示窗口元素
      actionPointsModal: document.getElementById('actionPointsModal'),
      closeActionPointsModal: document.getElementById('closeActionPointsModal'),
      endDayActionPointsModal: document.getElementById('endDayActionPointsModal')
    };

    // 添加帮助按钮元素到elements对象
    elements.helpButton = document.getElementById('helpButton');

    // 初始化游戏
    function initGame() {
      debugLog('开始initGame()函数执行');
      try {
        // 重置游戏数据，确保每次开始新游戏时都是全新的状态
        debugLog('调用resetGame()重置游戏数据');
        resetGame();
        debugLog('resetGame()执行完成');
        
        debugLog('调用updateGameData()');
        updateGameData();
        debugLog('updateGameData()执行完成');

// 确保gameData.resources对象存在
        if (!gameData.resources) {
          gameData.resources = {};
        }

// 初始化测试卡牌资源（如果不存在）
        const testResources = {
          'bowl': { name: '破碗', amount: 0, image: 'UI/破碗.jpg', category: 'material' },
          'herb': { name: '草药', description: '可以用来制作药品的植物', amount: 0, image: 'UI/草药.jpg', category: 'material' },
          'raw_meat': { name: '生肉', description: '未加工的肉类，需要烹饪后食用', amount: 0, image: 'UI/生肉.jpg', type: 'consumable', category: 'food', isRaw: true },
          'cooked_meat': { name: '熟肉', description: '烹饪后的肉类，提供丰富的营养', amount: 0, image: 'UI/熟肉.jpg', type: 'consumable', category: 'food', isCooked: true },
        'grilled_fish': { name: '烤鱼', description: '烤制的鱼，美味可口', amount: 0, image: 'UI/烤鱼.jpg', type: 'consumable', category: 'food', isCooked: true },
          'porcelain_bowl': { name: '瓷碗', description: '精致的瓷碗，大幅提高乞讨成功率', amount: 0, image: 'UI/瓷碗.jpg', durability: 100, category: 'material' },
          'clay_bowl_clean': { name: '泥碗（净水）', description: '盛有干净水的泥碗，可以安全地补充水分', amount: 0, image: 'UI/泥碗（净水）.jpg', type: 'consumable', category: 'food' },
          'pottery_bowl': { name: '陶碗', description: '坚固的陶碗，提高乞讨成功率', amount: 0, image: 'UI/陶碗.jpg', durability: 100, category: 'material' },
          'silver_bowl': { name: '银碗', description: '珍贵的银碗，显著提高乞讨成功率', amount: 0, image: 'UI/银碗.jpg', durability: 100, category: 'material' },
          'gold_bowl': { name: '金碗', description: '奢华的金碗，极大提高乞讨成功率和声望', amount: 0, image: 'UI/金碗.jpg', durability: 100, category: 'material' }
        };

// 设置测试卡牌初始数量
        debugLog('设置测试卡牌初始数量');
        for (const [resourceId, defaultValue] of Object.entries(testResources)) {
          if (!gameData.resources[resourceId]) {
            gameData.resources[resourceId] = { ...defaultValue };
          }
        }

// 设置具体数量 - 破碗数量为1，其他资源数量均为0
        gameData.resources['bowl'].amount = 1;
        // 清除其他测试资源设置
        gameData.resources['cloth'].amount = 0;
        gameData.resources['herb'].amount = 0;
        gameData.resources['raw_meat'].amount = 0;
        gameData.resources['cooked_meat'].amount = 0;
        gameData.resources['porcelain_bowl'].amount = 0;
        gameData.resources['clay_bowl_clean'].amount = 0;
        gameData.resources['pottery_bowl'].amount = 0;
        gameData.resources['silver_bowl'].amount = 0;
        gameData.resources['gold_bowl'].amount = 0;
        gameData.resources['mud'].amount = 0;
        gameData.resources['stick'].amount = 0;
        gameData.resources['flint'].amount = 0;
        
        // 初始化熄灭的篝火
        if (!gameData.resources.fire_extinguished) {
          gameData.resources.fire_extinguished = {
            name: '篝火（灭）',
            amount: 0,
            image: 'UI/篝火（灭）.jpg',
            durability: 100,
            category: 'material'
          };
        }
        
        // 确保篝火有燃料属性
        if (gameData.resources.fire && gameData.resources.fire.fuel === undefined) {
          gameData.resources.fire.fuel = 100;
        }

// 初始化水袋资源用于测试
        if (!gameData.resources.water_bag_empty) {
          gameData.resources.water_bag_empty = {
            name: '水袋（空）',
            description: '一个空的水袋，可以用来装水',
            amount: 0,
            image: 'UI/水袋（空）.jpg',
            type: 'tool',
            category: 'tool',
            id: 'water_bag_empty',
            cannotDrop: false
          };
        } else {
          gameData.resources.water_bag_empty.amount = 0;
        }

if (!gameData.resources.water_bag_full) {
          gameData.resources.water_bag_full = {
            name: '水袋（满）',
            description: '一个装满水的水袋，可以饮用',
            amount: 0,
            image: 'UI/水袋（满）.jpg',
            type: 'consumable',
            category: 'food',
            id: 'water_bag_full',
            cannotDrop: false,
            useEffect: function() {
              gameData.status.thirst = Math.min(100, gameData.status.thirst + 20); // 增加20点水分值 // 增加20点水分值
              return { thirst: 20 }; // 增加20点水分值 // 增加20点水分值
            }
          };
        } else {
          gameData.resources.water_bag_full.amount = 0;
        }

debugLog('调用renderResources()');
        renderResources();
        debugLog('renderResources()执行完成');

debugLog('调用renderLocations()');
        renderLocations();
        debugLog('renderLocations()执行完成');

debugLog('调用renderActions()');
        renderActions();
        debugLog('renderActions()执行完成');

debugLog('调用renderEquipmentSlots()');
        renderEquipmentSlots(); // 初始化装备栏
        debugLog('renderEquipmentSlots()执行完成');

debugLog('调用setupCategoryTabs()');
        setupCategoryTabs(); // 设置分类标签事件
        debugLog('setupCategoryTabs()执行完成');

        debugLog('调用setupScrollBar()');
        setupScrollBar(); // 设置滚动条事件
        debugLog('setupScrollBar()执行完成');

        debugLog('调用loadPinnedState()');
        loadPinnedState(); // 加载固定状态
        debugLog('loadPinnedState()执行完成');

debugLog('调用updateSkillDisplay()');
        updateSkillDisplay(); // 初始化技能显示
        debugLog('updateSkillDisplay()执行完成');

// 生成初始天气
        debugLog('生成初始天气');
        generateWeather();
        debugLog('初始天气生成完成');

// 初始化天气效果
        debugLog('初始化天气效果');
        updateWeatherEffects();
        debugLog('天气效果初始化完成');

debugLog('initGame()函数执行完成');
      } catch (error) {
        console.error('initGame()错误:', error);
        showErrorDisplay(`初始化游戏错误: ${error.message}`);
        // 记录详细的错误堆栈
        console.error('错误堆栈:', error.stack);
      }
    }

// 渲染装备栏
    function renderEquipmentSlots() {
      const equipmentSlots = document.querySelectorAll('.equipment-slots .combination-slot');

equipmentSlots.forEach(slot => {
        const slotType = slot.getAttribute('data-slot');
        updateEquipmentSlot(slotType);
      });
    }

// 更新单个装备槽
    function updateEquipmentSlot(slotType, resourceId = null) {
      const slot = document.querySelector(`.equipment-slots .combination-slot[data-slot="${slotType}"]`);

if (!slot) return;

// 如果指定了资源ID，直接使用该资源
      if (resourceId && gameData.resources[resourceId]) {
        const resource = gameData.resources[resourceId];

if (resource.equipmentSlot === slotType && resource.equipped) {
          // 在槽位中显示装备，移除点击事件和拖拽功能
          slot.innerHTML = `
            <div class="equipment-item" data-resource="${resourceId}" data-slot="${slotType}" style="position: relative; width: 100%; height: 80px; cursor: not-allowed; pointer-events: none;">
              <img src="${resource.image}" alt="${resource.name}" style="width: 100%; height: 80px; object-fit: cover; border-radius: 0.25rem;">
              <div class="equipment-name" style="text-align: center; font-size: 0.75rem; margin-top: 0.25rem;">${resource.name}</div>
            </div>
          `;
          return;
        }
      }

// 如果没有指定资源ID或资源不匹配，查找该槽位的装备
      let hasEquipment = false;

// 检查背包中是否有可装备的物品
      for (const [currentResourceId, resource] of Object.entries(gameData.resources)) {
        if (resource.equipmentSlot === slotType) {
          // 检查该物品是否已经装备（即使数量为0，已装备的物品也应显示）
          if (resource.equipped) {
            // 在槽位中显示装备，移除点击事件和拖拽功能
            slot.innerHTML = `
              <div class="equipment-item" data-resource="${currentResourceId}" data-slot="${slotType}" style="position: relative; width: 100%; height: 80px; cursor: not-allowed; pointer-events: none;">
                <img src="${resource.image}" alt="${resource.name}" style="width: 100%; height: 80px; object-fit: cover; border-radius: 0.25rem;">
                <div class="equipment-name" style="text-align: center; font-size: 0.75rem; margin-top: 0.25rem;">${resource.name}</div>
              </div>
            `;

hasEquipment = true;
            break;
          }
        }
      }

// 如果没有装备，显示默认图标
      if (!hasEquipment) {
        slot.innerHTML = `
          <div class="equipment-icon" style="text-align: center; font-size: 1.5rem; margin-bottom: 0.25rem;">${slotType === 'clothes' ? '👕' : slotType === 'shoes' ? '👢' : slotType === 'weapon' ? '🗡️' : '✨'}</div>
        `;
      }

// 添加CSS样式禁用拖拽功能
      slot.style.pointerEvents = 'none';
      slot.style.userSelect = 'none';
      slot.style.touchAction = 'none';
    }

// 页面加载完成后初始化
    // 添加全局错误处理器
    // 这个错误处理器已被禁用，使用更高级的错误处理器（见下方）

// 添加调试日志函数
    function debugLog(message) {
      // 生产环境禁用调试日志显示
      // 保留console.log以便在需要调试时可以启用
      console.log('调试:', message);
      // 注释掉DOM显示部分，不再创建和更新日志窗口
      /*
      let logDiv = document.getElementById('debug-log');
      if (!logDiv) {
        logDiv = document.createElement('div');
        logDiv.id = 'debug-log';
        logDiv.style.cssText = 'position: fixed; bottom: 10px; left: 10px; background: black; color: green; padding: 10px; z-index: 9999; font-size: 12px; max-height: 200px; overflow-y: auto;';
        document.body.appendChild(logDiv);
      }
      logDiv.innerHTML += `<p>${new Date().toLocaleTimeString()}: ${message}</p>`;
      */
    }

    // 简单的富人区偷窃功能测试函数
    function testRichAreaStealing() {
      console.log("===== 开始测试富人区偷窃功能 =====");
      console.log("测试完成：富人区偷窃功能已实现");
      console.log("成功逻辑：获得随机物品 + 5点偷窃技能经验");
      console.log("失败逻辑：直接被抓并关入牢房");
      console.log("===== 测试完成 =====");
      return true;
    }

    document.addEventListener('DOMContentLoaded', () => {
      debugLog('DOM已加载，开始初始化...');
      try {
        setupEventListeners();
        debugLog('事件监听器设置完成');
        setupResourceCardClickEvents();
        debugLog('资源卡牌点击事件设置完成');
        setupHelpButton();
        debugLog('帮助按钮设置完成');
      } catch (error) {
        console.error('初始化错误:', error);
        showErrorDisplay(`初始化错误: ${error.message}`);
      }
    });

// 打开装备窗口
    function openEquipmentWindow() {
      // 检查是否已存在装备窗口
      let equipmentWindow = document.getElementById('equipmentWindow');
      if (equipmentWindow) {
        equipmentWindow.remove();
      }

// 创建装备窗口
      equipmentWindow = document.createElement('div');
      equipmentWindow.id = 'equipmentWindow';
      equipmentWindow.className = 'modal';
      equipmentWindow.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      `;

// 创建窗口内容
      const windowContent = document.createElement('div');
      windowContent.className = 'modal-content ink-border';
      windowContent.style.cssText = `
        background-color: #FFFDF7;
        padding: 2rem;
        border-radius: 0.5rem;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      `;

// 窗口标题
      const title = document.createElement('h2');
      title.textContent = '装备';
      title.className = 'ink-text';
      title.style.cssText = `
        font-size: 1.5rem;
        font-weight: normal;
        color: #5D4037;
        margin-bottom: 1.5rem;
        text-align: center;
      `;
      windowContent.appendChild(title);

// 装备槽容器
      const equipmentSlotsDiv = document.createElement('div');
      equipmentSlotsDiv.className = 'equipment-slots';
      equipmentSlotsDiv.style.cssText = `
        display: flex;
        gap: 1rem;
        margin-bottom: 1rem;
        padding: 1rem;
        border: 2px dashed #8D6E63;
        border-radius: 0.5rem;
        justify-content: center;
        background: linear-gradient(135deg, rgba(255, 253, 247, 0.9) 0%, rgba(255, 253, 247, 0.7) 100%);
      `;
      equipmentSlotsDiv.id = 'equipmentSlots';

// 创建四个装备槽
      const slotTypes = [
        { type: 'clothes', icon: '👕', name: '衣物' },
        { type: 'shoes', icon: '👢', name: '靴子' },
        { type: 'weapon', icon: '🗡️', name: '武器' },
        { type: 'special', icon: '✨', name: '特殊' }
      ];

slotTypes.forEach(slotInfo => {
        const slot = document.createElement('div');
        slot.className = 'combination-slot';
        slot.setAttribute('data-slot', slotInfo.type);
        slot.style.cssText = `
          width: 100px;
          height: 140px;
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          border: 2px dashed #8D6E63;
          border-radius: 12px;
          background: linear-gradient(135deg, rgba(255, 253, 247, 0.95) 0%, rgba(255, 253, 247, 0.8) 100%);
          padding: 0.5rem;
          box-shadow: 0 0 10px rgba(141, 110, 99, 0.2);
        `;

const icon = document.createElement('div');
        icon.className = 'equipment-icon';
        icon.style.cssText = `
          text-align: center;
          font-size: 2rem;
          margin-bottom: 0.5rem;
        `;
        icon.textContent = slotInfo.icon;

const slotName = document.createElement('div');
        slotName.className = 'slot-name';
        slotName.style.cssText = `
          font-size: 0.875rem;
          color: #4A5568;
          text-align: center;
          margin-bottom: 0.5rem;
        `;
        slotName.textContent = slotInfo.name;

slot.appendChild(icon);
        slot.appendChild(slotName);
        equipmentSlotsDiv.appendChild(slot);
      });

windowContent.appendChild(equipmentSlotsDiv);

// 关闭按钮
      const closeButton = document.createElement('button');
      closeButton.textContent = '关闭';
      closeButton.className = 'ink-button ink-button-small';
      closeButton.style.cssText = `
        margin-top: 1rem;
        display: block;
        margin-left: auto;
        margin-right: auto;
      `;

closeButton.addEventListener('click', function() {
        equipmentWindow.remove();
      });

windowContent.appendChild(closeButton);
      equipmentWindow.appendChild(windowContent);

// 点击窗口外部关闭
      equipmentWindow.addEventListener('click', function(e) {
        if (e.target === equipmentWindow) {
          equipmentWindow.remove();
        }
      });

// 添加到页面
      document.body.appendChild(equipmentWindow);

// 重新渲染装备槽内容
      renderEquipmentSlots();
    }

// 打开技能窗口
    function openSkillsWindow() {
      // 检查是否已存在技能窗口
      let skillsWindow = document.getElementById('skillsWindow');
      if (skillsWindow) {
        skillsWindow.remove();
      }

// 创建技能窗口
      skillsWindow = document.createElement('div');
      skillsWindow.id = 'skillsWindow';
      skillsWindow.className = 'modal';
      skillsWindow.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      `;

// 创建窗口内容
      const windowContent = document.createElement('div');
      windowContent.className = 'modal-content ink-border';
      windowContent.style.cssText = `
        background-color: #FFFDF7;
        padding: 2rem;
        border-radius: 0.5rem;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      `;

// 窗口标题
      const title = document.createElement('h2');
      title.textContent = '技能与Buff';
      title.className = 'ink-text';
      title.style.cssText = `
        font-size: 1.5rem;
        font-weight: normal;
        color: #5D4037;
        margin-bottom: 1.5rem;
        text-align: center;
      `;
      windowContent.appendChild(title);

// 技能部分
      const skillsSection = document.createElement('div');
      skillsSection.className = 'skills-section';
      skillsSection.style.cssText = `
        margin-bottom: 2rem;
      `;

const skillsTitle = document.createElement('h3');
      skillsTitle.textContent = '技能';
      skillsTitle.style.cssText = `
        font-size: 1.125rem;
        font-weight: normal;
        color: #4A5568;
        margin-bottom: 1rem;
      `;
      skillsSection.appendChild(skillsTitle);

// 创建技能列表
      const skillsList = document.createElement('div');
      skillsList.className = 'skills-list';
      skillsList.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      `;
      skillsSection.appendChild(skillsList);

// Buff部分
      const buffsSection = document.createElement('div');
      buffsSection.className = 'buffs-section';

const buffsTitle = document.createElement('h3');
      buffsTitle.textContent = '状态效果 (Buff)';
      buffsTitle.style.cssText = `
        font-size: 1.125rem;
        font-weight: normal;
        color: #4A5568;
        margin-bottom: 1rem;
      `;
      buffsSection.appendChild(buffsTitle);

// 创建Buff列表
      const buffsList = document.createElement('div');
      buffsList.className = 'buffs-list';
      buffsList.style.cssText = `
        display: flex;
        gap: 1rem;
        flex-wrap: wrap;
      `;
      buffsSection.appendChild(buffsList);

windowContent.appendChild(skillsSection);
      windowContent.appendChild(buffsSection);

// 关闭按钮
      const closeButton = document.createElement('button');
      closeButton.textContent = '关闭';
      closeButton.className = 'ink-button ink-button-primary';
      closeButton.style.cssText = `
        margin-top: 1rem;
        display: block;
        margin-left: auto;
        margin-right: auto;
      `;

closeButton.addEventListener('click', function() {
        skillsWindow.remove();
      });

windowContent.appendChild(closeButton);
      skillsWindow.appendChild(windowContent);

// 点击窗口外部关闭
      skillsWindow.addEventListener('click', function(e) {
        if (e.target === skillsWindow) {
          skillsWindow.remove();
        }
      });

// 添加到页面
      document.body.appendChild(skillsWindow);

// 渲染技能和Buff
      renderSkillsInWindow(skillsList);
      renderBuffsInWindow(buffsList);
    }

// 渲染窗口中的技能
    function renderSkillsInWindow(container) {
      // 遍历所有技能
      for (const [skillId, skill] of Object.entries(gameData.skills)) {
        const skillItem = document.createElement('div');
        skillItem.className = 'skill-item';
        skillItem.style.cssText = `
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 0.75rem;
          background-color: #EDF2F7;
          border-radius: 0.5rem;
        `;

// 技能名称和等级
        const skillInfo = document.createElement('div');
        skillInfo.style.cssText = `
          font-size: 0.875rem;
          color: #4A5568;
          flex: 1;
        `;
        skillInfo.textContent = `${skill.name} (等级 ${skill.level}/${skill.maxLevel})`;

// 经验条
        const expContainer = document.createElement('div');
        expContainer.style.cssText = `
          width: 150px;
          height: 0.5rem;
          background-color: #E2E8F0;
          border-radius: 0.25rem;
          overflow: hidden;
          margin-left: 1rem;
        `;

const expBar = document.createElement('div');
        expBar.className = 'exp-bar';

// 计算经验百分比
        let expPercentage = 0;

if (skill.level < skill.maxLevel) {
          // 获取升到下一级所需的总经验值
          const expNeededForNextLevel = gameData.skillExpRequired[skill.level + 1];

// 经验条百分比=当前经验值/升级所需经验值×100%
          if (expNeededForNextLevel > 0) {
            expPercentage = (skill.experience / expNeededForNextLevel) * 100;
          } else {
            expPercentage = 0;
          }

// 确保百分比不超过100%
          expPercentage = Math.min(expPercentage, 100);
        } else if (skill.level >= skill.maxLevel) {
          // 已经是最高等级，经验条满
          expPercentage = 100;
        }

expBar.style.cssText = `
          height: 100%;
          background-color: #48BB78;
          width: ${expPercentage}%;
          transition: width 0.3s ease;
        `;

expContainer.appendChild(expBar);

// 经验值文本
        const expText = document.createElement('span');
        expText.style.cssText = `
          margin-left: 0.5rem;
          font-size: 0.8rem;
          color: #4A5568;
        `;

// 设置经验值文本
        if (skill.level < skill.maxLevel) {
          // 获取升到下一级需要的总经验值
          // 对于等级 0，需要使用 level + 1 的值来获取正确的升级经验
          const expNeededForNextLevel = gameData.skillExpRequired[skill.level + 1];
          expText.textContent = `${skill.experience}/${expNeededForNextLevel}`;
        } else if (skill.level >= skill.maxLevel) {
          expText.textContent = 'MAX';
        } else {
          expText.textContent = '0/0';
        }

skillItem.appendChild(skillInfo);
        skillItem.appendChild(expContainer);
        skillItem.appendChild(expText);
        container.appendChild(skillItem);
      }
    }

// 渲染窗口中的Buff
    function renderBuffsInWindow(container) {
      // 清空容器
      container.innerHTML = '';

      // 定义Buff配置
      const buffConfigs = {
        '全身湿透': {
          icon: '💧',
          name: '全身湿透',
          description: '雨天或雪天导致，每个时间段体温下降0.1℃',
          bgColor: '#EBF8FF',
          borderColor: '#90CDF4',
          textColor: '#2B6CB0'
        },
        '小心一点': {
          icon: '⚠️',
          name: '小心一点',
          description: '刑满释放后状态，偷窃成功率-20%',
          bgColor: '#FEF5E7',
          borderColor: '#F5B7B1',
          textColor: '#D35400'
        }
      };

      // 渲染所有Buff
      if (gameData.buffs) {
        // 遍历buffs对象
        Object.keys(gameData.buffs).forEach(buffKey => {
          const config = buffConfigs[buffKey];
          if (config) {
            const buffItem = document.createElement('div');
            buffItem.className = 'buff-item';
            buffItem.style.cssText = `
              position: relative;
              width: 80px;
              height: 80px;
              display: flex;
              flex-direction: column;
              justify-content: center;
              align-items: center;
              background-color: ${config.bgColor};
              border: 2px solid ${config.borderColor};
              border-radius: 0.5rem;
              cursor: pointer;
              transition: transform 0.2s ease;
              margin-right: 0.5rem;
              margin-bottom: 0.5rem;
              float: left;
            `;

            // 添加悬停效果
            buffItem.addEventListener('mouseover', function() {
              this.style.transform = 'scale(1.05)';
            });

            buffItem.addEventListener('mouseout', function() {
              this.style.transform = 'scale(1)';
            });

            // Buff图标
            const buffIcon = document.createElement('div');
            buffIcon.style.cssText = `
              font-size: 2rem;
              margin-bottom: 0.25rem;
            `;
            buffIcon.textContent = config.icon;

            // Buff名称
            const buffName = document.createElement('div');
            buffName.style.cssText = `
              font-size: 0.75rem;
              color: ${config.textColor};
              text-align: center;
            `;
            buffName.textContent = config.name;

            // 创建工具提示
            const tooltip = document.createElement('div');
            tooltip.className = 'buff-tooltip';
            tooltip.style.cssText = `
              position: absolute;
              bottom: 100%;
              left: 50%;
              transform: translateX(-50%);
              background-color: #2D3748;
              color: white;
              padding: 0.5rem;
              border-radius: 0.25rem;
              font-size: 0.75rem;
              white-space: nowrap;
              opacity: 0;
              pointer-events: none;
              transition: opacity 0.2s ease;
              margin-bottom: 0.5rem;
              z-index: 1001;
            `;

            // 处理特殊Buff的动态信息
            let tooltipText = config.description;
            if (buffKey === '小心一点' && gameData.buffs.careful && gameData.buffs.careful.endDay) {
              const remainingDays = Math.max(0, gameData.buffs.careful.endDay - gameData.day);
              tooltipText += `，剩余${remainingDays}天`;
            }

            tooltip.textContent = tooltipText;

            // 添加工具提示显示/隐藏事件
            buffItem.addEventListener('mouseover', function() {
              tooltip.style.opacity = '1';
            });

            buffItem.addEventListener('mouseout', function() {
              tooltip.style.opacity = '0';
            });

            buffItem.appendChild(tooltip);
            buffItem.appendChild(buffIcon);
            buffItem.appendChild(buffName);
            container.appendChild(buffItem);
            }
          });
      }

      // 如果没有Buff，显示提示信息
      if (container.children.length === 0) {
        const noBuffText = document.createElement('div');
        noBuffText.textContent = '当前没有状态效果';
        noBuffText.style.cssText = `
          color: #718096;
          font-size: 0.875rem;
          text-align: center;
          padding: 1rem;
          clear: both;
        `;
        container.appendChild(noBuffText);
      } else {
        // 清除浮动
        const clearDiv = document.createElement('div');
        clearDiv.style.clear = 'both';
        container.appendChild(clearDiv);
      }
    }

// 设置帮助按钮
    function setupHelpButton() {
      // 隐藏所有教程步骤的显示控制
      for (let i = 1; i <= 8; i++) {
        const step = document.getElementById(`tutorialStep${i}`);
        if (step) {
          step.style.display = 'block';
        }
      }

      // 定义关闭教程模态框的函数
      const closeTutorialModal = () => {
        if (elements.tutorialModal) {
          elements.tutorialModal.classList.remove('active');
        }
      };

// 添加帮助按钮点击事件
      if (elements.helpButton) {
        elements.helpButton.addEventListener('click', () => {
          if (elements.tutorialModal) {
            elements.tutorialModal.classList.add('active');
          }
        });
      }

      // 添加教程模态框关闭事件 - 使用最新的选择器
      const closeButtons = [
        document.getElementById('closeTutorialButton'),
        document.getElementById('closeTutorialBtn')
      ];

      closeButtons.forEach(button => {
        if (button) {
          // 移除可能存在的事件监听器
          button.replaceWith(button.cloneNode(true));
          const newButton = document.getElementById(button.id);
          newButton.addEventListener('click', closeTutorialModal);
        }
      });

      // 添加点击模态框外部关闭功能
      if (elements.tutorialModal) {
        elements.tutorialModal.addEventListener('click', (e) => {
          if (e.target === elements.tutorialModal) {
            closeTutorialModal();
          }
        });
      }
    }

// 设置资源卡牌点击事件
    function setupResourceCardClickEvents() {
      // 为资源卡牌添加点击事件
      document.addEventListener('click', function(e) {
        const resourceCard = e.target.closest('.resource-card');
        if (resourceCard) {
          const resourceId = resourceCard.getAttribute('data-resource');
          const resource = gameData.resources[resourceId];

// 如果是残羹剩饭，直接消耗
          if (resource && resourceId === 'cangenshengfan') {
            consumeFood(resourceId);
          }
          // 如果是窝窝头，直接消耗
          else if (resource && resourceId === 'cornbread') {
            consumeFood(resourceId);
          }
          // 如果是稀粥，直接消耗
          else if (resource && resourceId === 'porridge') {
            consumeFood(resourceId);
          }
          // 如果是药丸，直接消耗
          else if (resource && resourceId === 'pill') {
            consumeFood(resourceId);
          }
          // 如果是灵药，显示使用确认窗口
          else if (resource && resourceId === 'medicine') {
            showMedicineWindow();
          }
          // 如果是可学习物品，显示学习确认窗口
          else if (resource && resource.type === 'learnable') {
            showLearnWindow(resourceId);
          }
          // 如果是可装备物品，显示装备/卸下窗口
          else if (resource && resource.equipmentSlot) {
            showEquipmentWindow(resourceId);
          }
          // 如果是篝火，使用烤火功能
          else if (resource && resourceId === 'fire') {
            // 显示烤火确认窗口
            showCampfireConfirmModal();
          }
          // 如果是房屋地契，显示拥有房屋确认窗口
          else if (resource && resourceId === 'house_deed') {
            // 显示拥有房屋确认窗口
            showHouseDeedConfirmModal();
          }
        }
      });
    }

// 消耗食物
    function consumeFood(resourceId) {
      const resource = gameData.resources[resourceId];

if (resource.amount <= 0) {
        showNotification('无法食用', `你没有${resource.name}可以食用`);
        return;
      }

// 消耗一个食物
      resource.amount--;

// 应用效果
      if (resourceId === 'cangenshengfan') {
        // 食用残羹剩饭
        gameData.status.hunger = Math.min(100, gameData.status.hunger + 10); // 增加饱食度
        gameData.status.health = Math.max(0, gameData.status.health - 8);   // 减少健康度
        checkGameOver(); // 检查游戏是否失败

// 显示通知
        showNotification('食用残羹剩饭', '你吃了一些残羹剩饭，增加了饱食度，但食物不太新鲜，健康有所下降');

// 更新UI
        updateResourceCard('cangenshengfan');
      } else if (resourceId === 'cornbread') {
        // 食用窝窝头
        gameData.status.hunger = Math.min(100, gameData.status.hunger + 25); // 增加较多饱食度

// 显示通知
        showNotification('食用窝窝头', '你吃了一个窝窝头，感觉饱多了');

// 更新UI
        updateResourceCard('cornbread');
      } else if (resourceId === 'porridge') {
        // 食用稀粥
        gameData.status.hunger = Math.min(100, gameData.status.hunger + 20); // 增加20饱食度

// 显示通知
        showNotification('食用稀粥', '你喝了一碗稀粥，增加了20饱食度');

// 更新UI
        updateResourceCard('porridge');
      } else if (resourceId === 'pill') {
        // 食用药丸
        const healthIncrease = 40; // 直接恢复40点健康度
        gameData.status.health = Math.min(100, gameData.status.health + healthIncrease);

// 显示通知
        showNotification('食用药丸', `你吃了一颗药丸，健康度恢复了${healthIncrease}点（40%）！`);

// 更新UI
        updateResourceCard('pill');
      }

updateGameData();
    }

// 显示使用灵药确认窗口（已废弃）
    // function showMedicineWindow() {
    //   const resource = gameData.resources.medicine;
    //   // 此功能已移除
    // }

// 处理资源点击事件
    function handleResourceClick(resourceId) {
      const resource = gameData.resources[resourceId];

if (!resource || resource.amount <= 0) {
        showNotification('无法使用', `你没有${resource?.name || '该物品'}可以使用`);
        return;
      }



// 处理水类卡牌的饮用
      if (resourceId === 'dirty_water_bowl') {
        // 饮用脏水
        resource.amount--;
        gameData.status.thirst = Math.min(100, gameData.status.thirst + 30); // 增加30点水分值
        gameData.status.health = Math.max(0, gameData.status.health - 15);   // 减少15点健康值
        checkGameOver(); // 检查游戏是否失败
        showNotification('饮用脏水', '你喝了一口脏水，虽然补充了水分但感觉不太舒服，健康有所下降。');
        updateResourceCard(resourceId);
        return;
      }

// 为水袋（满）添加特殊处理
      if (resourceId === 'water_bag_full') {
        showWaterBagConfirmWindow(resourceId);
      }
      // 其他资源点击处理...
    }

// 显示水袋（满）确认使用窗口
    function showWaterBagConfirmWindow(resourceId) {
      const resource = gameData.resources[resourceId];

// 显示确认对话框
      if (confirm(`是否要饮用${resource.name}？\n\n饮用后将补充水分，并获得空水袋。`)) {
        drinkWaterBag(resourceId);
      }
      // 取消则不执行任何操作
    }

// 显示水缸确认喝水窗口（自定义窗口）
    function showWaterTankConfirm() {
      // 创建模态框元素
      const modal = document.createElement('div');
      modal.className = 'water-tank-modal active';
      modal.innerHTML = `
        <div class="water-tank-modal-content ink-border">
          <h2 class="water-tank-modal-title ink-text">饮水</h2>
          <div class="ink-decoration">
            <p class="water-tank-modal-text">水缸中的水有些浑浊，是否要饮水？</p>
          </div>
          <div class="water-tank-modal-effects">
            <div class="effect-item positive">+15% 水分</div>
            <div class="effect-item negative">-5% 健康</div>
          </div>
          <div class="water-tank-modal-buttons">
            <div class="water-tank-modal-button ink-button ink-button-primary confirm" id="confirmDrink">饮水</div>
            <div class="water-tank-modal-button ink-button ink-button-secondary cancel" id="cancelDrink">取消</div>
          </div>
        </div>
      `;

      document.body.appendChild(modal);

      // 添加样式
      const style = document.createElement('style');
      style.textContent = `
        .water-tank-modal {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 500;
          opacity: 0;
          pointer-events: none;
          transition: opacity 0.3s ease;
        }
        
        .water-tank-modal.active {
          opacity: 1;
          pointer-events: all;
        }
        
        .water-tank-modal-content {
          background-color: #FFFDF7;
          border-radius: 6px;
          padding: 24px;
          width: 90%;
          max-width: 400px;
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
          text-align: center;
          animation: modalSlideIn 0.3s ease;
        }
        
        @keyframes modalSlideIn {
          from {
            transform: translateY(-50px);
            opacity: 0;
          }
          to {
            transform: translateY(0);
            opacity: 1;
          }
        }
        
        .water-tank-modal-title {
          font-size: 20px;
          font-weight: normal;
          color: #5D4037;
          margin-bottom: 12px;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }
        
        .water-tank-modal-text {
          font-size: 14px;
          color: #7D6E63;
          margin-bottom: 20px;
          line-height: 1.5;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }
        
        .water-tank-modal-effects {
          margin-bottom: 20px;
          display: flex;
          flex-direction: column;
          gap: 8px;
        }
        
        .effect-item {
          padding: 8px 16px;
          border-radius: 6px;
          font-size: 13px;
          font-weight: normal;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }
        
        .effect-item.positive {
          background-color: #e8f5e8;
          color: #2e7d32;
        }
        
        .effect-item.negative {
          background-color: #ffebee;
          color: #c62828;
        }
        
        .water-tank-modal-buttons {
          display: flex;
          gap: 12px;
          justify-content: center;
        }
        
        .water-tank-modal-button {
          flex: 1;
          max-width: 120px;
          padding: 10px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: normal;
          cursor: pointer;
          transition: all 0.2s ease;
          border: none;
          color: #fff;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }
        
        .water-tank-modal-button.confirm {
          background-color: #8D6E63;
        }
        
        .water-tank-modal-button.confirm:hover {
          background-color: #6D4C41;
          transform: translateY(-2px);
          box-shadow: 0 4px 8px rgba(141, 110, 99, 0.3);
        }
        
        .water-tank-modal-button.cancel {
          background-color: #A1887F;
        }
        
        .water-tank-modal-button.cancel:hover {
          background-color: #8D6E63;
          transform: translateY(-2px);
          box-shadow: 0 4px 8px rgba(161, 136, 127, 0.3);
        }
      `;

      document.head.appendChild(style);

      // 点击确认按钮
      const confirmButton = document.getElementById('confirmDrink');
      confirmButton.addEventListener('click', () => {
        modal.classList.remove('active');
        setTimeout(() => {
          document.body.removeChild(modal);
          document.head.removeChild(style);
        }, 300);
        drinkFromWaterTank();
      });

      // 点击取消按钮
      const cancelButton = document.getElementById('cancelDrink');
      cancelButton.addEventListener('click', () => {
        modal.classList.remove('active');
        setTimeout(() => {
          document.body.removeChild(modal);
          document.head.removeChild(style);
        }, 300);
      });

      // 点击模态框外部关闭
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.classList.remove('active');
          setTimeout(() => {
            document.body.removeChild(modal);
            document.head.removeChild(style);
          }, 300);
        }
      });
    }

// 实现从水缸喝水的功能
    function drinkFromWaterTank() {
      const waterIncrease = Math.floor(gameData.status.thirst * 0.15); // 恢复15%的水分
      const healthDecrease = Math.floor(gameData.status.health * 0.05); // 降低5%的健康

// 应用状态变化
      gameData.status.thirst = Math.min(100, gameData.status.thirst + waterIncrease);
      gameData.status.health = Math.max(0, gameData.status.health - healthDecrease);

// 更新UI显示
      updateGameData();

// 显示结果
      showNotification('喝水完成', `你从水缸中喝了水，水分恢复了${waterIncrease}%，但健康降低了${healthDecrease}%。`);
    }





// 实现饮用装满水的水袋功能
    function drinkWaterBag(resourceId) {
      const fullWaterBag = gameData.resources[resourceId];
      const emptyWaterBag = gameData.resources.water_bag_empty;

if (!fullWaterBag || fullWaterBag.amount <= 0) {
        showNotification('无法使用', '你没有水袋（满）可以使用');
        return;
      }

// 消耗一个水袋（满）
      fullWaterBag.amount--;

// 增加一个水袋（空）
      if (emptyWaterBag) {
        emptyWaterBag.amount++;
      }

// 补充水分30%
      const thirstIncrease = 30;
      gameData.status.thirst = Math.min(100, gameData.status.thirst + thirstIncrease); // 增加水分值

// 显示通知
      showNotification('饮用成功', `你饮用了水袋中的水，水分恢复了${thirstIncrease}%，并获得了一个空水袋。`);

// 更新UI
      updateResourceCard('water_bag_full');
      updateResourceCard('water_bag_empty');
      updateGameData(); // 更新游戏状态UI
    }



// 显示食物确认窗口（已废弃）
    // function showFoodWindow(resourceId) {
    //   // 此功能已移除
    // }

// 使用灵药
    function useMedicine(resourceId) {
      const resource = gameData.resources[resourceId];

if (!resource || resource.amount <= 0) {
        showNotification('无法使用', `你没有${resource?.name || '该物品'}可以使用`);
        return;
      }

// 消耗一个灵药
      resource.amount--;

// 应用效果
      gameData.status.health = Math.min(100, gameData.status.health + 50); // 恢复50点健康值

// 显示通知
      showNotification('使用灵药', '你使用了灵药，恢复了50点健康值！');

// 更新UI
      updateResourceCard(resourceId);

updateGameData();
    }

// 获取装备描述
    function getEquipmentDescription(resourceId) {
      const resource = gameData.resources[resourceId];

// 根据装备类型添加属性加成描述
      switch(resourceId) {
        case 'simple_clothes': // 破衣服
          return '提供基本的保暖，装备后：<br>保暖度 +10';
        case 'shoes': // 破鞋
          return '提供基本的脚部保护，装备后：<br>健康度 +5<br>保暖度 +5';
        case 'crutch': // 拐杖
          return '提高移动能力和声望，装备后：<br>健康度 +10<br>声望 +10';
        case 'black_cloak': // 黑色斗篷
          return '用于进入黑市的特殊衣物，装备后：<br>精神状态 +15<br>解锁黑市访问权限';
        case 'fire': // 篝火
          return '提供温暖，烹饪食物，放置后：<br>保暖度 +20<br>健康度 +5';
        case 'clay_bowl': // 泥碗
          return '提高乞讨成功率，使用后：<br>乞讨成功率 +10%';
        case 'bamboo_bow': // 竹弓
          return '临时提高战斗力，装备后：<br>攻击力 +10<br>命中率 +10%<br>耐久度：' + (resource.durability || 100) + '/100';
        default:
          return resource.description || '无特殊效果';
      }
    }

// 显示装备/卸下窗口
    function showEquipmentWindow(resourceId) {
      const resource = gameData.resources[resourceId];

// 创建装备窗口元素
      const equipmentWindow = document.createElement('div');
      equipmentWindow.className = 'equipment-window ink-border';
      equipmentWindow.id = 'equipmentWindow';
      equipmentWindow.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #FFFDF7;
        border-radius: 0.25rem;
        padding: 1.5rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
        z-index: 1000;
        width: 300px;
        text-align: center;
      `;

// 窗口内容
      const isBambooBow = resourceId === 'bamboo_bow';
      equipmentWindow.innerHTML = `
        <div class="equipment-window-header" style="margin-bottom: 1rem;">
          <h3 class="ink-text" style="font-size: 1.25rem; font-weight: 700; color: #5D4037;">${resource.name}</h3>
        </div>
        <div class="equipment-window-body" style="margin-bottom: 1.5rem;">
          <div style="width: 100px; height: 100px; margin: 0 auto 1rem; background-color: #E2E8F0; border-radius: 0.25rem; overflow: hidden;">
            <img src="${resource.image}" alt="${resource.name}" style="width: 100%; height: 100%; object-fit: cover;">
          </div>
          <p style="color: #7D6E63; margin-bottom: 1rem;">${getEquipmentDescription(resourceId)}</p>
          <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
            <button class="equipment-button ink-button ink-button-primary" id="equipButton">
              ${resource.equipped ? '卸下' : '穿戴'}
            </button>
            ${isBambooBow ? `
            <button class="equipment-button ink-button ink-button-secondary" id="useButton">
              使用
            </button>
            ` : ''}
            <button class="equipment-button ink-button ink-button-secondary" id="cancelButton">
              取消
            </button>
          </div>
        </div>
      `;

// 添加到页面
      document.body.appendChild(equipmentWindow);

// 添加点击事件
      const equipButton = equipmentWindow.querySelector('#equipButton');
      const cancelButton = equipmentWindow.querySelector('#cancelButton');

equipButton.addEventListener('click', function() {
        if (resource.equipped) {
          // 卸下装备
          unequipItem(resource.equipmentSlot, resourceId);
        } else {
          // 装备物品
          equipItem(resourceId);
        }

// 关闭窗口
        closeEquipmentWindow();
      });

// 为竹弓添加使用按钮事件
      if (isBambooBow) {
        const useButton = equipmentWindow.querySelector('#useButton');
        useButton.addEventListener('click', function() {
          // 使用竹弓，消耗耐久度
          decreaseBambooBowDurability();

// 重新渲染装备窗口以更新耐久度显示
          closeEquipmentWindow();
          showEquipmentWindow(resourceId);
        });
      }

cancelButton.addEventListener('click', function() {
        closeEquipmentWindow();
      });

// 点击窗口外部关闭
      equipmentWindow.addEventListener('click', function(e) {
        if (e.target === equipmentWindow) {
          closeEquipmentWindow();
        }
      });
    }

// 关闭装备窗口
    function closeEquipmentWindow() {
      const equipmentWindow = document.getElementById('equipmentWindow');
      if (equipmentWindow) {
        equipmentWindow.remove();
      }
    }

// 显示学习确认窗口
    function showLearnWindow(resourceId) {
      const resource = gameData.resources[resourceId];

// 创建学习窗口元素
      const learnWindow = document.createElement('div');
      learnWindow.className = 'learn-window ink-border';
      learnWindow.id = 'learnWindow';
      learnWindow.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #FFFDF7;
        border-radius: 0.25rem;
        padding: 1.5rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
        z-index: 1000;
        width: 300px;
        text-align: center;
      `;

// 窗口内容
      learnWindow.innerHTML = `
        <div class="learn-window-header" style="margin-bottom: 1rem;">
          <h3 class="ink-text" style="font-size: 1.25rem; font-weight: 700; color: #5D4037;">${resource.name}</h3>
        </div>
        <div class="learn-window-body" style="margin-bottom: 1.5rem;">
          <div style="width: 100px; height: 100px; margin: 0 auto 1rem; background-color: #E2E8F0; border-radius: 0.25rem; overflow: hidden;">
            <img src="${resource.image}" alt="${resource.name}" style="width: 100%; height: 100%; object-fit: cover;">
          </div>
          <p style="color: #7D6E63; margin-bottom: 1rem;">${resource.description}</p>
          <div style="display: flex; gap: 1rem; justify-content: center;">
            <button class="learn-button ink-button ink-button-primary" id="learnButton">
              学习
            </button>
            <button class="learn-button ink-button ink-button-secondary" id="cancelLearnButton">
              取消
            </button>
          </div>
        </div>
      `;

// 添加到页面
      document.body.appendChild(learnWindow);

// 添加点击事件
      const learnButton = learnWindow.querySelector('#learnButton');
      const cancelButton = learnWindow.querySelector('#cancelLearnButton');

learnButton.addEventListener('click', function() {
        // 学习物品
        learnItem(resourceId);

// 关闭窗口
        closeLearnWindow();
      });

cancelButton.addEventListener('click', function() {
        closeLearnWindow();
      });

// 点击窗口外部关闭
      learnWindow.addEventListener('click', function(e) {
        if (e.target === learnWindow) {
          closeLearnWindow();
        }
      });
    }

// 关闭学习窗口
    function closeLearnWindow() {
      const learnWindow = document.getElementById('learnWindow');
      if (learnWindow) {
        learnWindow.remove();
      }
    }

// 检查技能是否需要升级
    function checkSkillLevelUp(skillId, eventResults) {
      const skill = gameData.skills[skillId];
      if (!skill) return;

// 检查技能是否已经达到最高等级
      if (skill.level >= skill.maxLevel) return;

// 检查当前经验是否达到下一级所需的经验
      if (gameData.skillExpRequired[skill.level + 1] && skill.experience >= gameData.skillExpRequired[skill.level + 1]) {
        // 提升技能等级
        skill.level++;

// 武术技能升级时增加武力值：每级+5
        if (skillId === 'martial') {
            if (!skill.power) {
                skill.power = 10; // 确保基础武力值正确
            } else {
                skill.power += 5;
                levelUpEffect += `\n武力值增加5点，当前武力值：${skill.power}`;
            }
        }

// 获取技能名称
        const skillName = skill.name || skillId;

// 更新效果描述
        let levelUpEffect = `${skillName}技能升级到 ${skill.level} 级！`;

// 添加到事件结果（如果当前正在处理事件）
        if (eventResults) {
          eventResults.effects.push(levelUpEffect);
        }

// 显示升级通知
        showNotification('技能升级', levelUpEffect);

// 更新技能显示UI
        updateSkillDisplay();

// 检查是否可以继续升级
        checkSkillLevelUp(skillId, eventResults);
      }
    }

// 更新技能显示
    function updateSkillDisplay() {
      // 技能显示现在通过技能按钮和窗口完成，不再在状态栏中显示
      // 移除现有的技能容器（如果存在）
      const existingSkillsContainer = document.getElementById('skillsContainer');
      if (existingSkillsContainer) {
        existingSkillsContainer.remove();
      }

// 如果技能窗口已打开，更新技能列表中的经验条
      const skillsWindow = document.getElementById('skillsWindow');
      if (skillsWindow) {
        const skillsList = skillsWindow.querySelector('.skills-list');
        if (skillsList) {
          skillsList.innerHTML = '';
          renderSkillsInWindow(skillsList);
        }
      }

return;
      // 以下是原函数内容，已被注释掉
      /*
      try {
        // 创建或获取技能显示容器
        let skillsContainer = document.getElementById('skillsContainer');
        if (!skillsContainer) {
          // 在状态栏中创建技能显示区域 - 修正选择器为status-grid
          const statusDiv = document.querySelector('.status-grid');

// 健壮的错误检查
          if (!statusDiv) {
            console.warn('无法找到状态容器元素(.status-grid)，跳过技能显示创建');
            return;
          }

skillsContainer = document.createElement('div');
          skillsContainer.id = 'skillsContainer';
          skillsContainer.className = 'skills-container';
          skillsContainer.style.cssText = `
            margin-top: 1rem;
            padding: 1rem;
            background-color: #F7FAFC;
            border-radius: 0.5rem;
            border: 1px solid #E2E8F0;
          `;

// 添加标题
          const title = document.createElement('h3');
          title.textContent = '技能';
          title.style.cssText = `
            font-size: 1rem;
            font-weight: normal;
            color: #2D3748;
            margin-bottom: 0.75rem;
          `;
          skillsContainer.appendChild(title);

statusDiv.appendChild(skillsContainer);
        }

// 清空现有内容
      while (skillsContainer.children.length > 1) { // 保留标题
        skillsContainer.removeChild(skillsContainer.lastChild);
      }

// 创建技能列表
      const skillsList = document.createElement('div');
      skillsList.className = 'skills-list';
      skillsList.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      `;

// 遍历所有技能
      for (const [skillId, skill] of Object.entries(gameData.skills)) {
        const skillItem = document.createElement('div');
        skillItem.className = 'skill-item';
        skillItem.style.cssText = `
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 0.5rem;
          background-color: #EDF2F7;
          border-radius: 0.25rem;
        `;

// 技能名称和等级
        const skillInfo = document.createElement('div');
        skillInfo.style.cssText = `
          font-size: 0.875rem;
          color: #4A5568;
        `;
        skillInfo.textContent = `${skill.name} (等级 ${skill.level}/${skill.maxLevel})`;

// 经验条
        const expContainer = document.createElement('div');
        expContainer.style.cssText = `
          width: 120px;
          height: 0.5rem;
          background-color: #E2E8F0;
          border-radius: 0.25rem;
          overflow: hidden;
        `;

const expBar = document.createElement('div');
        expBar.className = 'exp-bar';

// 计算经验进度百分比
        let expPercentage = 0;
        if (skill.level < skill.maxLevel) {
          const currentExp = skill.experience - (skill.level > 1 ? gameData.skillExpRequired[skill.level - 1] : 0);
          const requiredExp = gameData.skillExpRequired[skill.level] - (skill.level > 1 ? gameData.skillExpRequired[skill.level - 1] : 0);
          expPercentage = requiredExp > 0 ? (currentExp / requiredExp) * 100 : 100;
        }

expBar.style.cssText = `
          height: 100%;
          width: ${expPercentage}%;
          background-color: #805AD5;
          transition: width 0.3s ease;
        `;

expContainer.appendChild(expBar);
        skillItem.appendChild(skillInfo);
        skillItem.appendChild(expContainer);
        skillsList.appendChild(skillItem);
      }

skillsContainer.appendChild(skillsList);
      }
      catch (error) {
        console.error('更新技能显示时出错:', error);
      }
      */
    }

// 装备物品
    function equipItem(resourceId) {
      const resource = gameData.resources[resourceId];

if (!resource || !resource.equipmentSlot) {
        showNotification('装备失败', '这不是可装备物品');
        return;
      }

// 检查物品数量
      if (resource.amount <= 0) {
        showNotification('装备失败', `你没有${resource.name}可以装备`);
        return;
      }

// 检查该槽位是否已有装备
      const slotType = resource.equipmentSlot;
      const slot = document.querySelector(`.equipment-slots .combination-slot[data-slot="${slotType}"]`);

// 检查该槽位是否已有装备
      for (const [currentResourceId, currentResource] of Object.entries(gameData.resources)) {
        if (currentResource.equipmentSlot === slotType && currentResource.equipped) {
          // 卸下当前装备
          unequipItem(slotType, currentResourceId);
          break;
        }
      }

// 装备新物品
      resource.equipped = true;

// 应用装备效果
      applyEquipmentEffect(resourceId, 'equip');

// 更新游戏数据和状态栏（确保体温变化及时显示）
      updateGameData();

// 更新当前装备槽
      updateEquipmentSlot(slotType, resourceId);

// 更新背包
      updateResourceCard(resourceId);

// 显示通知
      showNotification('装备成功', `成功装备了${resource.name}`);
    }

// 学习物品
    function learnItem(resourceId) {
      const resource = gameData.resources[resourceId];

if (!resource || resource.type !== 'learnable') {
        showNotification('学习失败', '这不是可学习物品');
        return;
      }

// 检查物品数量
      if (resource.amount <= 0) {
        showNotification('学习失败', `你没有${resource.name}可以学习`);
        return;
      }

// 获取关联的技能
      const skillType = resource.skill;
      if (!skillType || !gameData.skills[skillType]) {
        showNotification('学习失败', '此物品没有关联的技能');
        return;
      }

// 提升技能等级（学习技能书直接提升1级）
      const skill = gameData.skills[skillType];
      if (skill.level < skill.maxLevel) {
        // 增加1级
        skill.level += 1;

// 重置经验值为当前等级所需的基础值
        if (skill.level > 1) {
          skill.experience = gameData.skillExpRequired[skill.level - 1];
        }

// 特殊效果处理
        let specialEffect = '';
        switch(resourceId) {
          case 'day_stealing':
            specialEffect = '偷窃成功率增加30%';
            gameData.skills.thievery.successRateBonus = 0.3; // 30%成功率加成
            break;
          case 'herbal_canon':
            specialEffect = '获得草药识别能力';
            // 标记已学会识别草药
            gameData.skills.medicine.canIdentifyHerbs = true;
            break;
          case 'huangdi_canon':
            specialEffect = '获得疾病治疗能力（成功率40%）';
            // 标记已学会治疗疾病
            gameData.skills.medicine.canTreatDisease = true;
            gameData.skills.medicine.cureSuccessRate = 0.4; // 40%治疗成功率

// 添加治疗疾病的功能（如果需要，可以在这里初始化相关按钮或功能）
            if (!window.hasOwnProperty('handleDiseaseTreatment')) {
              window.handleDiseaseTreatment = function() {
                if (!gameData.skills.medicine.canTreatDisease) {
                  showNotification('无法治疗', '你还没有学会治疗疾病的技能');
                  return;
                }

// 检查是否生病
                if (!gameData.status.isSick) {
                  showNotification('无需治疗', '你目前没有生病');
                  return;
                }

// 计算治疗成功率：基础40% + 每级5%
                const totalCureRate = Math.min(0.95, gameData.skills.medicine.cureSuccessRate + (gameData.skills.medicine.level * 0.05));
                // 尝试治疗
                const success = Math.random() < totalCureRate;
                if (success) {
                  gameData.status.isSick = false;
                  gameData.status.health = Math.min(100, gameData.status.health + 10); // 治疗成功后恢复一些健康值

showNotification('治疗成功', '你成功治愈了疾病！健康值恢复了10点。');

// 治疗成功增加医术技能经验值
                  gameData.skills.medicine.experience += 2;
                  checkSkillLevelUp('medicine');
                } else {
                  showNotification('治疗失败', '治疗失败了，你需要休息一下再尝试。');
                }

// 更新游戏数据
                updateGameData();
              };
            }
            break;
          case 'dog_beating_stick':
            specialEffect = '击中概率增加30%';
            // 标记已学会打狗棒法
            gameData.skills.martial.canUseDogStick = true;
            gameData.skills.martial.hitProbabilityBonus = 0.3; // 30%击中概率加成
            // 初始化武术武力值：基础10 + 每级5
            if (!gameData.skills.martial.power) {
                gameData.skills.martial.power = 10;
            }
            break;
        }

// 显示通知
        showNotification('学习成功', `成功学习了${resource.name}！\n${skill.name}技能提升至${skill.level}级！\n${specialEffect}`);
      } else {
        showNotification('学习失败', '该技能已经达到最高等级');
        return;
      }

// 如果是一次性使用物品，消耗一个
      if (resource.oneTimeUse) {
        resource.amount--;

// 如果数量为0且不可丢弃，保持在背包中但显示为0
        if (resource.amount <= 0 && !resource.cannotDrop) {
          // 可以从背包中移除
          // 这里我们暂时保留，只是数量为0
        }
      }

// 更新UI
      updateResourceCard(resourceId);
      updateSkillDisplay(); // 需要实现这个函数来更新技能显示
      updateGameData();
    }

// 显示房屋地契确认弹窗
    function showHouseDeedConfirmModal() {
      // 创建确认弹窗
      const modal = document.createElement('div');
      modal.className = 'house-deed-modal';
      modal.innerHTML = `
        <div class="house-deed-modal-content ink-border">
          <h2 class="house-deed-modal-title ink-text">拥有房屋</h2>
          <div class="ink-decoration">
            <p class="house-deed-modal-text">你是否准备使用房屋地契，拥有自己的宅邸？</p>
          </div>
          <div class="house-deed-modal-buttons">
            <button class="house-deed-modal-button ink-button ink-button-primary" id="confirmHouseDeed">确定</button>
            <button class="house-deed-modal-button ink-button ink-button-secondary" id="cancelHouseDeed">取消</button>
          </div>
        </div>
      `;

      // 添加样式
      const style = document.createElement('style');
      style.textContent = `
        .house-deed-modal {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 1000;
          opacity: 0;
          pointer-events: none;
          transition: opacity 0.3s ease;
        }

        .house-deed-modal.active {
          opacity: 1;
          pointer-events: auto;
        }

        .house-deed-modal-content {
          background-color: #FFFDF7;
          padding: 2rem;
          box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
          width: 350px;
          text-align: center;
          border-radius: 0.25rem;
        }

        .house-deed-modal-title {
          font-size: 1.5rem;
          font-weight: normal;
          color: #5D4037;
          margin-bottom: 1rem;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }

        .house-deed-modal-text {
          color: #7D6E63;
          margin-bottom: 1.5rem;
          line-height: 1.5;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }

        .house-deed-modal-buttons {
          display: flex;
          gap: 1rem;
          justify-content: center;
        }

        .house-deed-modal-button {
          background-color: #8D6E63;
          color: white;
          padding: 0.75rem 1.5rem;
          border-radius: 0.375rem;
          cursor: pointer;
          font-weight: normal;
          transition: background-color 0.2s;
          display: inline-block;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
          border: none;
        }

        .house-deed-modal-button:hover {
          background-color: #6D4C41;
        }

        .house-deed-modal-button.ink-button-secondary {
          background-color: #A0AEC0;
        }

        .house-deed-modal-button.ink-button-secondary:hover {
          background-color: #718096;
        }
      `;

      document.head.appendChild(style);
      document.body.appendChild(modal);

      // 显示弹窗
      setTimeout(() => {
        modal.classList.add('active');
      }, 10);

      // 确定按钮事件
      const confirmButton = document.getElementById('confirmHouseDeed');
      confirmButton.addEventListener('click', function() {
        // 移除房屋地契
        const houseDeed = gameData.resources.house_deed;
        if (houseDeed && houseDeed.amount > 0) {
          houseDeed.amount = 0;
          updateResourceCard('house_deed');
        }

        // 添加"我的宅邸"地点到游戏中
        addMyMansionLocation();

        // 关闭弹窗
        modal.classList.remove('active');
        setTimeout(function() {
          if (modal.parentNode) {
            modal.parentNode.removeChild(modal);
          }
          if (style.parentNode) {
            style.parentNode.removeChild(style);
          }
        }, 300);

        // 显示通知
        showNotification('拥有宅邸', '你使用房屋地契拥有了属于自己的宅邸，地图上已新增"我的宅邸"地点。');
      });

      // 取消按钮事件
      const cancelButton = document.getElementById('cancelHouseDeed');
      cancelButton.addEventListener('click', function() {
        modal.classList.remove('active');
        setTimeout(function() {
          if (modal.parentNode) {
            modal.parentNode.removeChild(modal);
          }
          if (style.parentNode) {
            style.parentNode.removeChild(style);
          }
        }, 300);
      });

      // 点击弹窗外部关闭
      modal.addEventListener('click', function(e) {
        if (e.target === modal) {
          modal.classList.remove('active');
          setTimeout(function() {
            if (modal.parentNode) {
              modal.parentNode.removeChild(modal);
            }
            if (style.parentNode) {
              style.parentNode.removeChild(style);
            }
          }, 300);
        }
      });
    }

// 添加"我的宅邸"地点到游戏中
    function addMyMansionLocation() {
      // 检查是否已经存在"我的宅邸"地点
      const existingLocation = gameData.locations.find(loc => loc.id === 'my_mansion');
      if (!existingLocation) {
        // 创建新地点
        const myMansionLocation = {
          id: 'my_mansion',
          name: '我的宅邸',
          description: '你自己的宅邸，可以提供舒适的休息环境和安全保障。',
          image: 'UI/我的宅邸.jpg',
          available: true,
          resourceType: '',
          dangerLevel: 'none',
          actionPointCost: 1,
          entryCondition: {},
          currentLocation: false,
          actions: ['rest', 'sleep', 'eat', 'store_items']
        };

        // 添加到地点列表
        gameData.locations.push(myMansionLocation);

        // 添加地图坐标
        if (!gameData.mapPositions) {
          gameData.mapPositions = {};
        }
        gameData.mapPositions['my_mansion'] = { x: 400, y: 200 };

        // 更新地点显示
        renderLocations();
        updateMapModal();
      }
    }

// 显示烤火确认窗口
    function showCampfireConfirmModal() {
      const modal = document.createElement('div');
      modal.className = 'campfire-modal active';
      modal.innerHTML = `
        <div class="campfire-modal-content ink-border">
          <h2 class="campfire-modal-title ink-text">篝火取暖</h2>
          <div class="ink-decoration">
            <p class="campfire-modal-text">温暖的火焰在燃烧，是否需要篝火取暖？</p>
          </div>
          <div class="campfire-modal-buttons">
            <div class="campfire-modal-button ink-button ink-button-primary" id="confirmCampfire">篝火取暖</div>
            <div class="campfire-modal-button ink-button ink-button-secondary" id="cancelCampfire">取消</div>
          </div>
        </div>
      `;

      document.body.appendChild(modal);

// 添加样式
      const style = document.createElement('style');
      style.textContent = `
        .campfire-modal {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 500;
          opacity: 0;
          pointer-events: none;
          transition: opacity 0.3s ease;
        }

        .campfire-modal.active {
          opacity: 1;
          pointer-events: auto;
        }

        .campfire-modal-content {
          background-color: #FFFDF7;
          padding: 30px;
          border-radius: 6px;
          box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
          max-width: 400px;
          width: 90%;
          text-align: center;
        }

        .campfire-modal-title {
          font-size: 24px;
          margin-bottom: 20px;
          color: #5D4037;
          font-weight: normal;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }

        .campfire-modal-text {
          font-size: 18px;
          margin-bottom: 25px;
          line-height: 1.6;
          color: #7D6E63;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }

        .campfire-modal-buttons {
          display: flex;
          justify-content: space-between;
          margin-top: 20px;
        }

        .campfire-modal-button {
          background-color: #8D6E63;
          color: white;
          border: none;
          padding: 12px 24px;
          border-radius: 6px;
          cursor: pointer;
          font-size: 18px;
          font-weight: normal;
          transition: all 0.3s ease;
          flex: 1;
          margin: 0 5px;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }

        .campfire-modal-button:hover {
          background-color: #6D4C41;
          transform: translateY(-2px);
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .campfire-modal-button:active {
          transform: translateY(0);
        }
      `;

      document.head.appendChild(style);

// 添加事件监听器
      const confirmCampfire = document.getElementById('confirmCampfire');
      const cancelCampfire = document.getElementById('cancelCampfire');

      if (confirmCampfire) {
        confirmCampfire.addEventListener('click', () => {
          // 调用烤火函数执行正确的烤火逻辑
          warmByFire();
          modal.classList.remove('active');
          setTimeout(() => modal.remove(), 300);
        });
      }

      if (cancelCampfire) {
        cancelCampfire.addEventListener('click', () => {
          modal.classList.remove('active');
          setTimeout(() => modal.remove(), 300);
        });
      }

// 点击背景关闭弹窗
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.classList.remove('active');
          setTimeout(() => modal.remove(), 300);
        }
      });
    }

// 卸下装备
    function unequipItem(slotType, resourceId) {
      const resource = gameData.resources[resourceId];

if (resource) {
        // 移除装备效果
        applyEquipmentEffect(resourceId, 'unequip');

// 移除装备状态
        resource.equipped = false;

// 更新装备槽
        updateEquipmentSlot(slotType);

// 更新背包
        updateResourceCard(resourceId);

// 更新UI
        updateGameData();

// 显示通知
        showNotification('卸下装备', `成功卸下了${resource.name}`);
      }
    }

// 应用装备效果
    function applyEquipmentEffect(resourceId, action) {
      const resource = gameData.resources[resourceId];

// 根据装备类型应用不同效果
      switch(resourceId) {
        case 'simple_clothes': // 破衣服
          if (action === 'equip') {
            gameData.status.cold = Math.min(50, gameData.status.cold + 0.2); // 体温增加（保暖）
            showNotification('装备效果', '破衣服提供了基本的保暖，体温上升0.2℃');
          } else {
            gameData.status.cold = Math.max(30, gameData.status.cold - 0.2); // 体温减少（失去保暖）
            showNotification('装备效果', '卸下了破衣服，体温下降0.2℃');
          }
          break;

case 'black_cloak': // 黑色斗篷
          if (action === 'equip') {
            gameData.status.spirit += 15; // 提高精神状态
            // 解锁黑市
            const blackMarket = gameData.locations.find(loc => loc.id === 'black_market');
            if (blackMarket) {
              blackMarket.available = true;
              showNotification('装备效果', '黑色斗篷让你获得了进入黑市的资格！');
            }
            showNotification('装备效果', '黑色斗篷提升了你的精神状态，精神增加15点');
          } else {
            gameData.status.spirit -= 15; // 移除精神提升
            // 检查是否还有其他黑色斗篷
            if (gameData.resources.black_cloak.amount === 0) {
              // 锁定黑市
              const blackMarket = gameData.locations.find(loc => loc.id === 'black_market');
              if (blackMarket) {
                blackMarket.available = false;
                showNotification('装备效果', '没有黑色斗篷，无法进入黑市');
              }
            }
            showNotification('装备效果', '卸下了黑色斗篷，精神减少15点');
          }
          break;

case 'crutch': // 拐杖
          if (action === 'equip') {
            gameData.status.strength += 5; // 提高武力值
            gameData.status.reputation += 10; // 提高声望
            showNotification('装备效果', '拐杖帮助你行走，武力增加5点，声望增加10点');
          } else {
            gameData.status.strength -= 5; // 移除武力提升
            gameData.status.reputation -= 10; // 移除声望提升
            showNotification('装备效果', '卸下了拐杖，武力减少5点，声望减少10点');
          }
          break;

case 'fine_clothes': // 精美华服
          if (action === 'equip') {
            gameData.status.reputation += 20; // 大幅提高声望
            gameData.status.cold = Math.min(50, gameData.status.cold + 0.3); // 体温增加（保暖）
            showNotification('装备效果', '精美华服让你看起来体面，声望增加20点，体温上升0.3℃');
          } else {
            gameData.status.reputation -= 20; // 移除声望提升
            gameData.status.cold = Math.max(30, gameData.status.cold - 0.3); // 体温减少（失去保暖）
            showNotification('装备效果', '卸下了精美华服，声望减少20点，体温下降0.3℃');
          }
          break;

case 'silk_shoes': // 缎鞋
          if (action === 'equip') {
            gameData.status.health += 10; // 提高健康度
            gameData.status.cold = Math.min(50, gameData.status.cold + 0.1); // 体温增加（保暖）
            showNotification('装备效果', '缎鞋舒适保暖，健康增加10点，体温上升0.1℃');
          } else {
            gameData.status.health -= 10; // 移除健康提升
            checkGameOver(); // 检查游戏是否失败
            gameData.status.cold = Math.max(34, gameData.status.cold - 0.1); // 体温减少（失去保暖）
            showNotification('装备效果', '卸下了缎鞋，健康减少10点，体温下降0.1℃');
          }
          break;

case 'dog_beating_stick': // 打狗棒法
          if (action === 'equip') {
            gameData.status.reputation += 30; // 大幅提高声望
            gameData.status.health += 15; // 提高健康度
            showNotification('装备效果', '打狗棒法让你成为丐帮传人，声望增加30点，健康增加15点');
          } else {
            gameData.status.reputation -= 30; // 移除声望提升
            gameData.status.health -= 15; // 移除健康提升
            checkGameOver(); // 检查游戏是否失败
            showNotification('装备效果', '卸下了打狗棒法，声望减少30点，健康减少15点');
          }
          break;

case 'bamboo_bow': // 竹弓
          if (action === 'equip') {
            // 初始化攻击和命中率属性（如果不存在）
            if (gameData.status.attack === undefined) gameData.status.attack = 0;
            if (gameData.status.accuracy === undefined) gameData.status.accuracy = 0;

gameData.status.attack += 10; // 攻击+10
            gameData.status.accuracy += 10; // 命中率+10%
            showNotification('装备效果', '竹弓已装备，攻击增加10点，命中率增加10%');
          } else {
            gameData.status.attack -= 10; // 移除攻击提升
            gameData.status.accuracy -= 10; // 移除命中率提升
            showNotification('装备效果', '卸下了竹弓，攻击减少10点，命中率减少10%');
          }
          break;
      }

// 确保状态值在合理范围内
      for (const stat of ['cold', 'spirit', 'health', 'reputation', 'attack', 'accuracy']) {
        if (gameData.status[stat] !== undefined) {
          gameData.status[stat] = Math.max(0, Math.min(100, gameData.status[stat]));
        }
      }

// 更新UI
      updateGameData();
      renderLocations(); // 更新地点显示
    }

    // 保存游戏进度到文件系统（save文件夹）
    function saveGameProgress() {
      try {
        // 创建一个深拷贝以避免存储循环引用
        const gameDataToSave = JSON.parse(JSON.stringify(gameData));

// 移除不需要保存的临时数据
        delete gameDataToSave.uiState;
        delete gameDataToSave.tempData;

// 生成带时间戳的文件名
        const currentDate = new Date();
        const timestamp = `${currentDate.getFullYear()}${String(currentDate.getMonth() + 1).padStart(2, '0')}${String(currentDate.getDate()).padStart(2, '0')}_${String(currentDate.getHours()).padStart(2, '0')}${String(currentDate.getMinutes()).padStart(2, '0')}`;
        const fileName = `beggar_save_${timestamp}.json`;

// 同时保存到localStorage作为备份
        localStorage.setItem('beggarSurvivalGameSave', JSON.stringify(gameDataToSave));

// 创建可下载的文件
        const jsonString = JSON.stringify(gameDataToSave, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

// 创建下载链接
        const downloadLink = document.createElement('a');
        downloadLink.href = url;
        downloadLink.download = fileName;

// 触发下载
        document.body.appendChild(downloadLink);
        downloadLink.click();
        if (downloadLink.parentNode === document.body) {
        document.body.removeChild(downloadLink);
      }

// 清理URL对象
        URL.revokeObjectURL(url);

console.log('游戏进度已保存');
        showNotification('保存成功', '请将文件保存到游戏目录下的save文件夹中');

return true;
      } catch (error) {
        console.error('保存游戏进度失败:', error);
        showNotification('保存失败', '无法保存游戏进度，请重试');
        return false;
      }
    }

// 处理开始界面的游戏加载功能
    function handleLoadGame() {
      try {
        // 尝试使用Directory API直接选择文件夹
        if ('showDirectoryPicker' in window) {
          // 直接调用Directory API选择默认的save文件夹
          handleDirectorySelection('save').catch(error => {
            console.log('文件夹选择失败或取消，切换到文件选择模式:', error);
            // 降级到传统文件选择器
            showTraditionalFilePicker();
          });
        } else {
          // 不支持Directory API，使用传统文件选择器
          showTraditionalFilePicker();
        }
      } catch (error) {
        console.error('加载游戏初始化失败:', error);
        showNotification('操作失败', '无法初始化游戏加载功能');
        // 作为最后的降级方案，显示传统文件选择器
        setTimeout(() => {
          showTraditionalFilePicker();
        }, 1000);
      }
    }

// 使用Directory API处理文件夹选择
    async function handleDirectorySelection(defaultFolderName = null) {
      try {
        // 请求访问文件夹权限
        const options = {
          mode: 'read'
        };

// 如果指定了默认文件夹名称，尝试打开该文件夹
        if (defaultFolderName) {
          options.startIn = 'documents';
          options.suggestedName = defaultFolderName;
        } else {
          options.startIn = 'documents';
        }

const directoryHandle = await window.showDirectoryPicker(options);

console.log('已选择文件夹:', directoryHandle.name);
        showNotification('扫描中', '正在扫描文件夹中的存档文件...');

// 获取文件夹中的所有JSON文件
        const saveFiles = [];
        for await (const [name, handle] of directoryHandle.entries()) {
          if (handle.kind === 'file' && name.endsWith('.json')) {
            saveFiles.push({ name, handle });
          }
        }

// 按文件名排序（假设文件名包含时间戳，最新的应该在最后）
        saveFiles.sort((a, b) => a.name.localeCompare(b.name));

if (saveFiles.length === 0) {
          showNotification('未找到存档', '在选择的文件夹中没有找到JSON存档文件');
          return;
        }

// 构建存档选择菜单的HTML
        let saveOptions = '';
        saveFiles.forEach((file, index) => {
          saveOptions += `<option value="${index}">${file.name}</option>`;
        });

// 创建临时表单进行存档选择
        const selectionHTML = `
          <div style="padding: 15px;">
            <h3>选择存档文件</h3>
            <p>在 ${directoryHandle.name} 文件夹中找到 ${saveFiles.length} 个存档文件：</p>
            <select id="saveFileSelect" style="width: 100%; padding: 10px; margin: 10px 0;">
              ${saveOptions}
            </select>
            <p style="font-size: 0.9em; color: gray;">提示：如果需要浏览其他文件夹，请点击取消后重新尝试</p>
          </div>
        `;

// 使用自定义确认对话框选择存档
        const userChoice = await showCustomConfirm('选择存档', selectionHTML);

if (userChoice.confirmed && userChoice.selectedIndex >= 0) {
          const selectedIndex = userChoice.selectedIndex;
          const selectedFile = saveFiles[selectedIndex];

// 获取文件对象并传递给processSaveFile
          const file = await selectedFile.handle.getFile();

// 处理选中的存档文件
          processSaveFile(file);

console.log('已成功加载存档:', selectedFile.name);
        }
      } catch (error) {
        // 如果是用户取消选择，不记录为错误
        if (error.name === 'AbortError') {
          console.log('用户取消了文件夹选择');
          showNotification('操作取消', '您已取消文件夹选择');
          return; // 静默返回，不触发降级
        }
        // 对于其他错误，记录错误日志
        console.error('处理文件夹选择时出错:', error);
        // 显示通知并重新抛出以触发降级
        showNotification('操作失败', '文件夹选择过程中发生错误');
        throw error;
      }
    }

// 显示传统的文件选择器
    function showTraditionalFilePicker() {
      // 首先显示指引信息，帮助用户找到save文件夹
      const saveFolderPath = 'beggar_survival_game\\save';
      const guidanceMessage = `请在文件选择对话框中导航到以下路径选择存档文件：

${saveFolderPath}

步骤：
1. 在文件选择对话框中导航到游戏所在目录
2. 打开"save"文件夹
3. 选择一个.json存档文件

提示：如果使用Chrome或Edge浏览器，您可以尝试使用文件夹选择功能。`;

// 显示指引信息
      alert(guidanceMessage);

// 创建文件选择器
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      // 限制只能选择JSON文件
      fileInput.accept = '.json';
      // 添加multiple属性，允许选择多个文件（虽然我们一次只处理一个）
      fileInput.multiple = false;

// 添加文件选择后的处理逻辑
      fileInput.onchange = function(event) {
        const file = event.target.files[0];
        if (file) {
          processSaveFile(file);
        }
      };

// 触发文件选择器
      fileInput.click();
    }

// 处理选中的存档文件
    function processSaveFile(file) {
      console.log('选择的文件:', file.name);
      // 显示加载中的提示
      showNotification('加载中', `正在读取存档文件: ${file.name}...`);

// 读取文件内容
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          // 解析JSON内容
          const loadedGameData = JSON.parse(e.target.result);

// 验证数据有效性
          if (!loadedGameData.day || !loadedGameData.resources || !loadedGameData.status) {
            throw new Error('存档文件格式无效，缺少必要字段');
          }

// 清空当前gameData并加载保存的数据（保留uiState和tempData）
          Object.keys(gameData).forEach(key => {
            if (key !== 'uiState' && key !== 'tempData') {
              delete gameData[key];
            }
          });

// 合并加载的数据到gameData
          Object.assign(gameData, loadedGameData);

// 同时保存到localStorage作为备份
          localStorage.setItem('beggarSurvivalGameSave', JSON.stringify(gameData));

// 显示加载成功提示
          showNotification('加载成功', `成功加载存档: ${file.name}`);

// 切换到游戏界面
          switchToGameView();

// 根据当前天数重新计算季节（修复存档中季节值可能不正确的问题）
          gameData.season = calculateSeason(gameData.day);

// 确保篝火资源有正确的燃料属性
          if (gameData.resources.fire && gameData.resources.fire.fuel === undefined) {
            gameData.resources.fire.fuel = 100;
          }
          
          // 初始化熄灭的篝火资源（如果不存在）
          if (!gameData.resources.fire_extinguished) {
            gameData.resources.fire_extinguished = {
              name: '篝火（灭）',
              amount: 0,
              image: 'UI/篝火（灭）.jpg',
              durability: 100,
              category: 'material'
            };
          }
          
          // 更新UI以反映加载的游戏状态
          updateGameData();
          renderResources();
          renderLocations();
          renderActions();
          renderEquipmentSlots();
          updateSkillDisplay();
          updateWeatherEffects();

} catch (parseError) {
          console.error('解析存档文件失败:', parseError);
          showNotification('加载失败', '无法解析存档文件，请检查文件格式是否正确');
        }
      };

reader.onerror = function() {
        console.error('读取文件失败');
        showNotification('读取失败', '无法读取存档文件，请检查文件是否损坏');
      };

reader.readAsText(file);
    }

// 切换到游戏视图函数
    function switchToGameView() {
      try {
        debugLog('切换到游戏视图');
        // 如果开始屏幕存在，隐藏它
        if (elements.startScreen) {
          elements.startScreen.style.opacity = '0';
          elements.startScreen.style.display = 'none';
        }

// 显示游戏容器
        if (elements.gameContainer) {
          elements.gameContainer.style.display = 'block';
        }

debugLog('已切换到游戏视图');
      } catch (error) {
        console.error('切换到游戏视图时出错:', error);
        showNotification('切换失败', '无法切换到游戏视图');
      }
    }

    // 自定义确认对话框函数
    function showCustomConfirm(title, contentHTML) {
      return new Promise((resolve) => {
        // 创建对话框元素
        const dialog = document.createElement('div');
        dialog.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: #fff;
          padding: 20px;
          border-radius: 10px;
          box-shadow: 0 10px 25px rgba(0,0,0,0.2);
          z-index: 10000;
          max-width: 500px;
          width: 90%;
          max-height: 80vh;
          overflow-y: auto;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', Arial, sans-serif;
        `;

// 创建标题
        const dialogTitle = document.createElement('h2');
        dialogTitle.textContent = title;
        dialogTitle.style.cssText = 'margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 10px;';

// 创建内容容器
        const contentContainer = document.createElement('div');
        contentContainer.innerHTML = contentHTML;

// 创建按钮容器
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = 'margin-top: 20px; text-align: right;';

// 创建取消按钮
        const cancelButton = document.createElement('button');
        cancelButton.textContent = '取消';
        cancelButton.style.cssText = `
          padding: 10px 20px;
          margin-right: 10px;
          background-color: #f0f0f0;
          border: none;
          border-radius: 5px;
          cursor: pointer;
          font-size: 16px;
        `;

// 创建确认按钮
        const confirmButton = document.createElement('button');
        confirmButton.textContent = '确认';
        confirmButton.style.cssText = `
          padding: 10px 20px;
          background-color: #4CAF50;
          color: white;
          border: none;
          border-radius: 5px;
          cursor: pointer;
          font-size: 16px;
        `;

// 创建背景遮罩
        const overlay = document.createElement('div');
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.5);
          z-index: 9999;
        `;

// 添加事件监听
        cancelButton.addEventListener('click', () => {
          if (dialog.parentNode === document.body) {
        document.body.removeChild(dialog);
      }
      if (overlay.parentNode === document.body) {
        document.body.removeChild(overlay);
      }
          resolve({ confirmed: false, selectedIndex: -1 });
        });

confirmButton.addEventListener('click', () => {
          const selectElement = document.getElementById('saveFileSelect');
          const selectedIndex = selectElement ? parseInt(selectElement.value, 10) : -1;
          if (dialog.parentNode === document.body) {
        document.body.removeChild(dialog);
      }
      if (overlay.parentNode === document.body) {
        document.body.removeChild(overlay);
      }
          resolve({ confirmed: true, selectedIndex });
        });

// 添加键盘事件
        dialog.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            cancelButton.click();
          } else if (event.key === 'Enter') {
            confirmButton.click();
          }
        });

// 组装对话框
        buttonContainer.appendChild(cancelButton);
        buttonContainer.appendChild(confirmButton);
        dialog.appendChild(dialogTitle);
        dialog.appendChild(contentContainer);
        dialog.appendChild(buttonContainer);

// 添加到页面
        document.body.appendChild(overlay);
        document.body.appendChild(dialog);

// 聚焦到确认按钮
        confirmButton.focus();
      });
    }

// 从本地存储加载游戏进度
    function loadGameProgress() {
      try {
        const savedGameData = localStorage.getItem('beggarSurvivalGameSave');

if (!savedGameData) {
          console.log('没有找到保存的游戏进度');
          showNotification('未找到存档', '没有检测到已保存的游戏进度');
          return false;
        }

const parsedData = JSON.parse(savedGameData);

// 验证数据有效性
        if (!parsedData.day || !parsedData.resources || !parsedData.status) {
          throw new Error('保存的数据格式无效');
        }

        // 创建当前资源定义的深拷贝，以保留新添加的物品
        const masterResources = JSON.parse(JSON.stringify(gameData.resources));
        const savedResources = parsedData.resources;

        // 使用存档中的数量更新主资源列表
        for (const resourceId in masterResources) {
          if (savedResources && savedResources.hasOwnProperty(resourceId)) {
            masterResources[resourceId].amount = savedResources[resourceId].amount;
          }
        }

        // 用存档数据覆盖整个gameData
        Object.keys(gameData).forEach(key => {
          if (key !== 'uiState' && key !== 'tempData') {
            delete gameData[key];
          }
        });
        Object.assign(gameData, parsedData);

        // 将合并后的、最新的资源列表重新赋值给gameData
        gameData.resources = masterResources;

console.log('游戏进度已加载');
        showNotification('加载成功', '游戏进度已成功加载');

// 根据当前天数重新计算季节（修复存档中季节值可能不正确的问题）
        gameData.season = calculateSeason(gameData.day);

// 更新UI以反映加载的游戏状态
        updateGameData();
        renderResources();
        renderLocations();
        renderActions();
        renderEquipmentSlots();

return true;
      } catch (error) {
        console.error('加载游戏进度失败:', error);
        showNotification('加载失败', '无法加载游戏进度，存档可能已损坏');
        return false;
      }
    }

// 更新游戏数据
    function updateGameData() {
      // 确保gameData和相关属性存在
      if (!gameData || !gameData.status || !gameData.stats) {
        debugLog('updateGameData: gameData或其子属性不存在');
        return;
      }

      // 更新天数（带空值检查）
      if (elements.dayNumber && elements.dayNumber.textContent !== undefined) {
        elements.dayNumber.textContent = gameData.day;
      } else {
        debugLog('updateGameData: dayNumber元素不存在');
      }

// 更新时间段（带空值检查）
      const timeOfDayMap = {
        early_morning: '清晨',
        morning: '上午',
        afternoon: '下午',
        evening: '傍晚',
        night: '夜晚'
      };
      if (elements.timeOfDay && elements.timeOfDay.textContent !== undefined) {
        elements.timeOfDay.textContent = timeOfDayMap[gameData.timeOfDay] || '未知时间段';
      } else {
        debugLog('updateGameData: timeOfDay元素不存在');
      }

// 更新状态百分比显示（带空值检查）
      const statusUpdateMap = [
        { element: elements.hungerPercentage, value: `${gameData.status.hunger}%`, name: 'hungerPercentage' },
        { element: elements.coldPercentage, value: `${gameData.status.cold.toFixed(1)}℃`, name: 'coldPercentage' },
        { element: elements.healthPercentage, value: `${gameData.status.health}%`, name: 'healthPercentage' },
        { element: elements.bloodPercentage, value: `${gameData.status.blood}%`, name: 'bloodPercentage' },
        { element: elements.spiritPercentage, value: `${gameData.status.spirit}%`, name: 'spiritPercentage' },
        { element: elements.reputationPercentage, value: `${gameData.status.reputation}%`, name: 'reputationPercentage' },
        { element: elements.thirstPercentage, value: `${gameData.status.thirst}%`, name: 'thirstPercentage' },
        { element: elements.actionPointsValue, value: `(行动点 ${gameData.status.actionPoints}/20)`, name: 'actionPointsValue' }
      ];

      statusUpdateMap.forEach(({ element, value, name }) => {
        if (element && element.textContent !== undefined) {
          element.textContent = value;
        } else {
          debugLog(`updateGameData: ${name}元素不存在`);
        }
      });

// 更新季节（带空值检查）
      const seasons = {
        spring: { icon: '🌱', name: '春季' },
        summer: { icon: '☀️', name: '夏季' },
        autumn: { icon: '🍂', name: '秋季' },
        winter: { icon: '❄️', name: '冬季' }
      };

      const currentSeason = seasons[gameData.season] || { icon: '❓', name: '未知季节' };
      
      if (elements.seasonIcon && elements.seasonIcon.textContent !== undefined) {
        elements.seasonIcon.textContent = currentSeason.icon;
      } else {
        debugLog('updateGameData: seasonIcon元素不存在');
      }
      
      if (elements.seasonName && elements.seasonName.textContent !== undefined) {
        elements.seasonName.textContent = currentSeason.name;
      } else {
        debugLog('updateGameData: seasonName元素不存在');
      }

// 更新天气（带空值检查）
      const weathers = {
        sunny: { icon: '☀️', name: '晴天' },
        rainy: { icon: '🌧️', name: '雨天' },
        snowy: { icon: '❄️', name: '雪天' }
      };

      const currentWeather = weathers[gameData.weather] || { icon: '❓', name: '未知天气' };
      
      if (elements.weatherIcon && elements.weatherIcon.textContent !== undefined) {
        elements.weatherIcon.textContent = currentWeather.icon;
      } else {
        debugLog('updateGameData: weatherIcon元素不存在');
      }
      
      if (elements.weatherName && elements.weatherName.textContent !== undefined) {
        elements.weatherName.textContent = currentWeather.name;
      } else {
        debugLog('updateGameData: weatherName元素不存在');
      }

// 更新进度条（带空值检查）
      const progressBarUpdateMap = [
        { element: elements.hungerBar, width: `${gameData.status.hunger}%`, name: 'hungerBar', cardName: 'hungerCard' },
        // 体温范围34-42，转换为0-100%进度条宽度
        { element: elements.coldBar, width: `${((gameData.status.cold - 34) / 8) * 100}%`, name: 'coldBar', cardName: 'coldCard' },
        { element: elements.healthBar, width: `${gameData.status.health}%`, name: 'healthBar', cardName: 'healthCard' },
        { element: elements.bloodBar, width: `${gameData.status.blood}%`, name: 'bloodBar', cardName: 'bloodCard' },
        { element: elements.spiritBar, width: `${gameData.status.spirit}%`, name: 'spiritBar', cardName: 'spiritCard' },
        { element: elements.reputationBar, width: `${gameData.status.reputation}%`, name: 'reputationBar', cardName: 'reputationCard' },
        { element: elements.thirstBar, width: `${gameData.status.thirst}%`, name: 'thirstBar', cardName: 'thirstCard' }
      ];

      progressBarUpdateMap.forEach(({ element, width, name, cardName }) => {
        if (element && element.style && element.style.width !== undefined) {
          element.style.width = width;
          
          // 设置进度条颜色
          let color = '#48BB78'; // 默认绿色
          let isWarning = false; // 是否触发警告
          
          switch(name) {
            case 'coldBar':
              if (gameData.status.cold >= 40) {
                color = '#E53E3E'; // 体温过高，红色警告
                isWarning = true;
              } else if (gameData.status.cold < 35) {
                color = '#3182CE'; // 体温过低，蓝色警告
                isWarning = true;
              } else {
                color = '#48BB78'; // 正常体温，绿色
              }
              break;
            case 'hungerBar':
              if (gameData.status.hunger < 50) {
                color = '#E53E3E'; // 饱食度过低，红色警告
                isWarning = true;
              }
              break;
            case 'healthBar':
              if (gameData.status.health < 50) {
                color = '#E53E3E'; // 健康度过低，红色警告
                isWarning = true;
              }
              break;
            case 'bloodBar':
              if (gameData.status.blood < 50) {
                color = '#E53E3E'; // 血量过低，红色警告
                isWarning = true;
              }
              break;
            case 'spiritBar':
              if (gameData.status.spirit < 50) {
                color = '#E53E3E'; // 精神度过低，红色警告
                isWarning = true;
              }
              break;
            case 'thirstBar':
              if (gameData.status.thirst < 50) {
                color = '#E53E3E'; // 水分过低，红色警告
                isWarning = true;
              } else {
                color = '#48BB78'; // 水分充足，绿色
              }
              break;
          }
          
          element.style.backgroundColor = color;
          
          // 根据警告状态设置边框和阴影
          if (isWarning) {
            element.style.border = '2px solid #E53E3E';
            element.style.boxShadow = '0 0 10px rgba(229, 62, 62, 0.7)';
            // 如果有对应的状态框，也设置警告样式
            if (cardName && elements[cardName]) {
              const cardElement = elements[cardName];
              cardElement.style.border = '2px solid #E53E3E';
              cardElement.style.boxShadow = '0 0 15px rgba(229, 62, 62, 0.8)';
              cardElement.style.animation = 'pulse 1.5s infinite';
            }
          } else {
            element.style.border = 'none';
            element.style.boxShadow = 'none';
            // 如果有对应的状态框，也移除警告样式
            if (cardName && elements[cardName]) {
              const cardElement = elements[cardName];
              cardElement.style.border = '';
              cardElement.style.boxShadow = '';
              cardElement.style.animation = '';
            }
          }
        } else {
          debugLog(`updateGameData: ${name}元素不存在`);
        }
      });

// 更新统计数据
      gameData.stats.daysSurvived = gameData.day - 1;
      gameData.stats.maxReputation = Math.max(gameData.stats.maxReputation, gameData.status.reputation);
      
      // 检查游戏是否失败
      checkGameOver();
    }

// 生成天气函数
    function generateWeather() {
      // 初始化季节天气统计数据
      if (!gameData.seasonWeatherStats) {
        gameData.seasonWeatherStats = {
          spring: { rainyDays: 0, totalDays: 0 },
          summer: { rainyDays: 0, totalDays: 0 },
          autumn: { rainyDays: 0, totalDays: 0 },
          winter: { snowyDays: 0, totalDays: 0 }
        };
      }

      const currentSeason = gameData.season;
      
      // 确保当前季节的统计数据存在
      if (!gameData.seasonWeatherStats[currentSeason]) {
        gameData.seasonWeatherStats[currentSeason] = { rainyDays: 0, totalDays: 0, snowyDays: 0 };
      }
      
      // 增加当前季节的总天数计数
      gameData.seasonWeatherStats[currentSeason].totalDays++;
      
      let weather;

      // 根据季节设置天气概率
      switch (currentSeason) {
        case 'spring':
          // 春季：10%几率下雨，确保至少有1天雨天
          if (gameData.seasonWeatherStats.spring.rainyDays < 1 && gameData.day % 7 === 0) {
            weather = 'rainy'; // 每周强制下雨一次
          } else {
            weather = Math.random() < 0.1 ? 'rainy' : 'sunny';
          }
          break;
        case 'summer':
          // 夏季：20%几率下雨，确保至少有2天雨天
          if (gameData.seasonWeatherStats.summer.rainyDays < 2 && gameData.day % 5 === 0) {
            weather = 'rainy'; // 每5天强制下雨一次
          } else {
            weather = Math.random() < 0.2 ? 'rainy' : 'sunny';
          }
          break;
        case 'autumn':
          // 秋季：15%几率下雨，确保至少有1天雨天
          if (gameData.seasonWeatherStats.autumn.rainyDays < 1 && gameData.day % 6 === 0) {
            weather = 'rainy'; // 每6天强制下雨一次
          } else {
            weather = Math.random() < 0.15 ? 'rainy' : 'sunny';
          }
          break;
        case 'winter':
          // 冬季：30%几率下雪，确保至少有2天雪天
          if (gameData.seasonWeatherStats.winter.snowyDays < 2 && gameData.day % 4 === 0) {
            weather = 'snowy'; // 每4天强制下雪一次
          } else {
            weather = Math.random() < 0.3 ? 'snowy' : 'sunny';
          }
          break;
        default:
          weather = 'sunny';
      }

      // 更新天气统计
      if (weather === 'rainy') {
        gameData.seasonWeatherStats[currentSeason].rainyDays++;
      } else if (weather === 'snowy') {
        gameData.seasonWeatherStats[currentSeason].snowyDays++;
      }

      // 设置天气
      gameData.weather = weather;
      applyWeatherEffects();
      updateWeatherEffects(); // 更新天气动画效果
      updateGameData(); // 更新UI显示
    }

// 应用天气效果函数
    function applyWeatherEffects() {
      // 只在没有"全身湿透"BUFF时，根据天气条件添加
      // "全身湿透"BUFF一旦获得，只能通过篝火消除
      if (!gameData.buffs['全身湿透']) {
        if (gameData.weather === 'rainy' || gameData.weather === 'snowy') {
          gameData.buffs['全身湿透'] = { active: true };
        }
      }
      
      // 确保UI更新，显示当前天气状态
      const weatherIcon = document.getElementById('weatherIcon');
      const weatherName = document.getElementById('weatherName');
      
      if (weatherIcon && weatherName) {
        const weatherDisplayNames = {
          'sunny': { icon: '☀️', name: '晴天' },
          'rainy': { icon: '🌧️', name: '雨天' },
          'snowy': { icon: '❄️', name: '雪天' }
        };
        
        weatherIcon.textContent = weatherDisplayNames[gameData.weather]?.icon || '☀️';
        weatherName.textContent = weatherDisplayNames[gameData.weather]?.name || '晴天';
      }
    }

    // 天气效果动画系统
    let weatherAnimationInterval = null;
    let weatherParticles = [];
    
    // 创建雨滴函数
    function createRaindrop() {
      const raindrop = document.createElement('div');
      raindrop.className = 'raindrop';
      
      // 增加雨滴大小
      const width = Math.random() * 2 + 2; // 2-4px
      const height = Math.random() * 15 + 15; // 15-30px
      
      raindrop.style.width = width + 'px';
      raindrop.style.height = height + 'px';
      raindrop.style.left = Math.random() * 100 + '%';
      raindrop.style.animationDuration = (Math.random() * 2 + 1) + 's';
      raindrop.style.animationDelay = Math.random() * 2 + 's';
      
      // 添加雨滴落地事件监听
      raindrop.addEventListener('animationend', function() {
        // 创建晕圈效果
        createRipple(parseFloat(this.style.left));
        // 移除雨滴
        this.remove();
        // 从粒子数组中移除
        const index = weatherParticles.indexOf(this);
        if (index > -1) {
          weatherParticles.splice(index, 1);
        }
      });
      
      return raindrop;
    }
    
    // 创建晕圈效果函数
    function createRipple(xPosition) {
      const ripple = document.createElement('div');
      ripple.className = 'ripple';
      
      const size = Math.random() * 20 + 10; // 10-30px
      ripple.style.width = size + 'px';
      ripple.style.height = size + 'px';
      ripple.style.left = xPosition + '%';
      ripple.style.top = '95%'; // 接近底部
      
      const container = document.getElementById('weatherEffectsContainer');
      container.appendChild(ripple);
      
      // 动画结束后移除晕圈
      setTimeout(function() {
        ripple.remove();
      }, 1000);
    }
    
    // 清除天气效果函数
    function clearWeatherEffects() {
      if (weatherAnimationInterval) {
        clearInterval(weatherAnimationInterval);
        weatherAnimationInterval = null;
      }
      
      // 移除所有粒子
      weatherParticles.forEach(particle => {
        if (particle.parentNode) {
          particle.parentNode.removeChild(particle);
        }
      });
      weatherParticles = [];
    }
    
    // 启动下雨效果
    function startRainEffect() {
      const container = document.getElementById('weatherEffectsContainer');
      
      // 创建初始雨滴
      for (let i = 0; i < 50; i++) {
        const raindrop = createRaindrop();
        container.appendChild(raindrop);
        weatherParticles.push(raindrop);
      }
      
      // 定期创建新雨滴以维持效果
      weatherAnimationInterval = setInterval(function() {
        if (weatherParticles.length < 80) {
          const raindrop = createRaindrop();
          container.appendChild(raindrop);
          weatherParticles.push(raindrop);
        }
      }, 100);
    }
    
    // 更新天气效果函数
    function updateWeatherEffects() {
      // 清除之前的天气效果
      clearWeatherEffects();
      
      // 根据当前天气类型启动相应的效果
      if (gameData.weather === 'rainy') {
        startRainEffect();
        document.body.classList.add('weather-rainy');
      } else {
        document.body.classList.remove('weather-rainy');
      }
    }

// 烤火函数
    function warmByFire() {
      // 检查是否需要烤火：体温低于36℃ 或者 处于全身湿透状态
      if (gameData.status.cold >= 36 && !gameData.buffs['全身湿透']) {
        showNotification('烤火', '你不需要烤火，因为你的体温正常且没有全身湿透。');
        return;
      }

      // 移除全身湿透BUFF
      if (gameData.buffs['全身湿透']) {
        delete gameData.buffs['全身湿透'];
      }

      // 增加体温：只要体温低于36℃，就增加1℃
      if (gameData.status.cold < 36) {
        gameData.status.cold = Math.min(36, gameData.status.cold + 1); // 体温最多到36℃
      }

      // 更新UI
      updateGameData();

      // 显示通知
      let notificationTitle = '烤火成功';
      let notificationText = '';

      if (gameData.status.cold < 36) {
        if (gameData.buffs['全身湿透']) {
          notificationText = '你的体温上升了1℃！';
        } else {
          notificationText = '你烤火去除了全身湿透的状态，体温上升了1℃！';
        }
      } else {
        if (gameData.buffs['全身湿透']) {
          notificationText = '你的体温已恢复正常！';
        } else {
          notificationText = '你烤火去除了全身湿透的状态！';
        }
      }

      showNotification(notificationTitle, notificationText);
    }

// 检查篝火保暖函数
    function checkCampfireWarmth() {
      // 只有在夜晚且不是夏季时需要篝火保暖
      if (gameData.timeOfDay === 'night' && gameData.season !== 'summer') {
        // 检查背包中是否有篝火卡牌
        const hasCampfire = gameData.resources['fire'] && gameData.resources['fire'].amount > 0;
        return hasCampfire;
      }
      return true; // 其他情况不需要篝火
    }

// 处理BUFF效果函数
    function processBuffs() {
      Object.keys(gameData.buffs).forEach(buff => {
        switch (buff) {
          case '全身湿透':
            // 全身湿透：每个时间段体温下降0.1℃
            gameData.status.cold -= 0.1;
            break;
        }
      });

      // 处理夜晚降温
      if (gameData.timeOfDay === 'night' && gameData.season !== '夏天') {
        const hasCampfire = gameData.resources['fire'] && gameData.resources['fire'].amount > 0;
        if (!hasCampfire) {
          // 夜晚没有篝火：体温每个回合下降0.1℃
          gameData.status.cold -= 0.1;
        }
      }

      // 确保体温在合理范围内
      gameData.status.cold = Math.max(34, Math.min(42, gameData.status.cold));
    }

// 更新单个资源卡牌的显示
    function updateResourceCard(resourceId) {
      const resource = gameData.resources[resourceId];

// 如果资源数量为0，检查是否可以丢弃
      if (resource.amount <= 0) {
        // 特殊学习物品(type: 'learnable')即使标记为不可丢弃，使用后也应移除
        // 其他不可丢弃物品(cannotDrop)即使数量为0也不移除卡牌
        if (resource.type !== 'learnable' && resource.cannotDrop) {
          // 继续执行后续代码以更新卡牌显示为数量0
        } else {
          // 可丢弃物品和学习物品数量为0时移除卡牌
          const card = document.querySelector(`.resource-card[data-resource="${resourceId}"]`);
          if (card) {
            card.remove();
          }
          return;
        }
      }

// 查找现有的卡牌
      let card = document.querySelector(`.resource-card[data-resource="${resourceId}"]`);

// 如果卡牌不存在，创建新的
      if (!card) {
        card = document.createElement('div');
        card.className = 'card resource resource-card';
        card.setAttribute('draggable', 'true');
        card.setAttribute('data-resource', resourceId);
        elements.resourceGrid.appendChild(card);
      }

// 更新卡牌内容
      card.innerHTML = `
        <div class="card-image" style="background-image: url('${resource.image}'); background-size: cover; background-position: center; position: relative; display: flex;">
            <!-- 图片加载失败时的备用显示 -->
            <div class="image-fallback" style="display: flex; width: 100%; height: 100%; background-color: #E2E8F0; align-items: center; justify-content: center; color: #718096; font-size: 12px; z-index: 1;">图片</div>
          ${resource.equipped ? `
            <div class="equipped-badge" style="position: absolute; top: 0.25rem; right: 0.25rem; background-color: #805AD5; color: white; border-radius: 50%; width: 1.5rem; height: 1.5rem; display: flex; align-items: center; justify-content: center; font-size: 0.75rem; font-weight: bold;">
              已穿
            </div>
          ` : ''}
          ${resourceId === 'fire' ? `
            <div class="fuel-indicator" style="position: absolute; top: 0.25rem; left: 0.25rem; background-color: rgba(220, 38, 38, 0.9); color: white; border-radius: 0.25rem; padding: 0.25rem 0.5rem; font-size: 0.9rem; font-weight: bold;">
              ${resource.fuel || 0}%
            </div>
          ` : ''}
        </div>
        <div class="card-content">
          <div class="card-title">${resource.name}x${resource.amount}</div>
          ${resource.durability !== undefined ? `
            <div class="card-durability" style="margin-top: 0.25rem;">
              <div class="durability-bar-container" style="height: 4px; background-color: #E2E8F0; border-radius: 2px; overflow: hidden;">
                <div class="durability-bar" style="height: 100%; width: ${resource.durability}%; background-color: ${resource.durability > 50 ? '#38A169' : resource.durability > 20 ? '#D69E2E' : '#E53E3E'};"></div>
              </div>
              <div class="durability-text" style="font-size: 0.75rem; text-align: right; margin-top: 0.125rem;">${resource.durability}%</div>
            </div>
          ` : ''}
        </div>
      `;

// 为水袋（满）添加点击事件监听器
      if (resourceId === 'water_bag') {
        card.addEventListener('click', function() {
          showWaterBagConfirmWindow(resourceId);
        });
      } else if (resourceId === 'dirty_water_bowl' || resourceId === 'clean_water_bowl') {
        // 保留原有的水碗点击逻辑
        card.addEventListener('click', function() {
          handleResourceClick(resourceId);
        });
      } else if (resourceId === 'fire') {
        // 为篝火卡牌添加点击事件监听器
        card.addEventListener('click', function() {
          handleResourceClick(resourceId);
        });
      }
    }

    // 显示水袋饮用确认弹窗
    function showWaterBagConfirmWindow(resourceId) {
      const resource = gameData.resources[resourceId];

if (!resource || resource.amount <= 0) return;

// 创建模态窗口容器
      const modalContainer = document.createElement('div');
      modalContainer.className = 'modal-overlay';
      modalContainer.style.position = 'fixed';
      modalContainer.style.top = '0';
      modalContainer.style.left = '0';
      modalContainer.style.width = '100%';
      modalContainer.style.height = '100%';
      modalContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
      modalContainer.style.display = 'flex';
      modalContainer.style.alignItems = 'center';
      modalContainer.style.justifyContent = 'center';
      modalContainer.style.zIndex = '1000';

// 创建模态窗口内容
      const modalContent = document.createElement('div');
      modalContent.className = 'modal-content';
      modalContent.style.backgroundColor = 'white';
      modalContent.style.borderRadius = '8px';
      modalContent.style.padding = '1.5rem';
      modalContent.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
      modalContent.style.maxWidth = '300px';
      modalContent.style.width = '100%';

// 添加标题
      const title = document.createElement('h3');
      title.textContent = '确认饮用';
      title.style.marginTop = '0';
      title.style.marginBottom = '1rem';
      title.style.fontSize = '1.25rem';
      title.style.fontWeight = 'bold';
      title.style.color = '#1A202C';
      modalContent.appendChild(title);

// 添加内容
      const content = document.createElement('p');
      content.textContent = '你确定要饮用这个水袋里的水吗？饮用后水袋会变成空的，但可以再次装满。';
      content.style.marginBottom = '1.5rem';
      content.style.color = '#4A5568';
      modalContent.appendChild(content);

// 创建按钮容器
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.justifyContent = 'flex-end';
      buttonContainer.style.gap = '0.75rem';
      modalContent.appendChild(buttonContainer);

// 创建取消按钮
      const cancelButton = document.createElement('button');
      cancelButton.textContent = '取消';
      cancelButton.className = 'ink-button ink-button-secondary ink-button-small';
      cancelButton.style.marginRight = '0.5rem';

cancelButton.addEventListener('click', function() {
        if (modalContainer.parentNode === document.body) {
        if (modalContainer.parentNode === document.body) {
        document.body.removeChild(modalContainer);
      }
      }
      });

buttonContainer.appendChild(cancelButton);

// 创建确认按钮
      const confirmButton = document.createElement('button');
      confirmButton.textContent = '确定';
      confirmButton.className = 'ink-button ink-button-primary ink-button-small';

confirmButton.addEventListener('click', function() {
        document.body.removeChild(modalContainer);
        drinkWaterBag();
      });

buttonContainer.appendChild(confirmButton);

// 添加模态窗口到文档
      modalContainer.appendChild(modalContent);
      document.body.appendChild(modalContainer);
    }



// 饮用满水袋
    function drinkWaterBag() {
      const waterBag = gameData.resources['water_bag'];
      const emptyWaterBag = gameData.resources['empty_water_bag'];

if (!waterBag || waterBag.amount <= 0) {
        showNotification('错误', '你没有可以饮用的水袋。');
        return;
      }

// 减少满水袋数量
      waterBag.amount--;

// 增加空水袋数量
      emptyWaterBag.amount++;

// 补充水分50点
      gameData.status.thirst = Math.min(100, gameData.status.thirst + 50); // 增加50点水分值

// 显示通知
      showNotification('饮用了水袋里的水', '你喝了水袋里的水，水分得到了补充。水袋变成了空的。');

// 更新UI和游戏数据
      updateResourceCard('water_bag');
      updateResourceCard('empty_water_bag');
      updateGameData();
    }

// 全局变量用于跟踪当前分类
    let currentCategory = 'all';

// 添加缺失的分类属性的函数
    function ensureResourceCategories() {
        for (const [id, resource] of Object.entries(gameData.resources)) {
            if (!resource.category) {
                // 默认分类为材料
                gameData.resources[id].category = 'material';
            }
        }
    }

    // 图钉功能：切换卡牌的固定状态
    function togglePinResource(resourceId) {
        const resource = gameData.resources[resourceId];
        if (!resource) return;
        
        // 初始化固定状态
        if (resource.pinned === undefined) {
            resource.pinned = false;
        }
        
        // 切换固定状态
        resource.pinned = !resource.pinned;
        
        console.log(`图钉功能: 资源 ${resourceId} (${resource.name}) 固定状态切换为: ${resource.pinned}`);
        
        // 更新当前卡牌的UI状态，而不是重新渲染整个网格
        updateCardPinState(resourceId, resource.pinned);
        
        // 保存状态到localStorage
        savePinnedState();
        
        // 显示通知
        const action = resource.pinned ? '固定' : '取消固定';
        showNotification('卡牌状态', `卡牌 ${resource.name} 已被${action}`);
    }

    // 更新单个卡牌的固定状态
    function updateCardPinState(resourceId, pinned) {
        const card = document.querySelector(`.resource-card[data-resource="${resourceId}"]`);
        if (card) {
            if (pinned) {
                card.classList.add('pinned');
                card.setAttribute('draggable', 'false');
            } else {
                card.classList.remove('pinned');
                card.setAttribute('draggable', 'true');
            }
            
            // 更新图钉按钮的样式
            const pinButton = card.querySelector('.pin-button');
            if (pinButton) {
                if (pinned) {
                    pinButton.style.backgroundColor = '#38A169';
                    pinButton.classList.add('pinned');
                } else {
                    pinButton.style.backgroundColor = '#CBD5E0';
                    pinButton.classList.remove('pinned');
                }
            }
        }
    }

    // 保存固定状态到localStorage
    function savePinnedState() {
        const pinnedState = {};
        Object.keys(gameData.resources).forEach(resourceId => {
            // 篝火不能被固定，不保存其状态
            if (resourceId === 'fire') return;
            
            const resource = gameData.resources[resourceId];
            if (resource.pinned !== undefined) {
                pinnedState[resourceId] = resource.pinned;
            }
        });
        localStorage.setItem('pinnedResources', JSON.stringify(pinnedState));
    }

    // 加载固定状态
    function loadPinnedState() {
        const savedState = localStorage.getItem('pinnedResources');
        if (!savedState) return;
        
        const pinnedState = JSON.parse(savedState);
        Object.keys(pinnedState).forEach(resourceId => {
            if (gameData.resources[resourceId]) {
                // 篝火不能被固定，跳过篝火的固定状态
                if (resourceId !== 'fire') {
                    gameData.resources[resourceId].pinned = pinnedState[resourceId];
                }
            }
        });
    }

// 渲染资源
    function renderResources() {
      // 确保所有资源都有分类
      ensureResourceCategories();

// 保存当前卡牌的位置顺序
      const resourceGrid = elements.resourceGrid;
      const currentOrder = [];
      const existingCards = resourceGrid.querySelectorAll('.resource-card');
      existingCards.forEach(card => {
        const resourceId = card.getAttribute('data-resource');
        if (resourceId) {
          currentOrder.push(resourceId);
        }
      });

elements.resourceGrid.innerHTML = '';

// 筛选资源 - 只显示数量大于0的资源
      let filteredResources = [];
      for (const [id, resource] of Object.entries(gameData.resources)) {
        // 只显示数量大于0的资源，并且符合当前选中的分类
        if ((currentCategory === 'all' || resource.category === currentCategory) && resource.amount > 0) {
            filteredResources.push({ id, resource });
        }
      }

      // 如果有保存的位置顺序，按照保存的顺序重新排序
      if (currentOrder.length > 0) {
        filteredResources.sort((a, b) => {
          const indexA = currentOrder.indexOf(a.id);
          const indexB = currentOrder.indexOf(b.id);
          
          // 如果两个都在当前顺序中，按保存的顺序排序
          if (indexA !== -1 && indexB !== -1) {
            return indexA - indexB;
          }
          // 如果只有a在当前顺序中，a排在前面
          if (indexA !== -1) {
            return -1;
          }
          // 如果只有b在当前顺序中，b排在前面
          if (indexB !== -1) {
            return 1;
          }
          // 如果都不在当前顺序中，保持原顺序
          return 0;
        });
      }

// 更新分类标签样式
      document.querySelectorAll('.inventory-tab').forEach(tab => {
          // 移除所有可能的背景色类和强调样式
          tab.classList.remove('bg-purple-600', 'bg-green-600', 'bg-blue-600', 'bg-yellow-600', 'bg-gray-100', 'text-white', 'text-gray-600', 'border-purple-700', 'border-green-700', 'border-blue-700', 'border-yellow-700');

// 重置内联样式
          tab.style.borderWidth = '';
          tab.style.fontWeight = '';
          tab.style.boxShadow = '';
          tab.style.transform = '';
          tab.style.backgroundColor = '';
          tab.style.color = '';

if (tab.dataset.category === currentCategory) {
              tab.classList.add('active');
              // 选中的标签使用紫色背景和白色加粗文字
              tab.classList.add('bg-purple-600', 'text-white', 'border-purple-700');
              // 添加强调效果，使用!important确保覆盖内联样式
              tab.style.setProperty('border-width', '2px', 'important');
              tab.style.setProperty('font-weight', 'bold', 'important');
              tab.style.setProperty('box-shadow', '0 2px 4px rgba(0, 0, 0, 0.2)', 'important');
              tab.style.setProperty('transform', 'translateY(-1px) scale(1.05)', 'important');
              tab.style.setProperty('background-color', '#805AD5', 'important');
              tab.style.setProperty('color', 'white', 'important');
              tab.style.transition = 'all 0.2s ease';
          } else {
              tab.classList.remove('active');
              // 未选中的标签使用背景色作为字体颜色，字体不加粗
              tab.style.setProperty('background-color', '#F7FAFC', 'important');
              tab.style.setProperty('color', '#F7FAFC', 'important');
              tab.style.setProperty('font-weight', 'normal', 'important');
              tab.classList.add('text-gray-600');
          }
      });

// 显示所有筛选后的资源
      for (const { id, resource } of filteredResources) {
        // 初始化固定状态
        if (resource.pinned === undefined) {
          resource.pinned = false;
        }
        
        const resourceCard = document.createElement('div');
      resourceCard.className = `card resource resource-card ${resource.pinned ? 'pinned' : ''}`;
      resourceCard.setAttribute('draggable', 'true');
      resourceCard.setAttribute('data-resource', id);

resourceCard.innerHTML = `
          <div class="card-image" style="background-image: url('${resource.image}'); background-size: cover; background-position: center; position: relative; min-height: 100px; display: flex;">
            <!-- 图片加载失败时的备用显示 -->
            <div class="image-fallback" style="display: flex; width: 100%; height: 100%; background-color: #E2E8F0; align-items: center; justify-content: center; color: #718096; font-size: 12px; z-index: 1;">图片</div>
            <!-- 图钉按钮 -->
            <div class="pin-button ${resource.pinned ? 'pinned' : ''}" style="position: absolute; top: 0.25rem; right: 0.25rem; background-color: ${resource.pinned ? '#38A169' : '#CBD5E0'}; color: white; border-radius: 50%; width: 1.5rem; height: 1.5rem; display: flex; align-items: center; justify-content: center; font-size: 0.75rem; cursor: pointer; z-index: 100; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3); pointer-events: auto; transition: all 0.2s ease; user-select: none;">
              📌
            </div>
            ${resource.equipped ? `
              <div class="equipped-badge" style="position: absolute; bottom: 0.25rem; right: 0.25rem; background-color: #38A169; color: white; border-radius: 4px; padding: 0.1rem 0.3rem; font-size: 0.6rem; font-weight: normal; font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2); z-index: 10;">
                已穿戴
              </div>
            ` : ''}
            ${id === 'fire' ? `
              <div class="fuel-indicator" style="position: absolute; top: 0.25rem; left: 0.25rem; background-color: rgba(220, 38, 38, 0.9); color: white; border-radius: 0.25rem; padding: 0.25rem 0.5rem; font-size: 0.9rem; font-weight: bold;">
                ${resource.fuel || 0}%
              </div>
            ` : ''}
          </div>
          <div class="card-content">
            <div class="card-title">${resource.name}x${resource.amount}</div>
            ${resource.durability !== undefined ? `
              <div class="card-durability" style="margin-top: 0.25rem;">
                <div class="durability-bar-container" style="height: 4px; background-color: #E2E8F0; border-radius: 2px; overflow: hidden;">
                  <div class="durability-bar" style="height: 100%; width: ${resource.durability}%; background-color: ${resource.durability > 50 ? '#38A169' : resource.durability > 20 ? '#D69E2E' : '#E53E3E'};"></div>
                </div>
                <div class="durability-text" style="font-size: 0.75rem; text-align: right; margin-top: 0.125rem;">${resource.durability}%</div>
              </div>
            ` : ''}
          </div>
        `;

elements.resourceGrid.appendChild(resourceCard);

        // 添加图钉按钮点击事件
        const pinButton = resourceCard.querySelector('.pin-button');
        if (pinButton) {
          pinButton.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation(); // 阻止事件冒泡到卡牌点击事件
            e.stopImmediatePropagation(); // 阻止其他事件处理程序
            console.log('图钉按钮被点击，资源ID:', id);
            togglePinResource(id);
            return false; // 防止默认行为和事件冒泡
          }, true); // 使用捕获阶段确保最先处理
        }

// 完全重写的图片加载机制，修复异步问题和添加更多容错
        const imgUrl = resource.image;
        const img = new Image();

// 立即设置初始图片路径（不再等待加载成功）
        const cardImage = resourceCard.querySelector('.card-image');
        const fallback = resourceCard.querySelector('.image-fallback');

// 直接设置背景图片，这样即使加载失败，后续代码仍会尝试修复
        cardImage.style.backgroundImage = `url('${imgUrl}')`;

// 为水袋（满）卡牌添加点击事件监听器
        if (id === 'water_bag') {
          resourceCard.addEventListener('click', function() {
            showWaterBagConfirmWindow(id);
          });
        }
        
        // 为篝火卡牌添加拖放事件监听器
        if (id === 'fire') {
          // 添加拖放事件监听器
          resourceCard.addEventListener('dragover', function(e) {
            e.preventDefault();
            // 检查拖拽的物品是否为生食或木棍
            const draggedId = e.dataTransfer.getData('text/plain');
            if (canCookWithFire(draggedId) || draggedId === 'stick') {
              resourceCard.style.boxShadow = '0 0 15px rgba(128, 90, 213, 0.8)';
              resourceCard.style.transform = 'scale(1.05)';
            }
          });
          
          resourceCard.addEventListener('dragleave', function(e) {
            resourceCard.style.boxShadow = '';
            resourceCard.style.transform = '';
          });
          
          resourceCard.addEventListener('drop', function(e) {
            e.preventDefault();
            resourceCard.style.boxShadow = '';
            resourceCard.style.transform = '';
            
            const draggedId = e.dataTransfer.getData('text/plain');
            if (canCookWithFire(draggedId)) {
              cookWithFire(draggedId);
            } else if (draggedId === 'stick') {
              // 添加燃料功能
              addFuelToFire();
            }
          });
        }
        
        // 为熄灭的篝火卡牌添加拖放事件监听器
        if (id === 'fire_extinguished') {
          // 添加拖放事件监听器
          resourceCard.addEventListener('dragover', function(e) {
            e.preventDefault();
            // 检查拖拽的物品是否为燧石
            const draggedId = e.dataTransfer.getData('text/plain');
            if (draggedId === 'flint') {
              resourceCard.style.boxShadow = '0 0 15px rgba(255, 128, 0, 0.8)';
              resourceCard.style.transform = 'scale(1.05)';
            }
          });
          
          resourceCard.addEventListener('dragleave', function(e) {
            resourceCard.style.boxShadow = '';
            resourceCard.style.transform = '';
          });
          
          resourceCard.addEventListener('drop', function(e) {
            e.preventDefault();
            resourceCard.style.boxShadow = '';
            resourceCard.style.transform = '';
            
            const draggedId = e.dataTransfer.getData('text/plain');
            if (draggedId === 'flint') {
              // 点燃篝火功能
              relightFire();
            }
          });
        }

// 尝试加载图片的函数 - 同步方式
        function tryLoadImageSync(url) {
          return new Promise((resolve) => {
            const testImg = new Image();
            testImg.onload = function() {
              console.log(`成功加载图片: ${url} 为资源: ${resource.name}`);
              cardImage.style.backgroundImage = `url('${url}')`;
              if (fallback) fallback.style.display = 'none';
              resolve(true);
            };
            testImg.onerror = function() {
              console.log(`尝试加载图片失败: ${url}`);
              resolve(false);
            };
            testImg.src = url;
          });
        }

// 处理图片加载失败的函数
        function handleImageLoadFailure() {
          console.log(`资源 ${resource.name} 的原始图片 ${imgUrl} 加载失败，尝试其他路径...`);

// 显示备用内容
          if (fallback) {
            fallback.style.display = 'flex';
          }

// 创建所有可能的路径变体
          const allPossibleUrls = [];

// 1. 获取基础信息
          const hasSlash = imgUrl.includes('/');
          let directory = '';
          let filename = imgUrl;
          let baseName = imgUrl;
          let extension = '';

// 提取目录和文件名
          if (hasSlash) {
            const lastSlashIndex = imgUrl.lastIndexOf('/');
            directory = imgUrl.substring(0, lastSlashIndex);
            filename = imgUrl.substring(lastSlashIndex + 1);
          }

// 提取基础名称和扩展名
          const lastDotIndex = filename.lastIndexOf('.');
          if (lastDotIndex > 0) {
            baseName = filename.substring(0, lastDotIndex);
            extension = filename.substring(lastDotIndex);
          }

// 2. 尝试不同的文件扩展名
          const possibleExtensions = ['.jpg', '.png', '.jpeg', '.gif'];
          possibleExtensions.forEach(ext => {
            if (directory) {
              allPossibleUrls.push(`${directory}/${baseName}${ext}`);
            } else {
              allPossibleUrls.push(`${baseName}${ext}`);
            }
          });

// 3. 大小写变体 - 更全面的实现
          const lowercaseFilename = filename.toLowerCase();
          const uppercaseFilename = filename.toUpperCase();
          const lowercaseDirectory = directory.toLowerCase();
          const uppercaseDirectory = directory.toUpperCase();

// 添加所有可能的大小写组合
          if (directory) {
            allPossibleUrls.push(
              `${directory}/${lowercaseFilename}`,
              `${directory}/${uppercaseFilename}`,
              `${lowercaseDirectory}/${filename}`,
              `${uppercaseDirectory}/${filename}`,
              `${lowercaseDirectory}/${lowercaseFilename}`,
              `${uppercaseDirectory}/${uppercaseFilename}`
            );
          } else {
            allPossibleUrls.push(
              lowercaseFilename,
              uppercaseFilename
            );
          }

// 4. 不带扩展名的文件名
          if (directory) {
            allPossibleUrls.push(`${directory}/${baseName}`);
          } else {
            allPossibleUrls.push(baseName);
          }

// 5. 特殊处理：检查资源名称与文件名的直接对应
          // 特别是针对"黑色斗篷"这样名称与图片文件名不完全匹配的情况
          const resourceName = resource.name;
          allPossibleUrls.push(
            `UI/${resourceName}.jpg`,
            `UI/${resourceName}.png`,
            `UI/${resourceName}`
          );

// 6. 检查"UI高清版本"文件夹中的图片
          if (baseName && directory === 'UI') {
            possibleExtensions.forEach(ext => {
              allPossibleUrls.push(`UI高清版本/${baseName}${ext}`);
              allPossibleUrls.push(`UI高清版本/${resourceName}${ext}`);
            });
            allPossibleUrls.push(`UI高清版本/${baseName}`);
            allPossibleUrls.push(`UI高清版本/${resourceName}`);
          }

// 7. 尝试基础文件名与资源名的各种组合
          // 特别是处理"黑色斗篷"对应"黑衣斗篷.jpg"的情况
          const variations = [
            resourceName.replace(/黑色/, '黑衣'),  // 黑色斗篷 -> 黑衣斗篷
            resourceName.replace(/黑衣/, '黑色'),  // 反向转换
            resourceName.replace(/破/, ''),        // 移除"破"字
            resourceName.replace(/ /g, '')         // 移除空格
          ];

variations.forEach(variation => {
            possibleExtensions.forEach(ext => {
              if (variation && variation !== resourceName) {
                allPossibleUrls.push(`UI/${variation}${ext}`);
              }
            });
          });

// 去重
          const uniqueUrls = [...new Set(allPossibleUrls)];

// 尝试所有可能的URL（同步方式）
          function tryNextUrl(index) {
            if (index >= uniqueUrls.length) {
              console.log(`尝试了所有可能的URL，仍无法加载资源 ${resource.name} 的图片`);
              return;
            }

const url = uniqueUrls[index];
            tryLoadImageSync(url).then(success => {
              if (success) {
                console.log(`成功通过备用路径加载图片: ${url}`);
              } else {
                tryNextUrl(index + 1); // 尝试下一个URL
              }
            });
          }

// 开始尝试备用URLs
          tryNextUrl(0);
        }

// 设置图片加载事件
        img.onload = function() {
          console.log(`资源 ${resource.name} 的图片加载成功`);
          if (fallback) fallback.style.display = 'none';
        };

// 设置图片加载失败事件
        img.onerror = function() {
          handleImageLoadFailure();
        };

// 触发图片加载
        img.src = imgUrl;
      }
      
      // 更新滚动条状态
      updateScrollBar();
    }

// 添加分类切换事件
    function setupCategoryTabs() {
        document.querySelectorAll('.inventory-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                currentCategory = tab.dataset.category;
                renderResources();
            });
        });
    }

// 添加滚动条事件
    function setupScrollBar() {
        const scrollLeftButton = document.getElementById('scrollLeft');
        const scrollRightButton = document.getElementById('scrollRight');
        const resourceGrid = document.getElementById('resourceGrid');

if (scrollLeftButton) {
            scrollLeftButton.addEventListener('click', () => {
                if (resourceGrid) {
                    resourceGrid.scrollLeft -= 100;
                    updateScrollBar();
                }
            });
        }

if (scrollRightButton) {
            scrollRightButton.addEventListener('click', () => {
                if (resourceGrid) {
                    resourceGrid.scrollLeft += 100;
                    updateScrollBar();
                }
            });
        }

// 监听资源网格的滚动事件，更新滚动条位置
        if (resourceGrid) {
            resourceGrid.addEventListener('scroll', updateScrollBar);
        }
    }

// 更新滚动条状态
    function updateScrollBar() {
        const resourceGrid = document.getElementById('resourceGrid');
        const scrollBar = document.querySelector('.resource-scrollbar');
        const scrollBarThumb = document.querySelector('.resource-scrollbar-thumb');
        
        if (resourceGrid && scrollBar && scrollBarThumb) {
            const maxScrollLeft = resourceGrid.scrollWidth - resourceGrid.clientWidth;
            const scrollPercent = resourceGrid.scrollLeft / maxScrollLeft;
            const thumbWidth = scrollBar.clientWidth * (resourceGrid.clientWidth / resourceGrid.scrollWidth);
            
            scrollBarThumb.style.width = `${thumbWidth}px`;
            scrollBarThumb.style.left = `${scrollPercent * (scrollBar.clientWidth - thumbWidth)}px`;
        }
    }

    // 获取地点在地图上的固定坐标
    function generateLocationCoordinates(locationId) {
      // 8个地点的预设坐标点
      const locationCoordinates = {
        'street': { x: 350, y: 150 },     // 东西市，中左侧上部
        'temple': { x: 450, y: 100 },      // 万佛寺，北侧中心
        'rich_area': { x: 650, y: 250 },   // 锣鼓巷，右侧偏上
        'black_market': { x: 620, y: 450 }, // 黑市，右侧偏下
        'slum': { x: 650, y: 100 },       // 鸡毛房，右侧上部
        'dump': { x: 200, y: 100 },       // 灰坑，左侧上部
        'prison': { x: 600, y: 300 },     // 牢房，右侧中部
        'wilderness': { x: 150, y: 300 }   // 城外山野，左侧中部
      };
      
      // 返回对应地点的坐标，如果未定义则返回默认中心坐标
      return locationCoordinates[locationId] || { x: 450, y: 300 };
    }

    // 创建地图上的地点卡牌
    function createMapLocationCard(location) {
      const locationCard = document.createElement('div');
      locationCard.className = `map-location-card ${location.currentLocation ? 'current' : ''}`;
      locationCard.setAttribute('data-location', location.id);
      
      // 如果该地点还没有坐标，则生成随机坐标
      if (!location.mapCoordinates) {
        location.mapCoordinates = generateLocationCoordinates(location.id);
      }
      
      // 设置卡牌位置
      locationCard.style.left = `${location.mapCoordinates.x}px`;
      locationCard.style.top = `${location.mapCoordinates.y}px`;
      
      // 设置卡牌内容
      locationCard.innerHTML = `${location.name}`;
      
      return locationCard;
    }

    // 创建地点卡牌（用于主界面）
    function createLocationCard(location) {
      const locationCard = document.createElement('div');
      locationCard.className = `card location location-card ${location.currentLocation ? 'current' : ''}`;
      locationCard.setAttribute('data-location', location.id);
      
      // 对于万佛寺，不显示明显标识
      const showLocationIcon = location.id !== 'temple';
      
      locationCard.innerHTML = `
        <div class="card-content">
          <div class="card-title map-card-title">${location.name}</div>
        </div>
      `;
      
      return locationCard;
    }

    // 渲染地点
    function renderLocations() {
      // 检查locationGrid是否存在
      if (!elements.locationGrid) {
        debugLog('错误: locationGrid元素不存在');
        return;
      }
      
      elements.locationGrid.innerHTML = '';

for (const location of gameData.locations) {
        let shouldShow = false;
        
        // 根据地点类型判断是否显示
        if (location.id === 'black_market') {
          // 黑市需要满足多个条件：
          // 1. available为true（已通过神秘人解锁）
          // 2. 解锁标志为true（确保用户已完成解锁流程）
          shouldShow = location.available && gameData.flags.blackMarketUnlocked === true;
        } else if (location.id === 'prison') {
          // 牢房只有在服刑期间才显示
          shouldShow = location.sentenceDays > 0;
        } else {
          // 其他地点正常显示
          shouldShow = location.available;
        }
        
        if (shouldShow) {
          const locationCard = document.createElement('div');
          locationCard.className = `card location location-card ${location.currentLocation ? 'current' : ''}`;
          locationCard.setAttribute('data-location', location.id);

// 对于万佛寺，不显示明显标识
          const showLocationIcon = location.id !== 'temple';

locationCard.innerHTML = `
            <div class="card-content">
              <div class="card-title">${location.name}</div>
              <div class="card-description">${location.description}</div>
              <div class="location-details">
                <!-- 已移除危险等级显示 -->
              </div>
            </div>
          `;

elements.locationGrid.appendChild(locationCard);
        }
      }
    }

    // 渲染行动
    function renderActions() {
      elements.actionGrid.innerHTML = '';

// 获取当前地点
      const currentLocation = gameData.locations.find(loc => loc.currentLocation);

if (!currentLocation) {
        return;
      }

// 根据时间和地点选择行动列表
      let actionsToRender = [...currentLocation.actions];

// 如果是夜晚且在东西市，使用夜晚行动列表
      if (gameData.timeOfDay === 'night' && currentLocation.id === 'street' && currentLocation.nightActions) {
        actionsToRender = [...currentLocation.nightActions];

// 如果黑市已解锁，移除与神秘人对话行动
        const blackMarketLocation = gameData.locations.find(loc => loc.id === 'black_market');
        if (blackMarketLocation && blackMarketLocation.available) {
          actionsToRender = actionsToRender.filter(actionId => actionId !== 'talk_mystery');
        }
      }

// 如果是万佛寺，检查是否是放斋日（第2天开始，每4天一次）
      if (currentLocation.id === 'temple') {
        // 检查是否是放斋日（第2天、第6天、第10天...）
        if (gameData.day < 2 || (gameData.day - 2) % 4 !== 0 || gameData.fastingDayClaimed) {
          // 不是放斋日（从第2天开始每4天一次），或者已经领取过，则移除放斋日行动
          actionsToRender = actionsToRender.filter(actionId => actionId !== 'fasting_day');
        }
      }

// 根据当前地点的行动列表渲染行动卡牌
      for (const actionId of actionsToRender) {
        const action = gameData.actions.find(act => act.id === actionId);

if (!action) continue;

// 检查是否满足行动所需的资源
        let canPerform = true;
        if (action.requires) {
          for (const [resource, amount] of Object.entries(action.requires)) {
            if (!gameData.resources[resource] || gameData.resources[resource].amount < amount) {
              canPerform = false;
              break;
            }
          }
        }

const actionCard = document.createElement('div');
        actionCard.className = `card action action-card ${canPerform ? '' : 'opacity-50'}`;
        actionCard.setAttribute('data-action', action.id);
        actionCard.setAttribute('data-can-perform', canPerform);

actionCard.innerHTML = `
          <div class="card-title">${action.name}</div>
        `;

elements.actionGrid.appendChild(actionCard);
      }
    }

    // 渲染配方
    function renderRecipes() {
      elements.recipeGrid.innerHTML = '';

for (const recipe of gameData.recipes) {
        const isDiscovered = gameData.discoveredRecipes.includes(recipe.id);

const recipeCard = document.createElement('div');
        recipeCard.className = 'recipe-card';

if (!isDiscovered) {
          // 未解锁的配方显示为问号
          recipeCard.innerHTML = `
            <h3 class="recipe-card-title">???</h3>
            <div class="recipe-card-ingredients">
              <span class="recipe-card-ingredient">???</span>
              <span class="recipe-card-ingredient">???</span>
            </div>
            <p class="recipe-card-description">未解锁的配方</p>
            <p class="recipe-card-undiscovered">未发现</p>
          `;
        } else {
          // 已解锁的配方显示完整信息
          let ingredientsHtml = '';
          for (const [resource, amount] of Object.entries(recipe.ingredients)) {
            const resourceName = gameData.resources[resource] ? gameData.resources[resource].name : resource;
            ingredientsHtml += `<span class="recipe-card-ingredient">${resourceName} x${amount}</span>`;
          }

recipeCard.innerHTML = `
            <h3 class="recipe-card-title">${recipe.name}</h3>
            <div class="recipe-card-ingredients">
              ${ingredientsHtml}
            </div>
            <p class="recipe-card-description">${recipe.description}</p>
            <p class="recipe-card-discovered">已发现</p>
          `;
        }

elements.recipeGrid.appendChild(recipeCard);
      }
    }

    // 设置事件监听器
    function setupEventListeners() {
      // 卸下装备按钮点击事件
      document.addEventListener('click', function(e) {
        if (e.target.classList.contains('unequip-button')) {
          const slot = e.target.getAttribute('data-slot');
          const resourceId = e.target.getAttribute('data-resource');
          unequipItem(slot, resourceId);
        }
      });

// 装备按钮点击事件
      const equipmentButton = document.getElementById('equipmentButton');
      if (equipmentButton) {
        equipmentButton.addEventListener('click', function() {
          openEquipmentWindow();
        });
      }

// 技能按钮点击事件
      const skillsButton = document.getElementById('skillsButton');
      if (skillsButton) {
        skillsButton.addEventListener('click', function() {
          openSkillsWindow();
        });
      }

// 开始游戏按钮
      if (elements.startGameButton) {
        elements.startGameButton.addEventListener('click', () => {
        debugLog('开始游戏按钮被点击');
        try {
          debugLog('设置开始屏幕淡出动画');
          elements.startScreen.style.opacity = '0';

setTimeout(() => {
            try {
              debugLog('隐藏开始屏幕');
              elements.startScreen.style.display = 'none';

debugLog('显示游戏容器');
              elements.gameContainer.style.display = 'block';

debugLog('开始完全重置游戏数据...');
              
              // 首先尝试调用resetGame函数进行完全重置
              if (typeof resetGame === 'function') {
                try {
                  debugLog('调用resetGame函数重置游戏');
                  resetGame();
                  debugLog('resetGame函数调用成功');
                } catch (resetFuncError) {
                  console.error('调用resetGame函数失败:', resetFuncError);
                  // 重置失败时进行手动重置
                  performManualGameReset();
                }
              } else {
                debugLog('resetGame函数不存在，手动重置基本数据');
                performManualGameReset();
              }
              
              debugLog('调用initGame()初始化游戏');
              initGame();
              debugLog('游戏初始化完成');
            } catch (error) {
              console.error('开始游戏动画后错误:', error);
              showErrorDisplay(`开始游戏错误: ${error.message}`);
            }
          }, 500);
        } catch (error) {
          console.error('开始游戏按钮点击错误:', error);
          showErrorDisplay(`开始游戏按钮错误: ${error.message}`);
        }
      });
      } else {
        debugLog('错误: startGameButton元素不存在');
      }

// 教程模态框
      // 教程关闭按钮的事件处理已经在setupHelpButton()函数中设置，这里不再重复绑定

// 地点卡牌点击
      if (elements.locationGrid) {
        elements.locationGrid.addEventListener('click', (e) => {
        const locationCard = e.target.closest('.location-card');
        if (locationCard) {
          const locationId = locationCard.getAttribute('data-location');
          visitLocation(locationId);
        }
      });
      } else {
        debugLog('错误: locationGrid元素不存在');
      }

// 行动卡牌点击
      if (elements.actionGrid) {
        elements.actionGrid.addEventListener('click', (e) => {
        const actionCard = e.target.closest('.action-card');
        if (actionCard) {
          const actionId = actionCard.getAttribute('data-action');
          const canPerform = actionCard.getAttribute('data-can-perform') === 'true';

if (canPerform) {
            performAction(actionId);
          } else {
            showNotification('条件不足', '你没有足够的资源来执行此行动。');
          }
        }
      });
      } else {
        debugLog('错误: actionGrid元素不存在');
      }

// 配方按钮点击
      const recipeButton = document.getElementById('recipeButton');
      if (recipeButton) {
        recipeButton.addEventListener('click', () => {
          renderRecipes();
          elements.recipeModal.classList.add('active');
        });
      }

// 资源卡牌拖拽
      if (elements.resourceGrid) {
        elements.resourceGrid.addEventListener('dragstart', (e) => {
          if (e.target.classList.contains('resource-card')) {
            const resourceId = e.target.getAttribute('data-resource');
            const resource = gameData.resources[resourceId];
            
            // 检查卡牌是否被固定
            if (resource && resource.pinned) {
              e.preventDefault();
              showNotification('卡牌已固定', '该卡牌已被固定，无法拖拽移动。');
              return;
            }
            
            e.dataTransfer.setData('text/plain', resourceId);
            e.target.classList.add('dragging');
            // 设置拖拽效果
            e.dataTransfer.effectAllowed = 'move';
          }
        });
        
        // 拖拽排序功能
        let draggedElement = null;
        let dragOverElement = null;
        
        elements.resourceGrid.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          
          const draggingCard = document.querySelector('.dragging');
          if (!draggingCard) return;
          
          const container = elements.resourceGrid;
          const mousePosX = e.clientX;
          
          // 找到鼠标位置下的卡片，排除固定卡牌
          const cards = container.querySelectorAll('.resource-card:not(.dragging)');
          let targetCard = null;
          
          cards.forEach(card => {
            const resourceId = card.getAttribute('data-resource');
            const resource = gameData.resources[resourceId];
            
            // 跳过固定卡牌
            if (resource && resource.pinned) return;
            
            const cardRect = card.getBoundingClientRect();
            const cardCenterX = cardRect.left + cardRect.width / 2;
            
            // 确定应该插入到哪个卡片前面
            if (mousePosX < cardCenterX && !targetCard) {
              targetCard = card;
            }
          });
          
          // 如果找到目标卡片，将拖拽的卡片插入到目标卡片前面
          if (targetCard) {
            container.insertBefore(draggingCard, targetCard);
          } else {
            // 否则将拖拽的卡片放到最后
            container.appendChild(draggingCard);
          }
        });
        
        elements.resourceGrid.addEventListener('dragend', (e) => {
          if (e.target.classList.contains('resource-card')) {
            e.target.classList.remove('dragging');
            
            // 保存新的排序到localStorage或游戏数据中
            saveItemOrder();
          }
        });
      }
      
      // 保存物品排序的函数
      function saveItemOrder() {
        const container = elements.resourceGrid;
        if (!container) return;
        
        const cards = container.querySelectorAll('.resource-card');
        const itemOrder = Array.from(cards).map(card => card.getAttribute('data-resource'));
        
        // 将排序保存到localStorage
        localStorage.setItem('inventoryOrder', JSON.stringify(itemOrder));
      }
      
      // 加载物品排序的函数（需要在生成背包时调用）
      function loadItemOrder() {
        const savedOrder = localStorage.getItem('inventoryOrder');
        if (!savedOrder) return;
        
        const container = elements.resourceGrid;
        if (!container) return;
        
        const itemOrder = JSON.parse(savedOrder);
        const cards = container.querySelectorAll('.resource-card');
        
        // 创建一个映射，将资源ID映射到对应的卡片元素
        const cardMap = new Map();
        cards.forEach(card => {
          const resourceId = card.getAttribute('data-resource');
          cardMap.set(resourceId, card);
        });
        
        // 按照保存的顺序重新排列卡片
        itemOrder.forEach(resourceId => {
          const card = cardMap.get(resourceId);
          if (card && card.parentNode !== container) {
            container.appendChild(card);
          }
        });
      }

// 组合槽拖放 - 只选择卡牌组合区域的槽位
      const combinationSlots = document.querySelectorAll('#combinationSlots .combination-slot');
      combinationSlots.forEach(slot => {
        slot.addEventListener('dragover', (e) => {
          e.preventDefault();
          slot.classList.add('active');
        });

slot.addEventListener('dragleave', () => {
          slot.classList.remove('active');
        });

slot.addEventListener('drop', (e) => {
          e.preventDefault();
          slot.classList.remove('active');

const resourceId = e.dataTransfer.getData('text/plain');
          if (resourceId && gameData.resources[resourceId].amount > 0) {
            const slotNumber = slot.getAttribute('data-slot');

// 如果槽位已有资源，将其返回背包
            if (gameData.combinationSlots[slotNumber]) {
              const prevResourceId = gameData.combinationSlots[slotNumber];
              // 不需要增减数量，因为只是移动位置
            }

// 放置新资源
            gameData.combinationSlots[slotNumber] = resourceId;

// 更新UI
            updateCombinationSlots();
            renderResources();
            checkCombination();
          }
        });

slot.addEventListener('click', () => {
          const slotNumber = slot.getAttribute('data-slot');
          if (gameData.combinationSlots[slotNumber]) {
            const resourceId = gameData.combinationSlots[slotNumber];
            // 不需要增减数量，因为只是移动位置
            gameData.combinationSlots[slotNumber] = null;

updateCombinationSlots();
            renderResources();
            checkCombination();
          }
        });
      });

// 组合按钮
      if (elements.craftButton) {
        elements.craftButton.addEventListener('click', () => {
          console.log('组合按钮被点击了！');
          combineCards();
        });
      }

      // 事件模态框关闭按钮
      elements.closeEventButton.addEventListener('click', () => {
        elements.eventModal.classList.remove('active');
        endTurn();
      });

      // 地图模态框关闭按钮
      elements.closeMapButton.addEventListener('click', () => {
        console.log('地图模态框关闭按钮被点击');
        elements.mapModal.classList.remove('active');
      });

// 事件模态框点击任意位置关闭
      elements.eventModal.addEventListener('click', (e) => {
        if (e.target === elements.eventModal) {
          console.log('事件模态框背景被点击，关闭模态框');
          elements.eventModal.classList.remove('active');
        }
      });

      // 地图模态框点击任意位置关闭
      elements.mapModal.addEventListener('click', (e) => {
        if (e.target === elements.mapModal) {
          console.log('地图模态框背景被点击，关闭模态框');
          elements.mapModal.classList.remove('active');
        }
      });

      // 地图按钮点击事件
      elements.mapButton.addEventListener('click', () => {
        console.log('地图按钮被点击');
        try {
          // 清空并重新渲染地图中的地点卡牌
          elements.mapLocationGrid.innerHTML = '';
          console.log('地点卡牌容器已清空');
          
          // 使用gameData.locations而不是未定义的locations变量
          const locations = gameData.locations;
          if (!locations) {
            console.error('错误: gameData.locations 不存在');
            return;
          }
          
          locations.forEach(location => {
            console.log('正在渲染地点:', location.name);
            let shouldShow = false;
            
            // 根据地点类型判断是否显示（与主界面保持一致）
            if (location.id === 'black_market') {
              // 黑市需要满足多个条件：
              // 1. available为true（已通过神秘人解锁）
              // 2. 解锁标志为true（确保用户已完成解锁流程）
              shouldShow = location.available && gameData.flags.blackMarketUnlocked === true;
            } else if (location.id === 'prison') {
              // 牢房只有在服刑期间才显示
              shouldShow = location.sentenceDays > 0;
            } else {
              // 其他地点正常显示
              shouldShow = location.available;
            }
            
            if (shouldShow) {
              const locationCard = createMapLocationCard(location);
              elements.mapLocationGrid.appendChild(locationCard);
            }
          });
          console.log('所有地点卡牌渲染完成');
          
          // 为地图模态框中的地点卡牌添加点击事件监听器
          elements.mapLocationGrid.addEventListener('click', (e) => {
            const locationCard = e.target.closest('.map-location-card');
            if (locationCard) {
              const locationId = locationCard.getAttribute('data-location');
              console.log('地图中地点卡牌被点击，地点ID:', locationId);
              visitLocation(locationId);
              // 关闭地图模态框
              elements.mapModal.classList.remove('active');
            }
          });
          
          // 显示地图模态框
          elements.mapModal.classList.add('active');
          console.log('地图模态框已显示');
        } catch (error) {
          console.error('地图按钮点击事件中发生错误:', error);
        }
      });

// 配方模态框关闭按钮
      elements.closeRecipeButton.addEventListener('click', () => {
        elements.recipeModal.classList.remove('active');
      });

// 配方模态框点击任意位置关闭
      elements.recipeModal.addEventListener('click', (e) => {
        if (e.target === elements.recipeModal) {
          elements.recipeModal.classList.remove('active');
        }
      });

// 游戏结束模态框按钮


elements.exitGameButton.addEventListener('click', () => {
        // 重置游戏状态，确保下次开始游戏时是全新的游戏
        gameData.gameOver = false;
        // 调用返回开始页面函数
        returnToStartPage();
      });

// 通知关闭按钮
      elements.closeNotificationButton.addEventListener('click', () => {
        elements.notification.classList.remove('active');
      });

// 成就通知关闭按钮
      elements.closeAchievementButton.addEventListener('click', () => {
        elements.achievementModal.classList.remove('active');
      });

      // 行动点提示窗口事件监听器
      if (elements.closeActionPointsModal) {
        elements.closeActionPointsModal.addEventListener('click', closeActionPointsModal);
      }
      
      if (elements.endDayActionPointsModal) {
        elements.endDayActionPointsModal.addEventListener('click', endDayFromActionPointsModal);
      }
      
      // 点击行动点提示窗口外部关闭
      if (elements.actionPointsModal) {
        elements.actionPointsModal.addEventListener('click', function(e) {
          if (e.target === elements.actionPointsModal) {
            closeActionPointsModal();
          }
        });
      }
    }

    // 组合卡牌
    function combineCards() {
      console.log('combineCards函数被调用了！');
      const slots = Object.values(gameData.combinationSlots).filter(Boolean);
      console.log('组合槽中的物品:', slots);

if (slots.length < 2) {
        showNotification('组合失败', '需要至少两张卡牌才能组合。');
        return;
      }

// 检查是否匹配任何配方
      let matchedRecipe = null;

for (const recipe of gameData.recipes) {
        const ingredients = Object.keys(recipe.ingredients);

// 检查配方所需的所有资源是否都在组合槽中
        let hasAllIngredients = true;
        const slotCounts = {};

// 计算组合槽中每种资源的数量
        slots.forEach(resourceId => {
          slotCounts[resourceId] = (slotCounts[resourceId] || 0) + 1;
        });

// 检查是否满足配方要求
        for (const [resource, requiredAmount] of Object.entries(recipe.ingredients)) {
          if (!slotCounts[resource] || slotCounts[resource] < requiredAmount) {
            hasAllIngredients = false;
            break;
          }
        }

if (hasAllIngredients) {
          matchedRecipe = recipe;
          break;
        }
      }

if (matchedRecipe) {
        console.log('找到匹配的配方:', matchedRecipe);
        // 保存当前配方引用，以便在回调中使用
        const currentRecipe = matchedRecipe;
        // 滑块小游戏配置 - 检查产物是否为装备类物品
        const hasEquipment = Object.keys(currentRecipe.result).some(resultId => gameData.resources[resultId] && gameData.resources[resultId].category === 'equipment');
        const gameConfig = {
          speed: hasEquipment ? 4 : 2, // 装备类物品速度为4，非装备类物品速度为2
          targetWidth: hasEquipment ? 0.08 : 0.1, // 装备类物品目标区域宽度为0.08，非装备类物品目标区域宽度为0.1
          timeLimit: 10 // 10秒时间限制
        };
        console.log('滑块游戏配置:', gameConfig);

// 显示滑块小游戏
        console.log('准备显示滑块小游戏...');
        console.log('elements.sliderGameModal:', elements.sliderGameModal);
        startSliderGame(gameConfig, (success) => {
          if (success) {
            // 游戏成功，消耗资源并应用配方结果
            const results = {
              resources: {},
              status: {},
              effects: []
            };

// 消耗背包中的资源
            for (const [resource, requiredAmount] of Object.entries(currentRecipe.ingredients)) {
              if (resource in gameData.resources) {
                const originalAmount = gameData.resources[resource].amount;
                gameData.resources[resource].amount = Math.max(0, originalAmount - requiredAmount);

// 检查该物品是否正在装备中
                if (gameData.resources[resource].equipped) {
                  // 如果物品数量变为0，自动卸下装备
                  if (gameData.resources[resource].amount === 0) {
                    // 移除装备效果
                    applyEquipmentEffect(resource, 'unequip');
                    // 移除装备状态
                    gameData.resources[resource].equipped = false;
                    results.effects.push(`你的${gameData.resources[resource].name}被消耗了，已自动卸下。`);
                  }
                }
              }
            }

// 应用配方结果
            let resourceChanged = false;
            for (const [resource, amount] of Object.entries(currentRecipe.result)) {
              if (resource in gameData.resources) {
                // 记录资源是否有变化
                if (gameData.resources[resource].amount !== gameData.resources[resource].amount + amount) {
                  resourceChanged = true;
                }
                gameData.resources[resource].amount += amount;
              } else if (resource in gameData.status) {
                const newStatus = Math.min(100, Math.max(0, gameData.status[resource] + amount));
                if (gameData.status[resource] !== newStatus) {
                  resourceChanged = true;
                }
                gameData.status[resource] = newStatus;
              } else if (resource === 'begging_chance') {
                // 处理乞讨成功率加成
                gameData.begging_chance = (gameData.begging_chance || 0) + amount;
                resourceChanged = true;
                showNotification('制作成功', `你的乞讨成功率提高了${amount}%！`);
              } else {
                // 如果是新的资源，创建它
                gameData.resources[resource] = {
                  name: resource.charAt(0).toUpperCase() + resource.slice(1).replace('_', ' '),
                  amount: amount,
                  image: '' // 默认为空图片，实际游戏中应该设置正确的图片
                };

// 如果是可制作的物品，设置初始耐久度
                if (['simple_clothes', 'fire', 'clay_bowl', 'crutch', 'black_cloak'].includes(resource)) {
                  gameData.resources[resource].durability = 100;
                  // 如果是篝火，设置初始燃料值
                  if (resource === 'fire') {
                    gameData.resources[resource].fuel = 100;
                  }
                }
                resourceChanged = true;
              }
            }

// 标记配方为已发现
            if (!gameData.discoveredRecipes.includes(currentRecipe.id)) {
              gameData.discoveredRecipes.push(currentRecipe.id);
              gameData.stats.recipesDiscovered++;
              showAchievement('新配方发现', `你发现了如何制作${currentRecipe.name}！`);
            }

// 如果制作的是泥碗，确保背包中没有破碗
            if (currentRecipe.id === 'clay_bowl') {
              gameData.resources.bowl.amount = 0;
            }

// 清空组合槽（保留碗类卡牌）
            for (const slot in gameData.combinationSlots) {
              const resourceId = gameData.combinationSlots[slot];
              if (resourceId && !nonConsumableBowls.includes(resourceId)) {
                gameData.combinationSlots[slot] = null;
              } else if (resourceId && nonConsumableBowls.includes(resourceId)) {
                console.log(`碗类卡牌 ${resourceId} 保留在组合槽中`);
              }
            }

// 更新UI
            updateCombinationSlots();
            updateGameData();
            checkCombination();

// 如果资源有变化，更新相关资源卡牌
            if (resourceChanged) {
              // 更新消耗的资源
              for (const [resource, requiredAmount] of Object.entries(currentRecipe.ingredients)) {
                updateResourceCard(resource);
              }

// 更新生成的资源
              for (const [resource, amount] of Object.entries(currentRecipe.result)) {
                if (resource in gameData.resources) {
                  updateResourceCard(resource);
                }
              }

// 只有当有装备物品被消耗时才更新装备栏
              if (results.effects.length > 0) {
                renderEquipmentSlots(); // 更新装备栏
              }
            }

// 显示成功消息
            elements.combinationResult.innerHTML = `
              <div class="text-green-600">
                <i class="fa fa-check-circle" aria-hidden="true"></i>
                成功制作了 ${currentRecipe.name}！
              </div>
            `;

// 如果有装备物品被消耗，显示通知
            if (results.effects.length > 0) {
              showEventResult('组合结果', results);
            } else {
              showNotification('组合成功', `成功制作了${currentRecipe.name}！`);
            }
          } else {
            // 游戏失败，消耗当前组合区域的卡牌
            console.log('滑块游戏失败，开始消耗组合区域的卡牌');
            console.log('当前组合槽:', gameData.combinationSlots);
            console.log('匹配的配方:', currentRecipe);
            
            // 消耗背包中的资源
            for (const [resource, requiredAmount] of Object.entries(currentRecipe.ingredients)) {
              if (resource in gameData.resources && !nonConsumableBowls.includes(resource)) {
                const originalAmount = gameData.resources[resource].amount;
                gameData.resources[resource].amount = Math.max(0, originalAmount - requiredAmount);
                console.log(`消耗了${requiredAmount}个${resource}，剩余${gameData.resources[resource].amount}个`);

// 检查该物品是否正在装备中
                if (gameData.resources[resource].equipped) {
                  // 如果物品数量变为0，自动卸下装备
                  if (gameData.resources[resource].amount === 0) {
                    // 移除装备效果
                    applyEquipmentEffect(resource, 'unequip');
                    // 移除装备状态
                    gameData.resources[resource].equipped = false;
                  }
                }
              } else if (nonConsumableBowls.includes(resource)) {
                console.log(`${resource}是碗类卡牌，不可消耗`);
              }
            }

// 清空组合槽（将碗类卡牌放回背包）
            for (const slot in gameData.combinationSlots) {
              const resourceId = gameData.combinationSlots[slot];
              if (resourceId) {
                if (nonConsumableBowls.includes(resourceId)) {
                  // 将碗类卡牌放回背包
                  gameData.resources[resourceId].amount++;
                  console.log(`将碗类卡牌 ${resourceId} 放回背包`);
                }
                // 清空组合槽
                gameData.combinationSlots[slot] = null;
              }
            }

// 更新UI
            updateCombinationSlots();
            updateGameData();
            checkCombination();

// 更新相关资源卡牌
            for (const [resource, requiredAmount] of Object.entries(currentRecipe.ingredients)) {
              updateResourceCard(resource);
            }

// 弹出游戏失败提示窗口
            showNotification('游戏失败', '游戏失败，未能制作出新的卡牌', 'error');
            
// 显示失败消息
            elements.combinationResult.innerHTML = `
              <div class="text-red-600">
                <i class="fa fa-times-circle" aria-hidden="true"></i>
                游戏失败，未能制作出新的卡牌
              </div>
            `;
          }
        });
      } else {
        // 显示失败消息
        elements.combinationResult.innerHTML = `
          <div class="text-red-600">
            <i class="fa fa-times-circle" aria-hidden="true"></i>
            这些卡牌无法组合。
          </div>
        `;

showNotification('组合失败', '这些卡牌无法组合，请尝试其他组合。');
      }
    }

    // 滑块小游戏实现
    function startSliderGame(config, callback) {
      console.log('startSliderGame函数被调用了！');
      console.log('传入的配置:', config);
      // 配置默认值
      const speed = config.speed || 2;
      const targetWidth = config.targetWidth || 0.3;
      const timeLimit = config.timeLimit || 10;

// 获取DOM元素
      const modal = elements.sliderGameModal;
      const track = elements.sliderTrack;
      const slider = elements.sliderTriangle;
      const target = elements.targetArea;
      const timer = elements.timerBar;
      const stopButton = elements.stopButton;

console.log('获取的DOM元素:', {
        modal: !!modal,
        track: !!track,
        slider: !!slider,
        target: !!target,
        timer: !!timer,
        stopButton: !!stopButton
      });

// 初始化游戏状态
      let isPlaying = true;
      let isMovingRight = true;
      let sliderPosition;
      // 手动设置滑块宽度（border-left + border-right = 30px）
      const sliderWidth = 30;
      let trackWidth, targetSize, targetX;
      let leftYellowStart, leftYellowEnd, rightYellowStart, rightYellowEnd;
      let yellowAreaStart, yellowAreaEnd;
      let gameLoop; // 游戏循环变量提升到外部作用域
      
      // 设置计时器初始状态
      let timeRemaining = timeLimit;
      
      // 显示模态框
      console.log('尝试显示模态框...');
      console.log('模态框是否已存在:', !!modal);
      if (modal) {
        console.log('模态框当前类:', modal.className);
        modal.classList.add('active');
        console.log('添加active类后的类:', modal.className);
        console.log('模态框是否可见:', modal.classList.contains('active'));
        console.log('模态框计算样式:', {
          opacity: window.getComputedStyle(modal).opacity,
          visibility: window.getComputedStyle(modal).visibility
        });
        
        // 模态框显示后再计算尺寸，确保DOM已经渲染
        setTimeout(() => {
          trackWidth = track.offsetWidth;
          targetSize = trackWidth * targetWidth;
          
          // 调试日志：验证轨道和滑块尺寸
          console.log('滑块游戏尺寸信息:', {
            trackWidth: trackWidth,
            sliderWidth: sliderWidth,
            targetSize: targetSize
          });

          // 设置绿色区域位置和大小
          // 绿色区域随机出现在黄色区域内
          const yellowAreaWidth = trackWidth - targetSize;
          targetX = Math.random() * yellowAreaWidth;
          target.style.width = targetSize + 'px';
          target.style.left = targetX + 'px';
          
          // 计算区域范围（基于CSS布局：黄色区域 + 绿色区域 + 黄色区域）
          // 左黄色区域：0 到 绿色区域开始位置
          leftYellowStart = 0;
          leftYellowEnd = targetX;
          // 绿色区域：targetX 到 targetX + targetSize
          // 右黄色区域：绿色区域结束位置 到 轨道最右端
          rightYellowStart = targetX + targetSize;
          rightYellowEnd = trackWidth;
          
          // 滑块移动范围：左黄色区域 + 绿色区域 + 右黄色区域（整个轨道）
          yellowAreaStart = leftYellowStart;      // 左黄色区域最左端
          yellowAreaEnd = rightYellowEnd;         // 右黄色区域最右端
          
          // 初始化滑块位置在整个移动范围的中心（左黄色 + 绿色 + 右黄色）
          // 滑块是向下的三角形，尖端在底部中心
          sliderPosition = yellowAreaStart + (yellowAreaEnd - yellowAreaStart)/2 - sliderWidth/2;
          
          // 应用初始位置
          slider.style.left = `${sliderPosition}px`;
          
          // 设置计时器宽度
          timer.style.width = '100%';
          
          // 开始游戏循环
          startGameLoop();
        }, 100); // 等待100ms确保模态框完全显示和渲染
      } else {
        console.error('modal元素不存在！');
      }

// 游戏循环函数
      function startGameLoop() {
        gameLoop = setInterval(() => {
          if (!isPlaying) return;

          // 更新滑块位置
          if (isMovingRight) {
            sliderPosition += speed;
            // 滑块尖端到达右黄色区域最右端时反向（轨道最右端）
            if (sliderPosition + sliderWidth/2 >= yellowAreaEnd) {
              sliderPosition = yellowAreaEnd - sliderWidth/2;
              isMovingRight = false;
            }
          } else {
            sliderPosition -= speed;
            // 滑块尖端到达左黄色区域最左端时反向（轨道最左端）
            if (sliderPosition + sliderWidth/2 <= yellowAreaStart) {
              sliderPosition = yellowAreaStart - sliderWidth/2;
              isMovingRight = true;
            }
          }

          // 应用滑块位置
          slider.style.left = `${sliderPosition}px`;

          // 更新计时器
          timeRemaining -= 0.016; // 假设60fps
          const timerPercentage = (timeRemaining / timeLimit) * 100;
          timer.style.width = `${Math.max(0, timerPercentage)}%`;

          // 检查超时
          if (timeRemaining <= 0) {
            isPlaying = false;
            clearInterval(gameLoop);
            modal.classList.remove('active');
            callback(false); // 游戏失败
          }
        }, 16); // 约60fps
      }

// 停止游戏的函数
      const stopGame = () => {
        if (!isPlaying) return;

        isPlaying = false;
        clearInterval(gameLoop);

        // 停止滑块移动，但不立即判定结果
        // 添加1秒延迟后再判定
        setTimeout(() => {
          // 检查滑块尖端是否在目标区域内
          // 滑块是三角形，尖端在中间位置
          const sliderTip = sliderPosition + sliderWidth/2;
          const targetLeft = targetX;
          const targetRight = targetX + targetSize;

          // 增加容错范围，解决手机触摸精度问题
          const tolerance = 5; // 5像素的容错范围
          const isSuccess = sliderTip >= (targetLeft - tolerance) && sliderTip <= (targetRight + tolerance);

          // 关闭模态框并回调结果
          modal.classList.remove('active');
          callback(isSuccess);
        }, 1000); // 1秒延迟
      };

// 绑定停止按钮事件
      stopButton.addEventListener('click', stopGame);

// 绑定手机触摸事件
      stopButton.addEventListener('touchend', (e) => {
        e.preventDefault(); // 防止触摸事件触发其他行为
        stopGame();
      });

// 绑定空格键事件
      const handleKeyPress = (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          stopGame();
        }
      };

document.addEventListener('keydown', handleKeyPress);

// 清理事件监听器
      const cleanup = () => {
        stopButton.removeEventListener('click', stopGame);
        document.removeEventListener('keydown', handleKeyPress);
      };

// 在模态框关闭时清理事件监听器
      modal.addEventListener('transitionend', () => {
        if (!modal.classList.contains('active')) {
          cleanup();
        }
      }, { once: true });
    }

    // 更新组合槽 - 只更新卡牌组合区域的槽位

// 检查地点进入条件
    function checkEntryConditions(location) {
      // 特殊检查：黑市需要黑色斗篷
      if (location.id === 'black_market') {
        // 检查是否穿戴了黑色斗篷
        let hasBlackCloakEquipped = false;

// 方法1：通过DOM检查特殊槽位是否有黑色斗篷
        const specialSlot = document.querySelector('.equipment-slots .combination-slot[data-slot="special"]');
        if (specialSlot) {
          const equipmentItem = specialSlot.querySelector('.equipment-item');
          if (equipmentItem && (equipmentItem.getAttribute('data-resource') === 'black_cloak' || 
              equipmentItem.innerHTML.includes('黑色斗篷'))) {
            hasBlackCloakEquipped = true;
          }
        }

// 方法2：通过游戏数据检查黑色斗篷是否已装备
        if (gameData.resources.black_cloak && gameData.resources.black_cloak.equipped) {
          hasBlackCloakEquipped = true;
        }

if (!hasBlackCloakEquipped) {
          // 显示提示：不符合进入条件
          showEventResult('不符合进入条件', {
            effects: ['进入黑市需要穿戴黑色斗篷，你目前没有穿戴。']
          });
          return false;
        }
      }

if (!location.entryCondition) return true;

for (const [status, condition] of Object.entries(location.entryCondition)) {
        if (condition.min !== undefined && gameData.status[status] < condition.min) {
          // 对于声望不足的情况，使用与放斋饭日相同的模态框样式
          if (status === 'reputation') {
            showReputationModal(location.name, condition.min, gameData.status[status]);
          } else {
            showNotification('条件不足', `进入${location.name}需要${status}至少${condition.min}%，你目前只有${gameData.status[status]}%。`, true);
          }
          return false;
        }
        if (condition.max !== undefined && gameData.status[status] > condition.max) {
          showNotification('条件不符', `进入${location.name}需要${status}不超过${condition.max}%，你目前有${gameData.status[status]}%。`, true);
          return false;
        }
      }

return true;
    }

// 显示地点图片弹窗
    function showLocationImageModal(locationName, locationImage, callback) {
      // 创建带有随机弹跳动画的文字
      const text = '移动中........';
      let animatedText = '';
      for (let i = 0; i < text.length; i++) {
        // 为每个字符创建span元素，设置随机延迟和弹跳高度
        const delay = (i * 0.1) + (Math.random() * 0.3);
        const height = 10 + (Math.random() * 15);
        animatedText += `<span class="bounce-char" style="--delay: ${delay}s; --height: ${height}px;">${text[i]}</span>`;
      }
      
      // 创建模态框元素
      const modal = document.createElement('div');
      modal.className = 'location-image-modal active';
      modal.innerHTML = `
        <div class="location-image-modal-content">
          <img src="${locationImage}" alt="${locationName}" class="location-image-modal-image">
          <div class="location-image-modal-text">${animatedText}</div>
        </div>
      `;

      document.body.appendChild(modal);

      // 等待图片加载完成后动态调整窗口大小
      const image = modal.querySelector('.location-image-modal-image');
      const content = modal.querySelector('.location-image-modal-content');
      
      const onImageLoad = () => {
        // 获取图片实际宽度
        const imageWidth = image.naturalWidth;
        const imageHeight = image.naturalHeight;
        
        // 设置缩放比例（整体缩小为图片实际大小的60%）
        const scale = 0.6;
        
        // 计算缩放后的宽度和高度
        const scaledWidth = Math.floor(imageWidth * scale);
        const scaledHeight = Math.floor(imageHeight * scale);
        
        // 设置图片宽度和高度
        image.style.width = scaledWidth + 'px';
        image.style.height = scaledHeight + 'px';
        
        // 设置窗口内容宽度为图片宽度（确保窗口与图片宽度相同）
        content.style.width = scaledWidth + 'px';
      };
      
      if (image.complete) {
        onImageLoad();
      } else {
        image.addEventListener('load', onImageLoad);
      }

      // 定义关闭模态框的函数
      const closeModal = () => {
        modal.classList.remove('active');
        setTimeout(() => {
          if (document.body.contains(modal)) {
            document.body.removeChild(modal);
          }
          if (callback) {
            callback();
          }
        }, 300); // 等待动画完成
      };

      // 添加样式
      const style = document.createElement('style');
      style.textContent = `
        .location-image-modal {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.5);
          backdrop-filter: blur(8px);
          -webkit-backdrop-filter: blur(8px);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 2000;
          opacity: 0;
          pointer-events: none;
          transition: opacity 0.3s ease;
        }

        .location-image-modal.active {
          opacity: 1;
          pointer-events: auto;
        }

        .location-image-modal-content {
          background-color: #FFFFFF;
          border: 2px solid #8B4513;
          border-radius: 8px;
          padding: 0;
          box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
          text-align: center;
          display: inline-block;
          margin: auto;
          width: auto;
          transition: width 0.3s ease;
          cursor: pointer;
        }

        .location-image-modal-image {
          max-width: 60vw;
          max-height: 80vh;
          border-radius: 0;
          box-shadow: none;
          width: auto;
          height: auto;
          transition: width 0.3s ease, height 0.3s ease;
        }

        .location-image-modal-text {
          margin-top: 15px;
          font-size: 18px;
          font-weight: normal;
          color: #8B4513;
          letter-spacing: 2px;
          width: 100%;
          box-sizing: border-box;
          padding: 0 10px 10px 10px;
          display: flex;
          justify-content: center;
          align-items: center;
          gap: 2px;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }

        .bounce-char {
          display: inline-block;
          animation: bounce 1s ease-in-out infinite;
          animation-delay: var(--delay);
          transform-origin: bottom center;
        }

        @keyframes bounce {
          0%, 100% {
            transform: translateY(0);
          }
          50% {
            transform: translateY(calc(-1 * var(--height)));
          }
        }
      `;
      document.head.appendChild(style);

      // 添加点击事件 - 点击图片内容区域可以立即关闭
      content.addEventListener('click', () => {
        closeModal();
      });

      // 添加点击背景关闭事件
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeModal();
        }
      });

      // 1秒后自动关闭模态框并执行回调函数
      setTimeout(() => {
        closeModal();
      }, 1000);
    }

// 退出地点
    function exitLocation() {
      // 获取当前地点
      const currentLocation = gameData.locations.find(loc => loc.currentLocation);

if (!currentLocation) return;

// 检查是否在牢房中且还有刑期
      if (currentLocation.id === 'prison') {
        const prisonLocation = gameData.locations.find(loc => loc.id === 'prison');
        if (prisonLocation && prisonLocation.sentenceDays > 0) {
          showNotification('无法离开', '你还在服刑期间，无法离开牢房！');
          return;
        }
      }

// 注意：离开地点本身不消耗行动点，只在切换时统一消耗2点
// 时间流逝 - 消耗1个回合
      gameData.timeTurns++;

// 显示退出通知
      showNotification('离开地点', `你离开了${currentLocation.name}。`);

// 更新UI
      renderLocations();
      updateGameData();

// 推进时间
      advanceTime();
    }

    // 访问地点
    function visitLocation(locationId) {
      // 防重复调用检查
      if (window.visitLocationInProgress) {
        console.log('visitLocation函数正在执行中，跳过重复调用');
        return;
      }
      
      // 设置防重复调用标志
      window.visitLocationInProgress = true;
      
      // 根据地点ID获取地点数据
      const location = gameData.locations.find(loc => loc.id === locationId);

      if (!location) {
        window.visitLocationInProgress = false;
        return;
      }

      // 检查是否已在当前地点
      const currentLocation = gameData.locations.find(loc => loc.currentLocation);
      if (currentLocation && currentLocation.id === locationId) {
        showNotification('已在该地点', `你已经在${location.name}了。`);
        window.visitLocationInProgress = false;
        return;
      }

      // 检查是否在牢房中且还有刑期，如果是，则不允许切换到其他地点
      if (currentLocation && currentLocation.id === 'prison') {
        const prisonLocation = gameData.locations.find(loc => loc.id === 'prison');
        if (prisonLocation && prisonLocation.sentenceDays > 0 && locationId !== 'prison') {
          showNotification('无法离开', '你还在服刑期间，无法离开牢房！');
          window.visitLocationInProgress = false;
          return;
        }
      }

      // 检查是否满足进入条件
      if (!checkEntryConditions(location)) {
        window.visitLocationInProgress = false;
        return;
      }

// 计算总行动点消耗（地图地点切换固定消耗2点）
      // 特别确保灰坑到万佛寺或万佛寺到灰坑也只消耗2点
      let totalActionCost = 2; // 固定消耗2点

// 检查行动点是否足够
      if (gameData.status.actionPoints < totalActionCost) {
        showActionPointsModal();
        return;
      }

      // 定义地点名称到图片文件的映射
      const locationImageMap = {
        '东西市': 'UI/东西市.jpg',
        '灰坑': 'UI/灰坑.jpg', 
        '万佛寺': 'UI/万佛寺.jpg',
        '锣鼓巷': 'UI/锣鼓巷.jpg',
        '鸡毛房': 'UI/鸡毛房.jpg',
        '城外山野': 'UI/城外山野.jpg',
        '黑市': 'UI/黑市.jpg',
        '牢房': 'UI/牢房.jpg'
      };

      // 获取当前地点图片
      const locationImage = locationImageMap[location.name];
      
      // 显示地点图片弹窗，然后执行地点切换逻辑
      showLocationImageModal(location.name, locationImage, () => {
        // 重新检查行动点是否足够（防止在弹窗显示期间行动点被消耗）
        if (gameData.status.actionPoints < totalActionCost) {
          showActionPointsModal();
          return;
        }
        
        // 消耗行动点（固定消耗2点）
        gameData.status.actionPoints -= 2;
        
        // 更新行动点显示
        updateActionPointsDisplay();

        // 更新当前地点
        if (currentLocation) {
          currentLocation.currentLocation = false;
        }
        location.currentLocation = true;

        // 时间流逝 - 消耗1个回合
        // 地点切换总共消耗2个回合（exitLocation消耗1个，visitLocation消耗1个）
        gameData.timeTurns++;

        // 显示进入通知
        showNotification('进入地点', `你进入了${location.name}。`);

        // 更新UI
        renderResources();
        renderLocations(); // 确保地点标识正确更新
        updateGameData();

        // 消耗时间
        advanceTime();
        
        // 清除防重复调用标志
        setTimeout(() => {
          window.visitLocationInProgress = false;
        }, 100);
      });
    }

    // 执行行动
    function performAction(actionId) {

// 根据行动ID获取行动数据
      const action = gameData.actions.find(act => act.id === actionId);

if (!action) return;

// 消耗1个行动点
      if (gameData.status.actionPoints < 1) {
        showActionPointsModal();
        return;
      }
      
      gameData.status.actionPoints--;
      // 检查元素是否存在，然后再设置textContent
      // 更新行动点显示
        updateActionPointsDisplay();

// 消耗所需资源
      if (action.requires) {
        for (const [resource, amount] of Object.entries(action.requires)) {
          // 检查资源是否存在
          if (gameData.resources[resource] && typeof gameData.resources[resource].amount === 'number') {
            gameData.resources[resource].amount -= amount;
          } else {
            console.warn(`资源 ${resource} 不存在或没有 amount 属性`);
          }
        }
      }

// 根据行动类型生成不同的结果
      switch (actionId) {
        // 放斋日行动在后面的switch语句中处理
        case 'beg':
          // 乞讨
          let baseChance = 0.3; // 基础失败概率为30%，成功率70%
          const begResults = {
            resources: {},
            status: {},
            effects: []
          };

// 根据玩家拥有的碗类型自动调整乞讨成功率
          // 碗的等级从低到高: 破碗(bowl)、泥碗(clay_bowl)、陶碗(pottery_bowl)、银碗(silver_bowl)、金碗(gold_bowl)
          let bowlBonus = 0;
          let bowlName = '';

if (gameData.resources.gold_bowl && gameData.resources.gold_bowl.amount > 0) {
            bowlBonus = 50; // 金碗提供50%成功率加成
            bowlName = '金碗';
          } else if (gameData.resources.silver_bowl && gameData.resources.silver_bowl.amount > 0) {
            bowlBonus = 30; // 银碗提供30%成功率加成
            bowlName = '银碗';
          } else if (gameData.resources.pottery_bowl && gameData.resources.pottery_bowl.amount > 0) {
            bowlBonus = 20; // 陶碗提供20%成功率加成
            bowlName = '陶碗';
          } else if (gameData.resources.clay_bowl.amount > 0) {
            bowlBonus = 10; // 泥碗提供10%成功率加成
            bowlName = '泥碗';
          } else if (gameData.resources.bowl.amount > 0) {
            bowlBonus = 5; // 破碗提供5%成功率加成
            bowlName = '破碗';
          }

// 合并基础加成和碗加成
          const totalBeggingChance = gameData.begging_chance + bowlBonus;

if (totalBeggingChance > 0) {
            // 每10点乞讨成功率降低10%的失败概率
            baseChance = Math.max(0.1, 0.3 - (totalBeggingChance / 100));
            begResults.effects.push(`使用${bowlName}，乞讨成功率提升${totalBeggingChance}%`);
          }

const begSuccess = Math.random() > baseChance;

if (begSuccess) {
            if (action.success) {
              // 50%的概率获得钱币，50%的概率获得残羹剩饭
              const getMoney = Math.random() < 0.5;

if (getMoney) {
                // 获得钱币
                const moneyAmount = Math.max(1, Math.round(action.success.money));
                if (gameData.resources.money && typeof gameData.resources.money.amount === 'number') {
                  gameData.resources.money.amount += moneyAmount;
                  showNotification('乞讨成功', `你成功乞讨到了一些钱币。${gameData.begging_chance ? `(成功率提升${gameData.begging_chance}%)` : ''}`);
                  showNotification('乞讨成功', `你成功乞讨到了一些钱币。${gameData.begging_chance ? '(成功率提升' + gameData.begging_chance + '%)' : ''}`);
                } else {
                  console.warn('钱币资源不存在或没有 amount 属性');
                }
              } else {
                // 获得残羹剩饭
                const adjustedAmount = Math.max(1, Math.round(action.success.cangenshengfan || 1));
                if (gameData.resources.cangenshengfan && typeof gameData.resources.cangenshengfan.amount === 'number') {
                  gameData.resources.cangenshengfan.amount += adjustedAmount;
                  showNotification('乞讨成功', `你成功乞讨到了一些残羹剩饭。${gameData.begging_chance ? `(成功率提升${gameData.begging_chance}%)` : ''}`);
                  showNotification('乞讨成功', `你成功乞讨到了一些残羹剩饭。${gameData.begging_chance ? '(成功率提升' + gameData.begging_chance + '%)' : ''}`);
                } else {
                  console.warn('残羹剩饭资源不存在或没有 amount 属性');
                }
              }
            }
            showEventResult('乞讨结果', begResults);
          } else {
            if (action.failure) {
              for (const [status, amount] of Object.entries(action.failure)) {
                gameData.status[status] = Math.max(0, gameData.status[status] + amount);
                begResults.status[status] = amount;
              }
            }
            showNotification('乞讨失败', '没有人愿意施舍你，你的精神状态下降了。');
            showEventResult('乞讨结果', begResults);
          }
          break;

case 'search':
          // 搜寻
          // 基础成功率60%，每级搜寻技能增加3%成功率
          const baseSearchChance = 0.4; // 基础失败概率
          const searchLevelBonus = (gameData.skills.search && gameData.skills.search.level) ? gameData.skills.search.level * 0.03 : 0;
          const adjustedFailureChance = Math.max(0.1, baseSearchChance - searchLevelBonus); // 最低失败概率10%
          const searchSuccess = Math.random() > adjustedFailureChance;
          const searchResults = {
            resources: {},
            status: {},
            effects: []
          };

if (searchSuccess) {
            if (action.success) {
              let itemsFound = 0;
              const maxItems = 1;

// 创建资源数组并随机排序，确保物品获得的随机性
              const resourcesArray = Object.entries(action.success);
              for (let i = resourcesArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [resourcesArray[i], resourcesArray[j]] = [resourcesArray[j], resourcesArray[i]];
              }

// 遍历随机排序后的资源，获得1种物品
              for (const [resource, amount] of resourcesArray) {
                if (itemsFound < maxItems) { // 100% 几率获得1种资源
                  // 检查资源是否存在
                  if (gameData.resources[resource] && typeof gameData.resources[resource].amount === 'number') {
                    gameData.resources[resource].amount += 1; // 固定获得1个物品
                    gameData.stats.resourcesCollected++; 
                    searchResults.resources[resource] = 1;
                    itemsFound++;
                  } else {
                    console.warn(`资源 ${resource} 不存在或没有 amount 属性`);
                  }
                }
              }
            }



// 搜寻成功，增加搜寻技能经验值
            if (gameData.skills.search) {
              const experienceGain = 1;
              gameData.skills.search.experience = (gameData.skills.search.experience || 0) + experienceGain;
              searchResults.effects.push(`搜寻技能经验 +${experienceGain}`);

// 检查是否升级
              checkSkillLevelUp('search', searchResults);
            }

showNotification('搜寻成功', '你找到了一些有用的物品。' + (searchResults.effects.includes('识别到草药') ? '你识别出了一些草药！' : ''));
            showEventResult('搜寻结果', searchResults);
          } else {
            if (action.failure) {
              for (const [status, amount] of Object.entries(action.failure)) {
                gameData.status[status] = Math.max(0, gameData.status[status] + amount);
                searchResults.status[status] = amount;
              }
            }
            showNotification('搜寻失败', '你在搜寻过程中受伤了。');
            showEventResult('搜寻结果', searchResults);
          }
          break;

case 'loot':
            // 翻垃圾
            // 显示翻垃圾游戏窗口
            showGarbageGame();
            break;

        case 'rest':
          // 休息 (固定获得10血量和10精神)
          const restResults = {
            resources: {},
            status: {}
          };

          // 固定增加10点血量和10点精神值
          gameData.status.health = Math.min(100, gameData.status.health + 10);
          gameData.status.spirit = Math.min(100, gameData.status.spirit + 10);
          restResults.status.health = 10;
          restResults.status.spirit = 10;
          
          showNotification('休息成功', '你得到了充分的休息，健康和精神都有所恢复。');
          showEventResult('休息结果', restResults);
          break;

case 'fasting_day':
          // 放斋日行动 - 总是成功获得斋饭
          const fastingResults = {
            resources: {
              cornbread: 1,
              porridge: 1
            },
            status: {},
            effects: []
          };

// 应用资源获得
          if (gameData.resources.cornbread && typeof gameData.resources.cornbread.amount === 'number') {
            gameData.resources.cornbread.amount += 1;
          } else {
            console.warn('窝窝头资源不存在或没有 amount 属性');
          }
          if (gameData.resources.porridge && typeof gameData.resources.porridge.amount === 'number') {
            gameData.resources.porridge.amount += 1;
          } else {
            console.warn('稀粥资源不存在或没有 amount 属性');
          }

// 标记放斋日已领取
          gameData.fastingDayClaimed = true;

// 放斋日行动会在renderActions函数中自动隐藏，无需手动移除

// 显示获得物品的结果
          showEventResult('放斋日', fastingResults);
          // 重新渲染行动以隐藏已领取的按钮
          renderActions();
          break;

case 'steal':
          // 偷窃
          const stealResults = {
            resources: {},
            status: {},
            effects: []
          };

          // 获取当前位置
          const currentLocation = gameData.locations.find(loc => loc.currentLocation);
          const isRichArea = currentLocation && currentLocation.id === 'rich_area'; // 仍使用ID判断，但显示名称已改为"锣鼓巷"

          // 锣鼓巷偷窃逻辑 - 显示撬锁小游戏
          if (isRichArea) {
            // 显示撬锁小游戏
            showLockpickGame();
            return; // 提前返回，不执行后续逻辑
          }

          // 非锣鼓巷的普通偷窃逻辑
          // 计算偷窃成功率（基础40%）
          const baseStealChance = 0.4;
          // 技能加成：每级+5%成功率
          const skillBonus = gameData.skills.steal.level * 0.05;
          // 偷天换日学习后额外+30%成功率
          const dayStealingBonus = gameData.skills.steal.specialAbilities?.includes('dayStealing') ? 0.3 : 0;
          // "小心一点"buff惩罚：-20%成功率
          const carefulBuffPenalty = gameData.buffs?.careful?.active ? 0.2 : 0;
          // 计算最终成功率，确保不低于0.1
          let totalStealChance = Math.min(0.95, baseStealChance + skillBonus + dayStealingBonus - carefulBuffPenalty);
          totalStealChance = Math.max(0.1, totalStealChance);

          const stealSuccess = Math.random() < totalStealChance;

if (isRichArea) {
            // 锣鼓巷偷窃逻辑 - 只有成功和失败两种结果
            if (stealSuccess) {
              // 偷窃成功，获得物品 - 确保至少获得1件物品

// 锣鼓巷可能出现的物品及其权重（只能获得金条、碎银子或金子）
              const richAreaLootTable = [
                { resource: 'gold_bar', minAmount: 1, maxAmount: 1, weight: 1 },
                { resource: 'silver_piece', minAmount: 1, maxAmount: 1, weight: 2 },
                { resource: 'gold', minAmount: 1, maxAmount: 1, weight: 1 }
              ];

// 加权随机选择物品
              let totalWeight = richAreaLootTable.reduce((sum, item) => sum + item.weight, 0);
              let random = Math.random() * totalWeight;
              let selectedItem = null;

for (const item of richAreaLootTable) {
                random -= item.weight;
                if (random <= 0) {
                  selectedItem = item;
                  break;
                }
              }

// 确保至少获得1件物品
              if (selectedItem && selectedItem.resource in gameData.resources) {
                // 计算物品数量（固定为1个）
                const amount = 1;

// 检查资源对象和amount属性是否存在
                if (gameData.resources[selectedItem.resource] && typeof gameData.resources[selectedItem.resource].amount === 'number') {
                  // 增加玩家资源
                  gameData.resources[selectedItem.resource].amount += amount;
                  stealResults.resources[selectedItem.resource] = amount;

                  // 获取物品名称用于通知
                  const itemName = gameData.resources[selectedItem.resource].name || selectedItem.resource;
                  showNotification('偷窃成功', `你在锣鼓巷成功偷到了 ${amount} 个 ${itemName}！`);
                } else {
                  console.warn(`资源 ${selectedItem.resource} 不存在或没有 amount 属性`);
                }
              } else {
                // 保底逻辑 - 如果以上逻辑失败，至少给1个金币
                if (gameData.resources.money && typeof gameData.resources.money.amount === 'number') {
                  gameData.resources.money.amount += 5;
                  stealResults.resources.money = 5;
                  showNotification('偷窃成功', '你在锣鼓巷成功偷到了 5 个金币！');
                } else {
                  showNotification('偷窃成功', '你在锣鼓巷成功偷到了一些贵重物品！');
                }
              }

// 成功奖励已经在前面的逻辑中处理

// 增加偷窃技能经验 - 成功时增加2点
              if (gameData.skills.steal) {
                const experienceGain = 2;
                gameData.skills.steal.experience = (gameData.skills.steal.experience || 0) + experienceGain;

// 添加经验增加到结果中
                stealResults.effects = stealResults.effects || [];
                stealResults.effects.push(`偷窃技能经验 +${experienceGain}`);

// 检查是否需要升级
                checkSkillLevelUp('steal', stealResults);

updateSkillDisplay(); // 更新技能显示UI
              }
              showEventResult('偷窃成功', stealResults);
            } else {
              // 锣鼓巷偷窃失败 - 直接被抓
              showNotification('偷窃失败', '你在锣鼓巷偷窃时被发现并被巡逻队抓住了！');

// 添加关押信息到事件结果
              stealResults.effects.push('被巡逻队抓住送进牢房，关押4天');

showEventResult('偷窃失败', stealResults);

// 将玩家送往牢房
              sendToPrison();
              return; // 不继续执行后续代码
            }
          } else {
            // 非富人区的普通偷窃逻辑
            if (stealSuccess) {
              // 偷窃成功，不减少声望

// 普通区域可能出现的物品及其权重（只能获得金条、碎银子或金子）
              const commonAreaLootTable = [
                { resource: 'gold_bar', minAmount: 1, maxAmount: 1, weight: 1 },
                { resource: 'silver_piece', minAmount: 1, maxAmount: 1, weight: 2 },
                { resource: 'gold', minAmount: 1, maxAmount: 1, weight: 1 }
              ];

// 加权随机选择物品
              let totalWeight = commonAreaLootTable.reduce((sum, item) => sum + item.weight, 0);
              let random = Math.random() * totalWeight;
              let selectedItem = null;

for (const item of commonAreaLootTable) {
                random -= item.weight;
                if (random <= 0) {
                  selectedItem = item;
                  break;
                }
              }

// 确保至少获得1件物品
              if (selectedItem && selectedItem.resource in gameData.resources) {
                // 计算物品数量（固定为1个）
                const amount = 1;

// 检查资源对象和amount属性是否存在
                if (gameData.resources[selectedItem.resource] && typeof gameData.resources[selectedItem.resource].amount === 'number') {
                  // 增加玩家资源
                  gameData.resources[selectedItem.resource].amount += amount;
                  stealResults.resources[selectedItem.resource] = amount;
                } else {
                  console.warn(`资源 ${selectedItem.resource} 不存在或没有 amount 属性`);
                }
              }

// 增加偷窃技能经验 - 成功时增加2点
              if (gameData.skills.steal) {
                const experienceGain = 2;
                gameData.skills.steal.experience = (gameData.skills.steal.experience || 0) + experienceGain;

// 添加经验增加到结果中
                stealResults.effects = stealResults.effects || [];
                stealResults.effects.push(`偷窃技能经验 +${experienceGain}`);

// 检查是否需要升级
                checkSkillLevelUp('steal', stealResults);

updateSkillDisplay(); // 更新技能显示UI
              }

// 获取物品名称用于通知
              const itemName = selectedItem ? (gameData.resources[selectedItem.resource].name || selectedItem.resource) : '金条';
              showNotification('偷窃成功', `你成功偷到了 ${itemName}！`);
              showEventResult('偷窃成功', stealResults);
            } else {
              // 偷窃失败，有概率被抓
              const caughtChance = 0.7; // 70%概率被抓
              const isCaught = Math.random() < caughtChance;

if (isCaught) {
                // 被抓住，送进牢房
                showNotification('偷窃失败', '你在偷窃时被巡逻士兵发现并被抓住了！');

// 添加关押信息到事件结果
                stealResults.effects.push('被巡逻队抓住送进牢房，关押4天');

showEventResult('偷窃失败', stealResults);

// 将玩家送往牢房
                sendToPrison();
                return; // 不继续执行后续代码
              } else {
                // 没被抓住，但声望降低
                if (action.failure) {
                  for (const [status, amount] of Object.entries(action.failure)) {
                    if (status !== 'reputation') { // 不减少声望
                      gameData.status[status] = Math.max(0, gameData.status[status] + amount);
                      stealResults.status[status] = amount;
                    }
                  }
                }
                // 额外减少声望
                const reputationLoss = -15;
                gameData.status.reputation = Math.max(-49, gameData.status.reputation + reputationLoss);
                stealResults.status.reputation = reputationLoss;

showNotification('偷窃失败', '你在偷窃时差点被发现，侥幸逃脱，但声望降低了。');
                showEventResult('偷窃失败', stealResults);
              }
            }
          }
          break;

case 'donate':
          // 救济
          const donateSuccess = Math.random() > 0.1; // 90% 成功率
          const donateResults = {
            resources: {},
            status: {},
            effects: []
          };

if (donateSuccess) {
            if (action.success) {
              for (const [resource, amount] of Object.entries(action.success)) {
                if (resource in gameData.resources) {
                  gameData.resources[resource].amount += amount;
                  donateResults.resources[resource] = amount;
                } else if (resource in gameData.status) {
                  gameData.status[resource] = Math.min(100, gameData.status[resource] + amount);
                  donateResults.status[resource] = amount;
                }
              }
            }
            showNotification('救济成功', '万佛寺为你提供了食物和住宿，你的健康和精神都有所恢复。');
            showEventResult('救济结果', donateResults);
          } else {
            showNotification('救济失败', '今天万佛寺没有提供救济。');
            showEventResult('救济结果', donateResults);
          }
          break;

case 'pray':
          // 祈福 - 总是成功
          const prayResults = {
            resources: {},
            status: {},
            effects: []
          };

// 祈福总是成功，直接应用成功效果
          if (action.success) {
            for (const [status, amount] of Object.entries(action.success)) {
              gameData.status[status] = Math.min(100, gameData.status[status] + amount);
              prayResults.status[status] = amount;
            }
          }
          showNotification('祈福成功', '你的祈祷得到了回应，身心得到了慰藉。');
          showEventResult('祈福结果', prayResults);
          break;

/* case 'trade':
          // 交易 - 暂时注释掉，后期再补充
          const tradeSuccess = Math.random() > 0.4; // 60% 成功率
          const tradeResults = {
            resources: {},
            status: {},
            effects: []
          };

if (tradeSuccess) {
            if (action.success) {
              for (const [resource, amount] of Object.entries(action.success)) {
                if (gameData.resources[resource] && typeof gameData.resources[resource].amount === 'number') {
                  gameData.resources[resource].amount += amount;
                  tradeResults.resources[resource] = amount;
                } else {
                  console.warn(`资源 ${resource} 不存在或没有 amount 属性`);
                }
              }
            }
            showNotification('交易成功', '你成功与其他乞丐交换了物资。');
            showEventResult('交易结果', tradeResults);
          } else {
            if (action.failure) {
              for (const [resource, amount] of Object.entries(action.failure)) {
                if (gameData.resources[resource] && typeof gameData.resources[resource].amount === 'number') {
                  gameData.resources[resource].amount = Math.max(0, gameData.resources[resource].amount + amount);
                  tradeResults.resources[resource] = amount;
                } else {
                  console.warn(`资源 ${resource} 不存在或没有 amount 属性`);
                }
              }
            }
            showNotification('交易失败', '你在交易中被骗，损失了一些物资。');
            showEventResult('交易结果', tradeResults);
          }
          break; */

case 'learn':
          // 学习
          const learnSuccess = Math.random() > 0.3; // 70% 成功率
          const learnResults = {
            resources: {},
            status: {},
            effects: []
          };

if (learnSuccess) {
            if (action.success) {
              for (const [status, amount] of Object.entries(action.success)) {
                gameData.status[status] = Math.min(100, gameData.status[status] + amount);
                learnResults.status[status] = amount;
              }
            }

// 随机解锁一个未解锁的配方
            const undiscoveredRecipes = gameData.recipes.filter(recipe => !gameData.discoveredRecipes.includes(recipe.id));
            if (undiscoveredRecipes.length > 0) {
              const recipeToDiscover = undiscoveredRecipes[Math.floor(Math.random() * undiscoveredRecipes.length)];
              gameData.discoveredRecipes.push(recipeToDiscover.id);
              gameData.stats.recipesDiscovered++;
              learnResults.effects.push(`解锁了新配方: ${recipeToDiscover.name}`);
              showNotification('学习成功', `你学会了新的制作技能，解锁了${recipeToDiscover.name}的配方！`);
            } else {
              showNotification('学习成功', '你学习了新的技能，声望有所提升。');
            }

showEventResult('学习结果', learnResults);
          } else {
            if (action.failure) {
              for (const [status, amount] of Object.entries(action.failure)) {
                gameData.status[status] = Math.max(0, gameData.status[status] + amount);
                learnResults.status[status] = amount;
              }
            }
            showNotification('学习失败', '你没有学到有用的技能，精神状态下降了。');
            showEventResult('学习结果', learnResults);
          }
          break;

case 'work':
          // 劳作（消耗半天时间，必定成功）
          const workResults = {
            resources: {},
            status: {},
            effects: []
          };

// 消耗半天时间（增加1.5个回合）
          gameData.timeTurns += 1.5;
          advanceTime(); // 检查是否需要推进时间段

// 劳作必定成功
          if (action.success) {
            for (const [resource, amount] of Object.entries(action.success)) {
              if (resource in gameData.resources) {
                gameData.resources[resource].amount += amount;
                workResults.resources[resource] = amount;
              }
            }
          }

showNotification('劳作成功', '你完成了今天的劳动，获得了残羹剩饭。');
          showEventResult('劳作结果', workResults);
          break;

case 'water_tank':
          // 水缸行动
          showWaterTankConfirm();
          break;

      case 'gamble':
          // 赌博
          const gambleSuccess = Math.random() > 0.6; // 40% 成功率
          const gambleResults = {
            resources: {},
            status: {},
            effects: []
          };

if (gambleSuccess) {
            if (action.success) {
              for (const [resource, amount] of Object.entries(action.success)) {
                if (gameData.resources[resource] && typeof gameData.resources[resource].amount === 'number') {
                  gameData.resources[resource].amount += amount;
                  gambleResults.resources[resource] = amount;
                } else {
                  console.warn(`资源 ${resource} 不存在或没有 amount 属性`);
                }
              }
            }

showNotification('赌博成功', '你在赌博中赢了！');
            showEventResult('赌博结果', gambleResults);
          } else {
            if (action.failure) {
              for (const [resource, amount] of Object.entries(action.failure)) {
                if (gameData.resources[resource] && typeof gameData.resources[resource].amount === 'number') {
                  gameData.resources[resource].amount = Math.max(0, gameData.resources[resource].amount + amount);
                  gambleResults.resources[resource] = amount;
                } else if (resource in gameData.status) {
                  gameData.status[resource] = Math.max(0, gameData.status[resource] + amount);
                  gambleResults.status[resource] = amount;
                }
              }
            }

showNotification('赌博失败', '你在赌博中输了，损失了一些钱币，精神状态也下降了。');
            showEventResult('赌博结果', gambleResults);
          }
          break;

case 'buy_goods':
          // 打开黑市货架
          openBlackMarketShelf();
          return; // 不消耗行动点，不结束回合
          break;

case 'buy_slave':
          // 购买奴隶
          const buySlaveResults = {
            resources: {},
            status: {},
            effects: []
          };

// 检查是否有足够的金条
          if (gameData.resources.gold_bar.amount >= 3) {
            // 消耗金条
            gameData.resources.gold_bar.amount -= 3;
            buySlaveResults.resources.gold_bar = -3;

// 添加奴隶
            gameData.resources.slave.amount += 1;
            buySlaveResults.resources.slave = 1;

showNotification('购买成功', '你用3张黄金卡牌购买了一个奴隶！奴隶每天会自动帮你收集资源。');
            showEventResult('购买结果', buySlaveResults);
          } else {
            showNotification('购买失败', '你没有足够的黄金卡牌！需要3张才能购买奴隶。');
            showEventResult('购买结果', buySlaveResults);
          }
          break;

case 'open_black_market_shelf':
          // 打开黑市货架
          openBlackMarketShelf();
          return; // 不结束回合

case 'talk_mystery':
          // 与神秘人对话
          const talkMysteryResults = {
            resources: {},
            status: {},
            effects: []
          };

// 检查是否已经解锁黑市
          const blackMarketLocation = gameData.locations.find(loc => loc.id === 'black_market');
          if (blackMarketLocation && blackMarketLocation.available && gameData.flags.blackMarketUnlocked) {
            showNotification('已解锁黑市', '你已经知道了黑市的消息，可以随时前往。');
            showEventResult('对话结果', talkMysteryResults);
            break;
          }

// 创建对话框，询问是否愿意花费10个钱币获得黑市消息
          elements.eventTitle.textContent = '神秘人的提议';
          elements.eventText.textContent = '「想要知道黑市的位置吗？这可是个秘密，需要花费10个钱币才能告诉你...」';

// 清空并添加选项
          elements.eventOptions.innerHTML = '';

// 同意选项
          const agreeOption = document.createElement('div');
          agreeOption.className = 'event-modal-option';
          agreeOption.innerHTML = `
            <div class="event-modal-option-text">同意花费10个钱币</div>
            <div class="event-modal-option-description">支付10个钱币以获取黑市位置</div>
          `;

agreeOption.addEventListener('click', () => {
            // 检查是否有足够的钱币
            if (gameData.resources.money && typeof gameData.resources.money.amount === 'number' && gameData.resources.money.amount >= 10) {
              // 消耗10个钱币
              gameData.resources.money.amount -= 10;
              talkMysteryResults.resources.money = -10;

// 解锁黑市
              if (blackMarketLocation) {
                blackMarketLocation.available = true;
                // 设置黑市解锁标志
                gameData.flags.blackMarketUnlocked = true;
                talkMysteryResults.effects.push('解锁了黑市地点');
              }

// 重新渲染地点栏，显示黑市
              renderLocations();

showNotification('交易成功', '你支付了10个钱币，神秘人告诉你了黑市的位置。');
              showEventResult('对话结果', talkMysteryResults);

// 更新UI
              renderResources();
              updateGameData();

// 消耗时间
              advanceTime();
            } else {
              // 显示钱币不足的弹窗提示
              showNoMoneyModal();
              // 不再显示对话结果窗口，避免两个窗口同时弹出
            }

elements.eventModal.classList.remove('active');
          });

// 添加拒绝提议按钮
          const closeButton = document.createElement('div');
          closeButton.className = 'event-modal-option';
          closeButton.style.backgroundColor = 'white'; // 白色背景
          closeButton.innerHTML = `
            <div class="event-modal-option-text">拒绝提议</div>
            <div class="event-modal-option-description">不支付钱币，结束对话</div>
          `;

closeButton.addEventListener('click', () => {
            // 直接关闭对话窗口，不显示通知
            closeEventModal();
          });

// 添加同意选项和关闭按钮到选项容器
          elements.eventOptions.appendChild(agreeOption);
          elements.eventOptions.appendChild(closeButton);

// 显示事件模态框
          elements.eventModal.classList.add('active');
          return; // 不结束回合
          break;

case 'craft':
          // 制作
          renderRecipes();
          elements.recipeModal.classList.add('active');
          return; // 不结束回合

case 'get_water':
          // 检查是否满足行动所需的资源（虽然UI上已经控制，但这里再次检查确保安全）
          const waterAction = gameData.actions.find(act => act.id === 'get_water');
          let canPerformWaterAction = true;

if (waterAction && waterAction.requires) {
            for (const [resource, amount] of Object.entries(waterAction.requires)) {
              if (!gameData.resources[resource] || gameData.resources[resource].amount < amount) {
                canPerformWaterAction = false;
                break;
              }
            }
          }

if (canPerformWaterAction) {
            // 显示打水选项弹窗
            showWaterOptionsModal();
          } else {
            showNotification('条件不足', '你没有足够的资源来执行这个行动。');
          }
          return; // 不结束回合，等待用户选择

case 'stream_action':
          // 显示溪边选项弹窗
          showStreamOptionsModal();
          return; // 不结束回合，等待用户选择

case 'mountain_action':
          // 进山行动的实现，50%成功率
          const mountainResults = {
            resources: {},
            status: {},
            effects: []
          };

          const mountainSuccess = Math.random() > 0.5;
          if (mountainSuccess) {
            // 成功时随机获得一种资源
            const rand = Math.random();
            if (rand < 0.4) {
              gameData.resources.herb.amount += 1;
              mountainResults.resources.herb = 1;
              mountainResults.effects.push('找到了一些草药');
            } else if (rand < 0.6) {
              gameData.resources.stick.amount += 1;
              mountainResults.resources.stick = 1;
              mountainResults.effects.push('找到了一根木棍');
            } else if (rand < 0.8) {
              gameData.resources.bamboo.amount = (gameData.resources.bamboo.amount || 0) + 1;
              mountainResults.resources.bamboo = 1;
              mountainResults.effects.push('找到了一根竹子');
            } else {
              gameData.resources.hide.amount += 1;
              mountainResults.resources.hide = 1;
              mountainResults.effects.push('发现了一张兽皮');
            }
          } else {
            // 失败时没有任何收获
            mountainResults.effects.push('一无所获');
          }

// 无论成功与否都消耗健康值
          gameData.status.health = Math.max(0, gameData.status.health - 5);
          checkGameOver(); // 检查游戏是否失败
          mountainResults.status.health = -5;
          mountainResults.effects.push('在山林中行走消耗了体力');

// 保存游戏数据
          updateGameData();

showNotification('进山探索', '你在山林中探索了一番。');
          showEventResult('探索结果', mountainResults);

// 更新UI
          renderResources();
          renderActions();

// 消耗时间
          advanceTime();
          break;

// 打水选项弹窗函数
      function showWaterOptionsModal() {
        // 创建弹窗容器，使用标准样式
        const modalContainer = document.createElement('div');
        modalContainer.className = 'event-modal';
        
        // 创建弹窗内容，使用ink-border样式保持一致性
        const modalContent = document.createElement('div');
        modalContent.className = 'event-modal-content ink-border';
        
        // 创建标题区域
        const modalHeader = document.createElement('div');
        modalHeader.className = 'event-modal-header';
        
        // 创建标题，使用ink-text样式
        const title = document.createElement('h2');
        title.className = 'event-modal-title ink-text';
        title.textContent = '选择喝水方式';
        modalHeader.appendChild(title);
        
        // 创建关闭按钮
        const closeButton = document.createElement('button');
        closeButton.className = 'event-modal-close';
        closeButton.innerHTML = '&times;';
        closeButton.onclick = function() {
          modalContainer.classList.remove('active');
          setTimeout(() => modalContainer.remove(), 300);
        };
        modalHeader.appendChild(closeButton);
        
        modalContent.appendChild(modalHeader);
        
        // 创建内容区域
        const modalBody = document.createElement('div');
        modalBody.className = 'event-modal-body';
        
        // 添加描述
        const description = document.createElement('p');
        description.className = 'event-modal-text';
        description.textContent = '你来到水井边，想要喝点水...';
        modalBody.appendChild(description);

        // 创建按钮容器
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'event-modal-options';

        // 创建用手捧着喝按钮
        const handDrinkButton = document.createElement('button');
        handDrinkButton.className = 'event-modal-option';
        handDrinkButton.innerHTML = `
          <div class="event-modal-option-text">用手捧着喝</div>
          <div class="event-modal-option-description">直接用手捧水喝，可能会弄湿衣服</div>
        `;
        
        handDrinkButton.onclick = function() {
          modalContainer.classList.remove('active');
          setTimeout(() => modalContainer.remove(), 300);
          drinkWaterWithHands();
        };

        // 创建用水袋装按钮
        const waterBagButton = document.createElement('button');
        waterBagButton.className = 'event-modal-option';
        waterBagButton.innerHTML = `
          <div class="event-modal-option-text">用水袋装</div>
          <div class="event-modal-option-description">使用水袋装水，需要先有空水袋</div>
        `;
        
        waterBagButton.onclick = function() {
          modalContainer.classList.remove('active');
          setTimeout(() => modalContainer.remove(), 300);
          
          // 确保水袋资源正确初始化
          ensureWaterBagResources();

          // 检测背包中水袋状态
          const hasEmptyWaterBag = gameData.resources.empty_water_bag && gameData.resources.empty_water_bag.amount > 0;

          // 使用已声明的变量
          const hasFullWaterBag = gameData.resources.water_bag && gameData.resources.water_bag.amount > 0;

          if (hasEmptyWaterBag) {
            // 有空水袋，执行装水逻辑
            fillWaterBag();
          } else if (hasFullWaterBag) {
            // 有水袋（满），显示水袋已满提示
            showWaterBagFullModal();
          } else {
            // 没有水袋，显示提示窗口
            showNoWaterBagModal();
          }
        };

        buttonContainer.appendChild(handDrinkButton);
        buttonContainer.appendChild(waterBagButton);
        
        modalBody.appendChild(buttonContainer);
        modalContent.appendChild(modalBody);
        modalContainer.appendChild(modalContent);
        
        document.body.appendChild(modalContainer);
        
        // 触发动画
        setTimeout(() => modalContainer.classList.add('active'), 10);
        
        // 添加点击背景关闭功能
        modalContainer.onclick = function(e) {
          if (e.target === modalContainer) {
            modalContainer.classList.remove('active');
            setTimeout(() => modalContainer.remove(), 300);
          }
        };
      }

// 溪边选项弹窗函数
      function showStreamOptionsModal() {
        // 创建弹窗容器，使用标准样式
        const modalContainer = document.createElement('div');
        modalContainer.className = 'event-modal';
        
        // 创建弹窗内容，使用ink-border样式保持一致性
        const modalContent = document.createElement('div');
        modalContent.className = 'event-modal-content ink-border';
        
        // 创建标题区域
        const modalHeader = document.createElement('div');
        modalHeader.className = 'event-modal-header';
        
        // 创建标题，使用ink-text样式
        const title = document.createElement('h2');
        title.className = 'event-modal-title ink-text';
        title.textContent = '清澈的溪水';
        modalHeader.appendChild(title);
        
        // 创建关闭按钮
        const closeButton = document.createElement('button');
        closeButton.className = 'event-modal-close';
        closeButton.innerHTML = '&times;';
        closeButton.onclick = function() {
          modalContainer.classList.remove('active');
          setTimeout(() => modalContainer.remove(), 300);
        };
        modalHeader.appendChild(closeButton);
        
        modalContent.appendChild(modalHeader);
        
        // 创建内容区域
        const modalBody = document.createElement('div');
        modalBody.className = 'event-modal-body';
        
        // 添加描述
        const description = document.createElement('p');
        description.className = 'event-modal-text';
        description.textContent = '你来到一条清澈的小溪边，溪水潺潺流动...';
        modalBody.appendChild(description);

        // 创建按钮容器
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'event-modal-options';

        // 创建用手捧着喝按钮
        const handDrinkButton = document.createElement('button');
        handDrinkButton.className = 'event-modal-option';
        handDrinkButton.innerHTML = `
          <div class="event-modal-option-text">用手捧着喝</div>
          <div class="event-modal-option-description">直接用手捧水喝，可能会弄湿衣服</div>
        `;
        
        handDrinkButton.onclick = function() {
          modalContainer.classList.remove('active');
          setTimeout(() => modalContainer.remove(), 300);
          drinkWaterWithHands();
        };

        // 创建用水袋装按钮
        const waterBagButton = document.createElement('button');
        waterBagButton.className = 'event-modal-option';
        waterBagButton.innerHTML = `
          <div class="event-modal-option-text">用水袋装</div>
          <div class="event-modal-option-description">使用水袋装水，需要先有空水袋</div>
        `;
        
        waterBagButton.onclick = function() {
          modalContainer.classList.remove('active');
          setTimeout(() => modalContainer.remove(), 300);
          
          // 确保水袋资源正确初始化
          ensureWaterBagResources();
          
          // 检测背包中水袋状态
          const hasEmptyWaterBag = gameData.resources.empty_water_bag && gameData.resources.empty_water_bag.amount > 0;
          const hasFullWaterBag = gameData.resources.water_bag && gameData.resources.water_bag.amount > 0;

          if (hasEmptyWaterBag) {
            // 有空水袋，执行装水逻辑
            fillWaterBag();
          } else if (hasFullWaterBag) {
            // 有水袋（满），显示水袋已满提示
            showWaterBagFullModal();
          } else {
            // 没有水袋，显示提示窗口
            showNoWaterBagModal();
          }
        };

        // 创建下水摸鱼按钮
        const fishButton = document.createElement('button');
        fishButton.className = 'event-modal-option';
        fishButton.innerHTML = `
          <div class="event-modal-option-text">下水摸鱼</div>
          <div class="event-modal-option-description">下水尝试摸鱼，可能会有收获</div>
        `;
        
        fishButton.onclick = function() {
          modalContainer.classList.remove('active');
          setTimeout(() => modalContainer.remove(), 300);
          catchFishInStream();
        };

        buttonContainer.appendChild(handDrinkButton);
        buttonContainer.appendChild(waterBagButton);
        buttonContainer.appendChild(fishButton);
        
        modalBody.appendChild(buttonContainer);
        modalContent.appendChild(modalBody);
        modalContainer.appendChild(modalContent);
        
        document.body.appendChild(modalContainer);
        
        // 触发动画
        setTimeout(() => modalContainer.classList.add('active'), 10);
        
        // 添加点击背景关闭功能
        modalContainer.onclick = function(e) {
          if (e.target === modalContainer) {
            modalContainer.classList.remove('active');
            setTimeout(() => modalContainer.remove(), 300);
          }
        };
      }

// 更新UI
      renderResources();
      renderActions();
      updateGameData();

// 消耗时间
      advanceTime();
    }

// 用手捧着喝的逻辑
      function drinkWaterWithHands() {
        const getWaterResults = {
          resources: {},
          status: {},
          effects: []
        };

// 补充少量水分，比用碗少一些
        gameData.status.thirst = Math.min(100, gameData.status.thirst + 15); // 增加15点水分值
        getWaterResults.status.thirst = 15;

// 添加行动效果说明
        getWaterResults.effects.push('用手捧着喝了一些水');

// 保存游戏数据
        updateGameData();

showNotification('喝水成功', '你用手捧着喝了一些水，感觉稍微没那么渴了。');
        showEventResult('喝水结果', getWaterResults);

// 更新UI
        renderResources();
        renderActions();

// 消耗时间
        advanceTime();
      }

// 用水袋装水的逻辑
      function fillWaterBag() {
        const getWaterResults = {
          resources: {},
          status: {},
          effects: []
        };

// 确保水袋资源正确初始化
        ensureWaterBagResources();

// 检查是否有水袋（满）
        if (gameData.resources.water_bag && gameData.resources.water_bag.amount > 0) {
          // 显示水袋已满提示
          showWaterBagFullModal();
          return;
        }

// 检查是否有水袋（空）
        if (gameData.resources.empty_water_bag && gameData.resources.empty_water_bag.amount > 0) {
          // 消耗一个水袋（空）
          gameData.resources.empty_water_bag.amount -= 1;
          getWaterResults.resources.empty_water_bag = -1;

// 如果水袋（空）数量为0，保持资源存在但amount为0
          // 增加一个水袋（满）
          gameData.resources.water_bag.amount += 1;
          getWaterResults.resources.water_bag = 1;

// 添加行动效果说明
          getWaterResults.effects.push('将水袋（空）装满了水');

// 保存游戏数据
          updateGameData();

showNotification('装水成功', '你成功将水袋装满了水。');
        } else {
          // 没有水袋（空）
          showNotification('装水失败', '你没有空水袋，无法装水。');
        }

if (getWaterResults.effects.length > 0) {
          showEventResult('装水结果', getWaterResults);
        }

// 更新UI
        renderResources();
        renderActions();

// 消耗时间
        advanceTime();
      }

// 确保水袋资源正确初始化
      function ensureWaterBagResources() {
        // 初始化水袋（空）
        if (!gameData.resources.empty_water_bag) {
          gameData.resources.empty_water_bag = {
            name: '水袋（空）',
            description: '一个空的水袋，可以用来装水',
            amount: 0,
            image: 'UI/水袋（空）.jpg',
            type: 'tool',
            category: 'material',
            id: 'empty_water_bag',
            cannotDrop: false
          };
        }

// 确保水袋（空）的属性正确设置
        gameData.resources.empty_water_bag.name = '水袋（空）';
        gameData.resources.empty_water_bag.category = 'material';
        gameData.resources.empty_water_bag.type = 'container';

// 初始化水袋（满）
        if (!gameData.resources.water_bag) {
          gameData.resources.water_bag = {
            name: '水袋（满）',
            description: '一个装满水的水袋，可以饮用',
            amount: 0,
            image: 'UI/水袋（满）.jpg',
            type: 'consumable',
            category: 'food',
            id: 'water_bag',
            cannotDrop: false,
            // 饮用效果
            useEffect: function() {
              gameData.status.thirst = Math.min(100, gameData.status.thirst + 20); // 增加20点水分值 // 增加20点水分值
              return { thirst: 20 }; // 增加20点水分值 // 增加20点水分값
            }
          };
        }

// 确保水袋（满）的属性正确设置
        gameData.resources.water_bag.name = '水袋（满）';
        gameData.resources.water_bag.category = 'food';
        gameData.resources.water_bag.type = 'consumable';
        // 确保不具有装备属性
        delete gameData.resources.water_bag.equipmentSlot;

// 确保amount是数字类型
        if (typeof gameData.resources.empty_water_bag.amount !== 'number') {
          gameData.resources.empty_water_bag.amount = 0;
        }
        if (typeof gameData.resources.water_bag.amount !== 'number') {
          gameData.resources.water_bag.amount = 0;
        }
      }

// 下水摸鱼的逻辑
      function catchFishInStream() {
        const fishResults = {
          resources: {},
          status: {},
          effects: []
        };

// 确保鱼资源存在
        ensureFishResource();

// 随机判断是否摸到鱼（50%几率）
        const catchSuccess = Math.random() < 0.5;

if (catchSuccess) {
          // 成功摸到鱼
          gameData.resources.fish.amount += 1;
          fishResults.resources.fish = 1;
          fishResults.effects.push('成功摸到一条鱼！');

showNotification('摸鱼成功', '你成功从溪水中摸到一条鱼！');
        } else {
          // 没有摸到鱼
          fishResults.effects.push('这次没有摸到鱼');
          showNotification('摸鱼失败', '你在水中摸索了半天，但没有摸到鱼。');
        }

// 下水摸鱼会消耗体力
        gameData.status.health = Math.max(0, gameData.status.health - 3);
        checkGameOver(); // 检查游戏是否失败
        fishResults.status.health = -3;

// 下水摸鱼无论成功与否都会全身湿透
        if (!gameData.buffs['全身湿透']) {
          gameData.buffs['全身湿透'] = { active: true };
          fishResults.effects.push('你浑身湿透了！');
          showNotification('浑身湿透', '你的衣服被水浸透了，需要烤火取暖。');
        }

// 保存游戏数据
        updateGameData();

showEventResult('摸鱼结果', fishResults);

// 更新UI
        renderResources();
        renderActions();

// 消耗时间
        advanceTime();
      }

// 确保鱼资源正确初始化
      function ensureFishResource() {
        if (!gameData.resources.fish) {
          gameData.resources.fish = {
            name: '鱼',
            description: '新鲜的鱼，可以烹饪后食用',
            amount: 0,
            image: 'UI/鱼.jpg',
            isRaw: true,
            type: 'consumable',
            category: 'food',
            id: 'fish',
            cannotDrop: false,
            // 直接食用生鱼的效果
            useEffect: function() {
              gameData.status.hunger = Math.min(100, gameData.status.hunger + 15);
              gameData.status.health = Math.max(0, gameData.status.health - 10); // 生吃有风险
              checkGameOver(); // 检查游戏是否失败
              return { hunger: 15, health: -10 };
            }
          };
        }

// 确保amount是数字类型
        if (typeof gameData.resources.fish.amount !== 'number') {
          gameData.resources.fish.amount = 0;
        }
      }

// 没有水袋提示弹窗
      function showNoWaterBagModal() {
        // 创建弹窗容器
        const modalContainer = document.createElement('div');
        modalContainer.className = 'modal';
        modalContainer.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 1000;
        `;

        // 创建弹窗内容
        const modalContent = document.createElement('div');
        modalContent.style.cssText = `
          background-color: #f0e6d6;
          padding: 20px;
          border-radius: 8px;
          text-align: center;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
          min-width: 300px;
        `;

        // 添加标题
        const title = document.createElement('h3');
        title.textContent = '无法装水';
        title.style.marginBottom = '15px';
        modalContent.appendChild(title);

        // 添加提示信息
        const message = document.createElement('p');
        message.textContent = '你还没有水袋，无法打水';
        message.style.marginBottom = '20px';
        modalContent.appendChild(message);

        // 创建关闭按钮
        const closeButton = document.createElement('button');
        closeButton.textContent = '关闭';
        closeButton.style.cssText = `
          padding: 8px 16px;
          background-color: #8b5a2b;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 16px;
        `;
        closeButton.onclick = function() {
          modalContainer.remove();
        };

        modalContent.appendChild(closeButton);
        modalContainer.appendChild(modalContent);
        document.body.appendChild(modalContainer);

        // 添加点击背景关闭功能
        modalContainer.onclick = function() {
          modalContainer.remove();
        };

        // 防止点击弹窗内容时触发关闭
        modalContent.onclick = function(e) {
          e.stopPropagation();
        };
      }

// 水袋已满提示弹窗
      function showWaterBagFullModal() {
        // 创建弹窗容器
        const modalContainer = document.createElement('div');
        modalContainer.className = 'modal';
        modalContainer.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 1001; /* 比之前的弹窗层级更高 */
        `;

// 创建弹窗内容
        const modalContent = document.createElement('div');
        modalContent.style.cssText = `
          background-color: #f0e6d6;
          padding: 20px;
          border-radius: 8px;
          text-align: center;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
          min-width: 280px;
        `;

// 添加标题
        const title = document.createElement('h3');
        title.textContent = '提示';
        title.style.marginBottom = '15px';
        modalContent.appendChild(title);

// 添加提示信息
        const message = document.createElement('p');
        message.textContent = '水袋已经装满了，无法继续装水。';
        message.style.marginBottom = '20px';
        modalContent.appendChild(message);

// 创建确定按钮
        const confirmButton = document.createElement('button');
        confirmButton.textContent = '确定';
        confirmButton.style.cssText = `
          padding: 10px 30px;
          background-color: #8b5a2b;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 16px;
        `;

confirmButton.onclick = function() {
          // 移除所有模态窗口
          const allModals = document.querySelectorAll('.modal');
          allModals.forEach(modal => modal.remove());

// 更新UI并消耗时间
          renderResources();
          renderActions();
          advanceTime();
        };

modalContent.appendChild(confirmButton);
        modalContainer.appendChild(modalContent);
        document.body.appendChild(modalContainer);
      }

      // 更新UI
      renderResources();
      renderActions();
      updateGameData();

      // 消耗时间
      advanceTime();
    }

    // 触发随机事件
    function triggerRandomEvent() {
      const event = gameData.events[Math.floor(Math.random() * gameData.events.length)];

elements.eventTitle.textContent = event.name;
      elements.eventText.textContent = event.text;

// 清空并添加选项
      elements.eventOptions.innerHTML = '';

for (const option of event.options) {
        const optionElement = document.createElement('div');
        optionElement.className = 'event-modal-option';

optionElement.innerHTML = `
          <div class="event-modal-option-text">${option.text}</div>
          <div class="event-modal-option-description">${option.description}</div>
        `;

optionElement.addEventListener('click', () => {
          // 应用选项结果
          for (const [resource, amount] of Object.entries(option.result)) {
            if (resource in gameData.resources) {
              gameData.resources[resource].amount = Math.max(0, gameData.resources[resource].amount + amount);
            } else if (resource in gameData.status) {
              gameData.status[resource] = Math.min(100, Math.max(0, gameData.status[resource] + amount));
            }
          }

// 特殊处理：当选择"反抗"选项时，增加武术技能经验值
          if (option.text === '反抗') {
            gameData.skills.martial.experience += 1;
            checkSkillLevelUp('martial');
          }

// 更新UI
          renderResources();
          updateGameData();

elements.eventModal.classList.remove('active');
          endTurn();
        });

elements.eventOptions.appendChild(optionElement);
      }

elements.eventModal.classList.add('active');
    }

    // 显示放斋日提示窗口
    function showFastingDayModal() {
      const modal = document.createElement('div');
      modal.className = 'fasting-day-modal active';
      modal.innerHTML = `
        <div class="fasting-day-modal-content ink-border">
          <h2 class="fasting-day-modal-title ink-text">放斋日通知</h2>
          <div class="ink-decoration">
            <p class="fasting-day-modal-text">今天是万佛寺放斋日，别忘了去领取食物！</p>
          </div>
          <div class="fasting-day-modal-button ink-button ink-button-primary" id="closeFastingDayModal">确定</div>
        </div>
      `;
      
      // 添加CSS样式
      const style = document.createElement('style');
      style.textContent = `
        .fasting-day-modal {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000;
          opacity: 0;
          transition: opacity 0.3s;
          pointer-events: none;
        }
        
        .fasting-day-modal.active {
          opacity: 1;
          pointer-events: all;
        }
        
        .fasting-day-modal-content {
          background-color: #F7FAFC;
          border: 2px solid #38A169;
          border-radius: 0.75rem;
          padding: 2rem;
          max-width: 400px;
          width: 90%;
          text-align: center;
          box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
          transform: translateY(-20px);
          transition: transform 0.3s;
        }
        
        .fasting-day-modal.active .fasting-day-modal-content {
          transform: translateY(0);
        }
        
        .fasting-day-modal-title {
          color: #38A169;
          font-size: 1.5rem;
          font-weight: normal;
          margin-bottom: 1rem;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }
        
        .fasting-day-modal-text {
          color: #4A5568;
          font-size: 1.1rem;
          margin-bottom: 1.5rem;
          line-height: 1.5;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }
        
        .fasting-day-modal-button {
          background-color: #38A169;
          color: white;
          padding: 0.75rem 1.5rem;
          border-radius: 0.375rem;
          cursor: pointer;
          font-weight: normal;
          transition: background-color 0.2s;
          display: inline-block;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }
        
        .fasting-day-modal-button:hover {
          background-color: #2C5282;
        }
      `;
      
      document.body.appendChild(modal);
      document.head.appendChild(style);
      
      // 关闭按钮事件
      const closeButton = document.getElementById('closeFastingDayModal');
      if (closeButton) {
        closeButton.addEventListener('click', function() {
          modal.classList.remove('active');
          setTimeout(function() {
            if (modal.parentNode) {
              modal.parentNode.removeChild(modal);
            }
            if (style.parentNode) {
              style.parentNode.removeChild(style);
            }
          }, 300);
        });
      }
      
      // 点击弹窗外部关闭
      modal.addEventListener('click', function(e) {
        if (e.target === modal) {
          modal.classList.remove('active');
          setTimeout(function() {
            if (modal.parentNode) {
              modal.parentNode.removeChild(modal);
            }
            if (style.parentNode) {
              style.parentNode.removeChild(style);
            }
          }, 300);
        }
      });
    }

    // 显示声望不足模态框
    function showReputationModal(locationName, requiredRep, currentRep) {
      // 检查是否已存在模态框
      const existingModal = document.querySelector('.reputation-modal');
      if (existingModal) {
        return; // 如果已存在，不再创建新的模态框
      }

      const modal = document.createElement('div');
      modal.className = 'reputation-modal active';
      modal.innerHTML = `
        <div class="reputation-modal-content ink-border">
          <h2 class="reputation-modal-title ink-text">声望不足</h2>
          <div class="ink-decoration">
            <p class="reputation-modal-text">声望不足，无法进入${locationName}。需要至少${requiredRep}%声望，你目前只有${currentRep}%。</p>
          </div>
          <div class="reputation-modal-button ink-button ink-button-primary" id="closeReputationModal">确定</div>
        </div>
      `;
      
      // 添加CSS样式
      const style = document.createElement('style');
      style.textContent = `
        .reputation-modal {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000;
          opacity: 0;
          transition: opacity 0.3s;
          pointer-events: none;
        }
        
        .reputation-modal.active {
          opacity: 1;
          pointer-events: all;
        }
        
        .reputation-modal-content {
          background-color: #F7FAFC;
          border: 2px solid #E53E3E;
          border-radius: 0.75rem;
          padding: 2rem;
          max-width: 400px;
          width: 90%;
          text-align: center;
          box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
          transform: translateY(-20px);
          transition: transform 0.3s;
        }
        
        .reputation-modal.active .reputation-modal-content {
          transform: translateY(0);
        }
        
        .reputation-modal-title {
          color: #E53E3E;
          font-size: 1.5rem;
          font-weight: normal;
          margin-bottom: 1rem;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }
        
        .reputation-modal-text {
          color: #4A5568;
          font-size: 1.1rem;
          margin-bottom: 1.5rem;
          line-height: 1.5;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }
        
        .reputation-modal-button {
          background-color: #E53E3E;
          color: white;
          padding: 0.75rem 1.5rem;
          border-radius: 0.375rem;
          cursor: pointer;
          font-weight: normal;
          transition: background-color 0.2s;
          display: inline-block;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }
        
        .reputation-modal-button:hover {
          background-color: #C53030;
        }
      `;
      
      document.body.appendChild(modal);
      document.head.appendChild(style);
      
      // 关闭按钮事件 - 使用事件委托确保只绑定一次
      const closeModal = function() {
        modal.classList.remove('active');
        setTimeout(function() {
          if (modal.parentNode) {
            modal.parentNode.removeChild(modal);
          }
          if (style.parentNode) {
            style.parentNode.removeChild(style);
          }
        }, 300);
      };
      
      // 获取关闭按钮并添加事件
      const closeButton = modal.querySelector('#closeReputationModal');
      if (closeButton) {
        closeButton.addEventListener('click', closeModal);
      }
      
      // 点击弹窗外部关闭
      modal.addEventListener('click', function(e) {
        if (e.target === modal) {
          closeModal();
        }
      });
    }
    
    // 送进牢房
    function sendToPrison() {
      // 获取当前地点
      const currentLocation = gameData.locations.find(loc => loc.currentLocation);

if (currentLocation) {
        currentLocation.currentLocation = false;
      }

// 找到牢房地点并设置为当前地点
      const prisonLocation = gameData.locations.find(loc => loc.id === 'prison');
      if (prisonLocation) {
        prisonLocation.currentLocation = true;
        prisonLocation.available = true;

// 设置刑期（4天）
        prisonLocation.sentenceDays = 4;

// 显示被捕通知
        showNotification('被捕入狱', `你因偷窃被抓，被判处监禁4天！`);

// 减少健康和精神
        gameData.status.health -= 20;
        checkGameOver(); // 检查游戏是否失败
        gameData.status.spirit -= 30;

// 更新UI
        renderLocations();
        renderActions();
        updateGameData();
      }
    }

// 推进时间
    function advanceTime() {
      const timeOrder = ['early_morning', 'morning', 'afternoon', 'evening', 'night'];
      const currentTimeIndex = timeOrder.indexOf(gameData.timeOfDay);

// 增加当前时间段的回合数
      gameData.timeTurns++;

// 每个回合结束时，应用BUFF效果和夜晚降温逻辑
      processBuffs();
      
      // 篝火燃料每回合减少5
      if (gameData.resources.fire && gameData.resources.fire.amount > 0) {
        gameData.resources.fire.fuel = Math.max(0, gameData.resources.fire.fuel - 5);
        
        // 如果燃料耗尽，篝火熄灭
        if (gameData.resources.fire.fuel <= 0) {
          // 记录耐久度
          const durability = gameData.resources.fire.durability;
          // 移除篝火
          gameData.resources.fire.amount = 0;
          // 添加熄灭的篝火
          if (!gameData.resources.fire_extinguished) {
            gameData.resources.fire_extinguished = { name: '篝火（灭）', amount: 0, image: 'UI/篝火（灭）.jpg', durability: durability, category: 'material' };
          }
          gameData.resources.fire_extinguished.amount = 1;
          gameData.resources.fire_extinguished.durability = durability;
          
          showNotification('篝火熄灭', '你的篝火燃料已经耗尽，篝火熄灭了。');
          
          // 更新资源显示
          renderResources();
        }
      }
      
      // 检查游戏是否失败
      checkGameOver();
      
      // 更新状态显示
      updateGameData();

// 如果当前时间段已进行3个回合，切换到下一个时间段
      if (gameData.timeTurns >= 3) {
        const nextTimeIndex = (currentTimeIndex + 1) % timeOrder.length;
        gameData.timeOfDay = timeOrder[nextTimeIndex];
        gameData.timeTurns = 0; // 重置回合数
        
        // 每个时间段结束时，饱食、水分、精神值下降5
        gameData.status.hunger = Math.max(0, gameData.status.hunger - 5);
        gameData.status.thirst = Math.max(0, gameData.status.thirst - 5); // 减少5点水分值（水分消耗）
        gameData.status.spirit = Math.max(0, gameData.status.spirit - 5);

// 如果时间从晚上变为清晨，增加一天
        if (gameData.timeOfDay === 'early_morning' && timeOrder[currentTimeIndex] === 'night') {
          gameData.day++;

// 生成新一天的天气
          generateWeather();

// 检查BUFF是否过期
          if (gameData.buffs && gameData.buffs.careful && gameData.buffs.careful.active) {
            if (gameData.day > gameData.buffs.careful.endDay) {
              gameData.buffs.careful.active = false;
              showNotification('BUFF消失', '"小心一点"状态效果已过期。');
            }
          }

// 重置放斋日领取状态 (仅在新的放斋日周期开始时重置)
          if ((gameData.day - 2) % 4 === 0) {
            gameData.fastingDayClaimed = false;
            showFastingDayModal(); // 在清晨自动弹出放斋日提示窗口
          }

// 重置行动点为满值
          gameData.status.actionPoints = 20;

// 检查是否在牢房中
            const prisonLocation = gameData.locations.find(loc => loc.id === 'prison');
            if (prisonLocation && prisonLocation.currentLocation) {
              // 减少刑期
              prisonLocation.sentenceDays--;

if (prisonLocation.sentenceDays <= 0) {
                // 刑期结束，释放出狱
                releaseFromPrison();
              } else {
                // 显示剩余刑期通知，剩余1天显示为"最后一天"
                const daysMessage = prisonLocation.sentenceDays === 1 ? '最后一天' : `${prisonLocation.sentenceDays}天`;
                showNotification('刑期通知', `你还需要在牢房中度过${daysMessage}。`);

// 在牢房中每天减少健康和精神
                gameData.status.health -= 5;
                checkGameOver(); // 检查游戏是否失败
                gameData.status.spirit -= 5;
              }
            }

// 更新季节（基于天数计算）
          const previousSeason = gameData.season;
          gameData.season = calculateSeason(gameData.day);
          
          // 只有当季节实际变化时才显示通知
          if (previousSeason !== gameData.season) {
            const seasonNames = {
              spring: '春季',
              summer: '夏季',
              autumn: '秋季',
              winter: '冬季'
            };
            showNotification('季节变化', `现在是${seasonNames[gameData.season]}了。`);
          }

// 根据季节消耗资源
          switch (gameData.season) {
            case 'spring':
              gameData.status.hunger = Math.max(0, gameData.status.hunger - 5);  // 饱食度减少
              gameData.status.cold = Math.min(42, gameData.status.cold + 0.1);    // 体温适中（春季温暖）
              break;
            case 'summer':
              gameData.status.hunger = Math.max(0, gameData.status.hunger - 8);  // 饱食度减少更多
              gameData.status.cold = Math.min(42, gameData.status.cold + 0.3);   // 体温升高（夏季炎热）
              gameData.status.health = Math.max(0, gameData.status.health - 3);  // 夏季容易生病
              checkGameOver(); // 检查游戏是否失败
              break;
            case 'autumn':
              gameData.status.hunger = Math.max(0, gameData.status.hunger - 7);  // 饱食度减少
              gameData.status.cold = Math.max(34, gameData.status.cold - 0.1);    // 体温降低（秋季凉爽）
              break;
            case 'winter':
              gameData.status.hunger = Math.max(0, gameData.status.hunger - 10); // 饱食度减少最多
              gameData.status.cold = Math.max(34, gameData.status.cold - 0.3);   // 体温降低（冬季寒冷）
              gameData.status.health = Math.max(0, gameData.status.health - 5);  // 冬季容易生病
              checkGameOver(); // 检查游戏是否失败
              break;
          }

// 应用BUFF效果
          if (gameData.buffs) {
            // 其他BUFF效果处理可以在这里添加
          }

// 物品耐久度减少
          decreaseItemDurability();

// 奴隶自动收集资源
          if (gameData.resources.slave.amount > 0) {
            const slaveResults = {
              resources: {},
              status: {},
              effects: []
            };

// 每个奴隶每天随机收集一些资源
            for (let i = 0; i < gameData.resources.slave.amount; i++) {
              const resources = ['food', 'money', 'cloth', 'stick', 'black_cloth', 'thread'];
              const resource = resources[Math.floor(Math.random() * resources.length)];
              const amount = Math.floor(Math.random() * 2) + 1; // 1-2个资源

gameData.resources[resource].amount += amount;
              slaveResults.resources[resource] = (slaveResults.resources[resource] || 0) + amount;
            }

// 显示奴隶收集资源的通知
            if (Object.keys(slaveResults.resources).length > 0) {
              let message = `你的${gameData.resources.slave.amount}个奴隶为你收集了：`;
              for (const [resource, amount] of Object.entries(slaveResults.resources)) {
                message += `${gameData.resources[resource].name}x${amount}，`;
              }
              message = message.slice(0, -1) + '。';

showNotification('奴隶的收获', message);
              showEventResult('奴隶收获', slaveResults);
            }
          }

// 不再显示新的一天通知
        } else {
          // 根据时间段显示不同的通知
          const timeMessages = {
            early_morning: '清晨',
            morning: '上午',
            afternoon: '下午',
            evening: '傍晚',
            night: '夜晚'
          };

// 不再显示时间流逝通知
        }
      } else {
        // 根据时间段显示不同的通知
        const timeMessages = {
          early_morning: '清晨',
          morning: '上午',
          afternoon: '下午',
          evening: '傍晚',
          night: '夜晚'
        };

// 不再显示时间流逝通知
      }

// 无限模式 - 移除所有游戏结束条件
      // 状态值不会导致游戏结束，但会影响游戏体验
      // 保持状态值在合理范围内
      gameData.status.health = Math.max(1, Math.min(100, gameData.status.health));
      gameData.status.hunger = Math.max(0, Math.min(99, gameData.status.hunger));
      gameData.status.cold = Math.max(34, Math.min(42, gameData.status.cold));
      gameData.status.spirit = Math.max(1, Math.min(100, gameData.status.spirit));
      gameData.status.reputation = Math.max(-49, Math.min(99, gameData.status.reputation));

// 更新UI
      updateGameData();
      renderActions();

return false;
    }

// 打开黑市货架
    function openBlackMarketShelf() {
      // 创建货架弹窗
      const shelfModal = document.createElement('div');
      shelfModal.className = 'shelf-modal';
      shelfModal.id = 'blackMarketShelfModal';
      shelfModal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #1A202C;
        border: 2px solid #4A5568;
        border-radius: 1rem;
        padding: 2rem;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.4), 0 10px 10px -5px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        width: 90%;
        max-width: 900px;
        max-height: 85vh;
        overflow-y: auto;
        transition: all 0.3s ease;
        background-image: linear-gradient(135deg, #1A202C 0%, #2D3748 100%);
      `;

// 货架商品列表
      const shelfItems = [
        { id: 'medicine', name: '灵药', price: 1, description: '珍贵的草药，能恢复大量健康' },
        { id: 'house_deed', name: '房屋地契', price: 1, description: '拥有自己的房产，提高声望和精神状态', special: true },
        { id: 'fine_clothes', name: '精美华服', price: 1, description: '华丽的服装，大幅提高声望和保暖度' },
        { id: 'silk_shoes', name: '缎鞋', price: 1, description: '精致的缎面鞋子，提高声望和健康' },
        { id: 'dog_beating_stick', name: '打狗棒法', price: 1, description: '丐帮绝技，提高战斗力和声望', special: true },
        { id: 'herbal_manual', name: '本草纲目', price: 1, description: '医学经典，提高健康恢复速度', special: true },
        { id: 'huangdi_canon', name: '黄帝内经', price: 1, description: '医学经典，大幅提高健康上限', special: true },
        { id: 'stealth_book', name: '偷天换日', price: 1, description: '盗窃技巧，提高偷窃成功率', special: true }
      ];

// 弹窗内容
      shelfModal.innerHTML = `
        <div class="shelf-modal-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid #4A5568;">
          <h3 style="font-size: 1.5rem; font-weight: 700; color: #EDF2F7; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);">黑市货架</h3>
          <button id="closeShelfButton" class="ink-button ink-button-small" style="width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center;">&times;</button>
        </div>
        <div class="shelf-modal-body">
          <div class="current-gold" style="margin-bottom: 1.5rem; text-align: center; font-size: 1.25rem; font-weight: 600; color: #E2E8F0;">
            <span style="background: linear-gradient(45deg, #D69E2E, #FBBF24); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-weight: bold;">💰</span> 当前金条: <span id="currentGoldAmount" style="font-weight: bold; color: #D69E2E;">${gameData.resources.gold_bar.amount}</span> 根
          </div>
          <div class="shelf-items" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 1.5rem;">
            ${shelfItems.map(item => {
              const resource = gameData.resources[item.id];
              return `
                <div class="shelf-item" style="background-color: #2D3748; border: 1px solid #4A5568; border-radius: 0.75rem; padding: 1.25rem; display: flex; flex-direction: column; align-items: center; text-align: center; transition: all 0.3s ease; transform: translateY(0); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);">
                  <div class="item-image" style="width: 120px; height: 120px; margin-bottom: 0.75rem; background-color: #1A202C; border: 2px solid #4A5568; border-radius: 0.5rem; overflow: hidden; display: flex; align-items: center; justify-content: center;">
                    <img src="${resource ? resource.image : ''}" alt="${resource ? resource.name : item.name}" style="width: 100%; height: 100%; object-fit: contain; padding: 8px;">
                  </div>
                  <div class="item-name" style="font-weight: 700; margin-bottom: 0.5rem; color: #EDF2F7; font-size: 1.1rem;">${resource ? resource.name : item.name}</div>
                  <div class="item-description" style="font-size: 0.875rem; color: #A0AEC0; margin-bottom: 0.75rem; line-height: 1.4; min-height: 40px;">${resource ? resource.description : item.description}</div>
                  <div class="item-price" style="font-weight: 700; color: #FBBF24; margin-bottom: 1rem; font-size: 1.1rem; display: flex; align-items: center; gap: 4px;">
                    <span>💰</span> 价格: ${item.price} 金条
                  </div>
                  <button class="buy-button ink-button ink-button-small" data-item="${item.id}" data-price="${item.price}" ${item.special && resource.amount > 0 ? 'disabled' : ''}>
                    ${item.special && resource.amount > 0 ? '已购买' : '购买'}
                  </button>
                </div>
              `;
            }).join('')}
          </div>
        </div>
      `;

// 添加到文档
      document.body.appendChild(shelfModal);

      // 添加关闭按钮事件和悬停效果
      const closeButton = document.getElementById('closeShelfButton');
      closeButton.addEventListener('click', function() {
        // 添加关闭动画
        shelfModal.style.opacity = '0';
        shelfModal.style.transform = 'translate(-50%, -50%) scale(0.95)';
        setTimeout(() => {
          if (shelfModal.parentNode === document.body) {
            document.body.removeChild(shelfModal);
          }
        }, 200);
      });

      // 添加点击任意位置关闭窗口的事件
      shelfModal.addEventListener('click', function(e) {
        if (e.target === shelfModal) {
          // 添加关闭动画
          shelfModal.style.opacity = '0';
          shelfModal.style.transform = 'translate(-50%, -50%) scale(0.95)';
          setTimeout(() => {
            if (shelfModal.parentNode === document.body) {
              document.body.removeChild(shelfModal);
            }
          }, 200);
        }
      });

closeButton.addEventListener('mouseover', function() {
        this.style.backgroundColor = '#718096';
      });

closeButton.addEventListener('mouseout', function() {
        this.style.backgroundColor = '#4A5568';
      });

// 添加商品卡片悬停效果
      const shelfItemElements = shelfModal.querySelectorAll('.shelf-item');
      shelfItemElements.forEach(item => {
        item.addEventListener('mouseover', function() {
          this.style.transform = 'translateY(-5px)';
          this.style.boxShadow = '0 10px 15px -3px rgba(0, 0, 0, 0.4), 0 4px 6px -2px rgba(0, 0, 0, 0.25)';
          this.style.borderColor = '#63B3ED';
        });

item.addEventListener('mouseout', function() {
          this.style.transform = 'translateY(0)';
          this.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.3)';
          this.style.borderColor = '#4A5568';
        });
      });

// 添加购买按钮悬停效果
      const buyButtons = shelfModal.querySelectorAll('.buy-button:not(:disabled)');
      buyButtons.forEach(button => {
        button.addEventListener('mouseover', function() {
          this.style.backgroundColor = '#9F7AEA';
          this.style.transform = 'scale(1.05)';
        });

button.addEventListener('mouseout', function() {
          this.style.backgroundColor = '#805AD5';
          this.style.transform = 'scale(1)';
        });
      });

// 添加购买按钮事件
      const allBuyButtons = shelfModal.querySelectorAll('.buy-button');
      allBuyButtons.forEach(button => {
        button.addEventListener('click', function() {
          const itemId = this.getAttribute('data-item');
          const price = parseInt(this.getAttribute('data-price'));

// 检查是否有足够的金条
          if (gameData.resources.gold_bar.amount >= price) {
            // 消耗金条
            gameData.resources.gold_bar.amount -= price;

          // 添加商品到背包
            gameData.resources[itemId].amount += 1;

// 特殊学习物品已在定义中设置了cannotDrop属性，确保购买限制正确应用
            // 所有特殊学习物品在货架上只能购买一次
            
            // 如果是特殊商品，更新按钮状态
            const shelfItem = shelfItems.find(item => item.id === itemId);
            if (shelfItem && shelfItem.special) {
              // 更新按钮文本和禁用状态
              button.textContent = '已购买';
              button.disabled = true;
              button.style.backgroundColor = '#4A5568';
            }

// 更新金币显示
            const currentGoldAmountElement = document.getElementById('currentGoldAmount');
            if (currentGoldAmountElement) currentGoldAmountElement.textContent = gameData.resources.gold_bar.amount;

// 更新背包UI
            renderResources();
            updateResourceCard('gold_bar');

// 显示购买成功通知
            showNotification('购买成功', `你用${price}张金条购买了${gameData.resources[itemId].name}！`);
            // 显示更醒目的购买成功弹窗
            showPurchaseResult('购买成功', `你用${price}张金条购买了${gameData.resources[itemId].name}！`, true);

// 检查是否是灵药，如果是，确保有durability属性
            if (itemId === 'medicine') {
              if (!('durability' in gameData.resources.medicine)) {
                gameData.resources.medicine.durability = 100;
              }
            }
          } else {
            // 显示金条不足通知
            showNotification('购买失败', `你没有足够的金条！需要${price}根，你只有${gameData.resources.gold_bar.amount}根。`);
            // 显示更醒目的购买失败弹窗
            showPurchaseResult('购买失败', `你没有足够的金条！需要${price}根，你只有${gameData.resources.gold_bar.amount}根。`, false);
          }
        });
      });

// 点击弹窗外部关闭
      shelfModal.addEventListener('click', function(e) {
        if (e.target === shelfModal && shelfModal.parentNode === document.body) {
          document.body.removeChild(shelfModal);
        }
      });
    }

// 从牢房释放
    function releaseFromPrison() {
      // 获取牢房地点
      const prisonLocation = gameData.locations.find(loc => loc.id === 'prison');

if (prisonLocation) {
        prisonLocation.currentLocation = false;
        prisonLocation.available = false;

// 将玩家送回东西市
        const streetLocation = gameData.locations.find(loc => loc.id === 'street');
        if (streetLocation) {
          streetLocation.currentLocation = true;
        }

// 减少声望
        gameData.status.reputation -= 20;

// 添加"小心一点"buff（持续2天）
        gameData.buffs.careful = {
          active: true,
          startDay: gameData.day,
          endDay: gameData.day + 2,
          description: '刑满释放后状态，偷窃成功率-20%'
        };

// 更新UI
        renderLocations();
        renderActions();
        updateGameData();

// 显示刑满释放弹窗
        showReleaseModal();
      }
    }

// 显示刑满释放弹窗
    function showReleaseModal() {
      const modal = document.createElement('div');
      modal.className = 'release-modal active';
      modal.innerHTML = `
        <div class="release-modal-content ink-border">
          <h2 class="release-modal-title ink-text">刑满释放</h2>
          <div class="ink-decoration">
            <p class="release-modal-text">你的刑期已满，被释放出狱！</p>
            <p class="release-modal-text">由于你的犯罪记录，声望降低了20点。</p>
            <p class="release-modal-text">出去之后一定要好好做人！获得"小心一点"BUFF</p>
          </div>
          <div class="release-modal-button ink-button ink-button-primary" id="closeReleaseModal">继续</div>
        </div>
      `;

document.body.appendChild(modal);

// 添加样式
      const style = document.createElement('style');
      style.textContent = `
        .release-modal {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 500;
          opacity: 0;
          pointer-events: none;
          transition: opacity 0.3s ease;
        }

.release-modal.active {
          opacity: 1;
          pointer-events: auto;
        }

.release-modal-content {
          background-color: #fff;
          padding: 20px;
          border-radius: 8px;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
          max-width: 400px;
          width: 90%;
          text-align: center;
          background-image: url('UI/监狱.png');
          background-size: cover;
          background-position: center;
          color: #ff0000;
          font-weight: normal;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }

.release-modal-title {
          font-size: 24px;
          margin-bottom: 10px;
          color: #ff0000;
          font-weight: normal;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }

.release-modal-text {
          font-size: 16px;
          margin-bottom: 15px;
          line-height: 1.5;
          color: #ff0000;
          font-weight: normal;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }

.release-modal-button {
          background-color: #8B0000;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 4px;
          cursor: pointer;
          font-size: 16px;
          margin-top: 10px;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
        }

.release-modal-button:hover {
          background-color: #B22222;
        }
      `;

document.head.appendChild(style);

// 添加关闭按钮事件
      const closeReleaseModal = document.getElementById('closeReleaseModal');
      if (closeReleaseModal) {
        closeReleaseModal.addEventListener('click', () => {
          modal.classList.remove('active');
          setTimeout(() => {
            if (modal.parentNode === document.body) {
        document.body.removeChild(modal);
      }
      if (style.parentNode === document.head) {
        document.head.removeChild(style);
      }
          }, 300);
        });
      }
    }

// 检查并移除过期的buff
    function checkAndRemoveExpiredBuffs() {
      if (!gameData.buffs) return;

for (const [buffId, buff] of Object.entries(gameData.buffs)) {
        if (buff.active && buff.endDay && buff.endDay <= gameData.day) {
          // 移除过期的buff
          buff.active = false;
          showNotification('状态消失', `${buff.description || buffId}效果已结束。`);
        }
      }
    }

// 结束回合（现在改为推进时间）
    function endTurn() {
      // 检查过期buff
      checkAndRemoveExpiredBuffs();

// 随机触发事件
      if (Math.random() > 0.7) {
        triggerRandomEvent();
      } else {
        advanceTime();
      }
    }

    // 游戏结束
    function gameOver(message, isVictory = false) {
      // 无限模式 - 游戏不会结束，只显示通知
      showNotification(isVictory ? '里程碑达成' : '警告', message);
    }

    // 返回开始界面处理函数 - 增强版
    // 添加状态标志防止重复调用
    let isReturningToStart = false;

// 添加全局错误处理，捕获未处理的异常
    window.addEventListener('error', function(event) {
      console.error('未捕获的全局错误:', event.error);
      // 显示错误信息（如果有具体错误信息）
      if (event.error && event.error.message) {
        showErrorDisplay(event.error.message);
      } else if (event.message) {
        showErrorDisplay(event.message);
      }
      
      // 确保状态标志被重置，防止界面卡住
      if (isReturningToStart) {
        isReturningToStart = false;
        console.warn('已重置返回开始界面状态标志');
      }
    });

    // 错误信息仅记录到控制台，不显示在页面上
    function showErrorDisplay(message) {
      console.error('游戏错误:', message);
    }

function handleBackToStart() {
      // 防止重复调用
      if (isReturningToStart) {
        console.warn('返回开始界面操作正在进行中，忽略重复调用');
        return;
      }

// 确保document和body存在，防止在极端情况下出错
      if (!document || !document.body) {
        console.error('文档对象不存在，无法执行返回开始界面操作');
        alert('系统错误：无法访问页面元素');
        return;
      }

// 只有在用户确认后才执行操作
      if(confirm('确定要返回开始界面吗？当前未保存的进度将会丢失。')) {
        isReturningToStart = true;
        console.log('开始返回开始界面处理...');

try {
          // 1. 清理旧的事件监听器和定时器，防止内存泄漏
          console.log('执行清理操作...');
          // 清除可能存在的游戏定时器和其他循环引用
          if (window.gameInterval) {
            clearInterval(window.gameInterval);
            window.gameInterval = null;
            console.log('游戏定时器已清除');
          }

// 清理可能存在的其他循环引用
          if (window.gameLoop) {
            if (typeof window.gameLoop === 'function') {
              try {
                window.gameLoop = null;
                console.log('游戏循环函数已清理');
              } catch (e) {
                console.warn('清理游戏循环函数失败:', e);
              }
            }
          }

// 2. 确保DOM元素存在并正确处理
          console.log('检查DOM元素...');
          let startScreenElement = null;
          let gameContainerElement = null;

try {
            startScreenElement = document.getElementById('startScreen');
            gameContainerElement = document.getElementById('gameContainer');
          } catch (domError) {
            console.error('获取DOM元素时出错:', domError);
          }

// 强制检查并处理DOM元素 - 优化版本
          if (!startScreenElement) {
            console.error('严重错误: 开始界面元素不存在！创建临时元素');
            try {
              // 创建一个更完善的临时开始界面，避免完全清空body
              startScreenElement = document.createElement('div');
              startScreenElement.id = 'startScreen';
              startScreenElement.className = 'start-screen';
              startScreenElement.style.display = 'flex';
              startScreenElement.style.position = 'fixed';
              startScreenElement.style.top = '0';
              startScreenElement.style.left = '0';
              startScreenElement.style.width = '100%';
              startScreenElement.style.height = '100%';
              startScreenElement.style.zIndex = '9999';
              startScreenElement.style.backgroundColor = '#f0e6d2';
              startScreenElement.style.color = '#333';
              startScreenElement.style.flexDirection = 'column';
              startScreenElement.style.alignItems = 'center';
              startScreenElement.style.justifyContent = 'center';
              startScreenElement.innerHTML = `
                <div class="start-screen-content" style="text-align: center; padding: 2rem;">
                  <h1 class="start-screen-title ink-text" style="font-size: 2.5em; margin-bottom: 20px;">乞丐求生</h1>
                  <p class="start-screen-subtitle" style="font-size: 1.2em; margin-bottom: 30px;">水墨画风格的卡牌生存游戏</p>
                  <p class="start-screen-description" style="max-width: 600px; margin-bottom: 30px;">
                    在这个残酷的古代世界中，你扮演一名乞丐，挣扎求生。通过收集资源、制作工具、探索地点和应对事件，努力活下去并寻找改变命运的机会。
                  </p>
                  <button id="startButton" class="start-screen-button ink-button ink-button-primary" style="font-size: 1.2em;">
                    开始游戏
                  </button>
                </div>
              `;

// 添加到body而不是清空body
              document.body.appendChild(startScreenElement);
              console.log('临时开始界面已创建');
            } catch (createError) {
              console.error('创建临时开始界面失败:', createError);
              // 即使创建失败也继续执行，尝试其他恢复方法
            }
          } else {
            // 显示开始界面并隐藏游戏容器
            try {
              startScreenElement.style.display = 'flex';
              console.log('开始界面显示成功');
            } catch (styleError) {
              console.error('设置开始界面样式失败:', styleError);
            }
          }

if (gameContainerElement) {
            try {
              gameContainerElement.style.display = 'none';
              console.log('游戏容器隐藏成功');
            } catch (styleError) {
              console.error('设置游戏容器样式失败:', styleError);
            }
          } else {
            console.warn('游戏容器元素未找到，可能已隐藏');
          }

// 3. 完整重置游戏数据
          try {
            console.log('重置游戏数据...');
            // 尝试重新初始化gameData
            if (typeof resetGame === 'function') {
              try {
                console.log('调用resetGame函数重置游戏');
                resetGame();
              } catch (resetFuncError) {
                console.error('调用resetGame函数失败:', resetFuncError);
                // 重置失败时进行手动重置
                performManualGameReset();
              }
            } else {
              console.log('resetGame函数不存在，手动重置基本数据');
              performManualGameReset();
            }

// 尝试调用initGame重新初始化
            if (typeof initGame === 'function') {
              console.log('尝试调用initGame函数重新初始化游戏');
              try {
                initGame();
              } catch(initError) {
                console.warn('initGame调用失败，但不影响返回开始界面:', initError);
              }
            }
          } catch(resetError) {
            console.error('重置游戏数据时出错:', resetError);
          }

// 4. 添加开始游戏函数的替代实现
          // 如果startGame函数不存在，则创建它
          if (typeof window.startGame !== 'function') {
            console.log('创建临时的startGame函数替代实现');
            window.startGame = function() {
              console.log('临时startGame函数被调用');
              try {
                // 隐藏开始界面
                const startScreen = document.getElementById('startScreen');
                if (startScreen) {
                  startScreen.style.display = 'none';
                }

// 显示游戏容器
                const gameContainer = document.getElementById('gameContainer');
                if (gameContainer) {
                  gameContainer.style.display = 'block';
                } else {
                  console.error('游戏容器元素不存在');
                  alert('游戏初始化失败：未找到游戏容器');
                  return;
                }

// 尝试重新初始化游戏
                if (typeof resetGame === 'function') {
                  try {
                    resetGame();
                  } catch (e) {
                    console.error('重置游戏失败:', e);
                    performManualGameReset();
                  }
                } else {
                  performManualGameReset();
                }

if (typeof initGame === 'function') {
                  try {
                    initGame();
                  } catch (e) {
                    console.error('初始化游戏失败:', e);
                    // 尝试基本显示逻辑
                    performBasicGameRender();
                  }
                } else {
                  console.warn('initGame函数不存在，游戏可能无法正常运行');
                  performBasicGameRender();
                }
              } catch (error) {
                console.error('游戏启动过程中出错:', error);
                alert('游戏启动失败：' + error.message);
              }
            };
          }

// 5. 重新绑定开始游戏事件
          setTimeout(() => {
            try {
              // 确保startScreenElement仍然存在
              if (!startScreenElement) {
                startScreenElement = document.getElementById('startScreen');
              }

if (startScreenElement) {
                const startGameButton = document.querySelector('#startScreen button, #startButton');
                if (startGameButton) {
                  // 移除旧的事件监听器
                  const newButton = startGameButton.cloneNode(true);
                  startGameButton.parentNode.replaceChild(newButton, startGameButton);

// 添加新的事件监听器，直接调用window.startGame（我们刚刚确保它存在）
                  newButton.onclick = function() {
                    console.log('开始游戏按钮被点击');
                    // 再次确认startGame函数存在
                    if (typeof window.startGame === 'function') {
                      window.startGame();
                    } else {
                      console.error('严重错误：startGame函数不存在');
                      alert('游戏功能不可用，请刷新页面');
                    }
                  };
                  console.log('开始游戏按钮事件已重新绑定');
                } else {
                  console.warn('未找到开始游戏按钮，创建一个');
                  try {
                    const button = document.createElement('button');
                    button.textContent = '开始游戏';
                    button.style.padding = '10px 20px';
                    button.onclick = function() {
                      if (typeof window.startGame === 'function') {
                        window.startGame();
                      } else {
                        alert('游戏功能暂不可用，请刷新页面');
                      }
                    };
                    startScreenElement.appendChild(button);
                  } catch (createButtonError) {
                    console.error('创建开始游戏按钮失败:', createButtonError);
                  }
                }
              } else {
                console.error('开始界面元素不存在，无法绑定事件');
              }
            } catch(bindError) {
              console.error('绑定开始游戏事件失败:', bindError);
            } finally {
              // 操作完成，重置状态标志
              isReturningToStart = false;
              console.log('返回开始界面处理完成，状态标志已重置');
            }
          }, 300);

} catch(error) {
          console.error('返回开始界面过程中发生严重错误:', error);
          // 确保状态标志被重置
          isReturningToStart = false;

// 显示一个基本的恢复界面，但不使用innerHTML覆盖整个body
          try {
            const recoveryDiv = document.createElement('div');
            recoveryDiv.style.position = 'fixed';
            recoveryDiv.style.top = '0';
            recoveryDiv.style.left = '0';
            recoveryDiv.style.width = '100%';
            recoveryDiv.style.height = '100%';
            recoveryDiv.style.backgroundColor = '#f0e6d2';
            recoveryDiv.style.color = '#333';
            recoveryDiv.style.textAlign = 'center';
            recoveryDiv.style.padding = '50px';
            recoveryDiv.style.zIndex = '99999';
            recoveryDiv.style.boxSizing = 'border-box';
            recoveryDiv.innerHTML = '<h1>出现问题</h1>' +
              '<p>返回开始界面时出错: ' + (error.message || '未知错误') + '</p>' +
              '<button onclick="location.reload()" class="ink-button ink-button-primary" style="margin-top: 20px;">刷新页面重试</button>';
            document.body.appendChild(recoveryDiv);
          } catch (recoveryError) {
            console.error('创建恢复界面失败:', recoveryError);
            // 最后手段：尝试使用alert通知用户
            alert('严重错误：无法显示恢复界面，请手动刷新页面');
          }
        }
      }
      // 点击取消时不执行任何操作，直接返回
      console.log('用户取消返回开始界面操作');
    }

    // 更新组合槽显示
    function updateCombinationSlots() {
      try {
        const slots = document.querySelectorAll('#combinationSlots .combination-slot');
        
        slots.forEach(slot => {
          const slotNumber = slot.getAttribute('data-slot');
          const resourceId = gameData.combinationSlots[slotNumber];
          
          slot.innerHTML = '';
          
          if (resourceId) {
            const resource = gameData.resources[resourceId];
            const resourceCard = document.createElement('div');
            resourceCard.className = 'card resource combination-card';
            
            resourceCard.innerHTML = `
              <div class="card-image" style="background-image: url('${resource.image}'); background-size: cover; background-position: center;"></div>
              <div class="card-content">
                <div class="card-title">${resource.name}</div>
              </div>
            `;
            
            slot.appendChild(resourceCard);
          }
        });
        debugLog('组合槽已更新');
      } catch (error) {
        console.error('更新组合槽时出错:', error);
      }
    }

// 辅助函数：手动重置游戏数据
    function performManualGameReset() {
      try {
        // 确保window对象存在
        if (!window) {
          console.error('window对象不存在，无法重置游戏数据');
          return;
        }

// 保存原始地点数据，如果存在的话
        let originalLocations = null;
        if (typeof gameData !== 'undefined' && gameData.locations) {
          originalLocations = JSON.parse(JSON.stringify(gameData.locations));
        }
        
        // 确保gameData存在并完全重置
        window.gameData = {
          day: 1,
          timeOfDay: 'early_morning',
          timeTurns: 0,
          season: 'spring',
          status: {
            hunger: 50,
            cold: 36.5,
            health: 80,
            spirit: 70,
            reputation: 20
          },
          discoveredRecipes: [],
          combinationSlots: {
            1: null,
            2: null
          },
          stats: {},
          gameOver: false,
          resources: {},
          locations: []
        };
        
        // 重置地点，确保东西市是当前地点
        // 使用原始地点数据，但重置状态
        if (originalLocations) {
          window.gameData.locations = originalLocations.map(location => {
            const newLocation = { ...location };
            newLocation.currentLocation = false;
            // 重置牢房的刑期
            if (newLocation.id === 'prison') {
              newLocation.sentenceDays = 0;
            }
            return newLocation;
          });
          
          // 设置东西市为当前地点
          const dongxishi = window.gameData.locations.find(loc => loc.id === 'street');
          if (dongxishi) {
            dongxishi.currentLocation = true;
          }
        }
        console.log('游戏数据已手动重置');
      } catch (e) {
        console.error('手动重置游戏数据失败:', e);
      }
    }

// 辅助函数：执行基本的游戏渲染
    function performBasicGameRender() {
      try {
        // 尝试调用可能存在的渲染函数
        const renderFunctions = [
          { name: 'renderResources', func: renderResources },
          { name: 'renderLocations', func: renderLocations },
          { name: 'renderActions', func: renderActions },
          { name: 'updateGameData', func: updateGameData },
          { name: 'updateStatusDisplay', func: updateStatusDisplay }
        ];

renderFunctions.forEach(({ name, func }) => {
          if (typeof func === 'function') {
            try {
              func();
              console.log(`成功调用${name}函数`);
            } catch (e) {
              console.warn(`调用${name}函数失败，但继续尝试其他渲染函数:`, e);
            }
          }
        });
      } catch (e) {
        console.error('执行基本游戏渲染失败:', e);
      }
    }

    // 重置游戏
    function resetGame() {
      gameData.day = 1;
      gameData.timeOfDay = 'early_morning';
      gameData.timeTurns = 0;
      gameData.season = calculateSeason(gameData.day);
      gameData.resources = {
        'cangenshengfan': { name: '残羹剩饭', description: '乞讨或搜寻获得的食物残渣，虽然能增加饱食度，但可能影响健康', amount: 0, image: 'UI/残羹剩饭.jpg', type: 'consumable', category: 'food' },
        'money': { name: '钱币', amount: 0, image: 'UI/钱币.jpg' },
        'cloth': { name: '破布', amount: 0, image: 'UI/破布.jpg' },
        'stick': { name: '木棍', amount: 0, image: 'UI/木棍.jpg' },
        'paper': { name: '废纸', amount: 0, image: 'UI/废纸.jpg' },
        'bowl': { name: '破碗', amount: 1, image: 'UI/破碗.jpg' },
        'medicine': { name: '灵药', description: '珍贵的草药，能恢复大量健康', amount: 0, image: 'UI/灵药.jpg', type: 'consumable' },
        'house_deed': { name: '房屋地契', description: '拥有一处房产的证明，提升声望和精神状态', amount: 1, image: 'UI/房屋地契.jpg', durability: 100, category: 'other' },
        'fine_clothes': { name: '精美华服', description: '高档的丝绸服装，大幅提升声望和保暖度', amount: 0, image: 'UI/精美华服.jpg', equipmentSlot: 'clothes', durability: 100, category: 'equipment' },
        'silk_shoes': { name: '缎鞋', description: '精致的丝缎鞋子，提升健康度和保暖度', amount: 0, image: 'UI/缎鞋.jpg', equipmentSlot: 'shoes', durability: 100, category: 'equipment' },
        'dog_beating_stick': { name: '打狗棒法', description: '丐帮镇帮之宝，提升健康度和声望', amount: 0, image: 'UI/打狗棒法.jpg', equipmentSlot: 'weapon', durability: 100, category: 'other' },
        'herbal_manual': { name: '本草纲目', description: '古代医学名著，提升健康度和精神状态', amount: 0, image: 'UI/本草纲目.jpg', durability: 100, category: 'other' },
        'huangdi_canon': { name: '黄帝内经', description: '中医经典著作，大幅提升健康度', amount: 0, image: 'UI/黄帝内经.jpg', durability: 100, category: 'other' },
        'stealth_book': { name: '偷天换日', description: '盗窃技巧秘籍，提高偷窃成功率', amount: 0, image: 'UI/偷天换日.jpg', durability: 100, category: 'other' },
        'herbal_medicine_book': { name: '本草纲目', description: '医学经典，提高健康恢复速度', amount: 0, image: 'UI/本草纲目.jpg', equipmentSlot: 'special', category: 'other' },
        'huangdi_neijing': { name: '黄帝内经', description: '医学经典，大幅提高健康上限', amount: 0, image: 'UI/黄帝内经.jpg', equipmentSlot: 'special', category: 'other' },
        'simple_clothes': { name: '破衣服', amount: 0, image: 'UI/破衣服.jpg', equipmentSlot: 'clothes', durability: 100, category: 'equipment' },
        'flint': { name: '燧石', amount: 0, image: 'UI/燧石.jpg' },
        'mud': { name: '泥巴', amount: 0, image: 'UI/泥巴.jpg' },
        'fire': { name: '篝火', amount: 0, image: 'UI/篝火.jpg', durability: 100, fuel: 100 },
        'fire_extinguished': { name: '篝火（灭）', amount: 0, image: 'UI/篝火（灭）.jpg', durability: 100, category: 'material' },
        'clay_bowl': { name: '泥碗', amount: 0, image: 'UI/泥碗.jpg' },
        'crutch': { name: '拐杖', amount: 0, image: 'UI/拐杖.jpg', equipmentSlot: 'weapon', durability: 100, category: 'equipment' },
        'gold_bar': { name: '金条', amount: 0, image: 'UI/金条.jpg' },
        'black_cloth': { name: '黑布', amount: 0, image: 'UI/黑布.jpg' },
        'hide': { name: '兽皮', description: '动物的皮毛，可以用来制作保暖衣物和容器', amount: 0, image: 'UI/兽皮.jpg' },
        'thread': { name: '线团', amount: 0, image: 'UI/线团.jpg' },
        'water_bag': { name: '水袋（满）', description: '可以储存水分，补充身体水分', amount: 0, image: 'UI/水袋（满）.jpg', durability: 100 },
        'empty_water_bag': { name: '水袋（空）', description: '空的水袋，需要寻找水源来装满它', amount: 0, image: 'UI/水袋（空）.jpg', durability: 100 },
        'black_cloak': { name: '黑色斗篷', amount: 0, image: 'UI/黑色斗篷.jpg', equipmentSlot: 'special', durability: 100, category: 'equipment' },
        'slave': { name: '奴隶', amount: 0, image: 'UI/奴隶.jpg' },
        'shoes': { name: '破鞋', description: '破旧的鞋子，提供基本的脚部保护', amount: 0, image: 'UI/破鞋.jpg', equipmentSlot: 'shoes', durability: 100, category: 'equipment' },
        'ornate_shoes': { name: '锦履', description: '华丽的锦缎鞋子，大幅提升声望和健康度', amount: 0, image: 'UI/锦履.jpg', equipmentSlot: 'shoes', durability: 100, category: 'equipment' },
        'cornbread': { name: '窝窝头', description: '粗糙的谷物制品，能提供较好的饱腹感', amount: 0, image: 'UI/窝窝头.jpg', type: 'consumable', category: 'food' },
        'porridge': { name: '稀粥', description: '清淡的粥品，容易消化，提供基本的饱腹感', amount: 0, image: 'UI/稀粥.jpg', type: 'consumable', category: 'food' },

        'day_stealing': { name: '偷天换日', description: '神秘的盗窃技巧秘籍，提升偷窃成功率', amount: 0, image: 'UI/偷天换日.jpg' }
      };
      gameData.status = {
        hunger: 100, // 初始饱食度为100（满值）
        cold: 36.5, // 初始体温保持不变
        health: 100, // 初始健康度为100（满值）
        spirit: 100, // 初始精神值为100（满值）
        blood: 100, // 初始血量为100（满值）
        reputation: 0, // 初始声望保持不变
        strength: 50,
        isSick: false,
        thirst: 100, // 初始水分为100（满值）
        actionPoints: 20 // 初始行动点为20（满值）
      };
      gameData.discoveredRecipes = [];
      gameData.combinationSlots = {
        1: null,
        2: null,
        3: null
      };
      gameData.stats = {
        daysSurvived: 0,
        maxReputation: 0,
        resourcesCollected: 0,
        recipesDiscovered: 0
      };
      gameData.gameOver = false;

      // 重置地点，确保东西市是当前地点
      if (gameData.locations) {
        gameData.locations.forEach(location => {
          location.currentLocation = false;
          // 重置牢房的刑期
          if (location.id === 'prison') {
            location.sentenceDays = 0;
          }
        });
        // 设置东西市为当前地点
        const dongxishi = gameData.locations.find(loc => loc.id === 'street');
        if (dongxishi) {
          dongxishi.currentLocation = true;
        }
      }

// 清空组合槽
      updateCombinationSlots();
      
      // 重置所有状态和BUFF
      gameData.buffs = {};
    }

    // 关闭事件模态框
    function closeEventModal() {
      elements.eventModal.classList.remove('active');
    }

    // 显示通知
    function showNotification(title, message, isCentral = false, manualCloseOnly = false) {
      // 只显示中央通知，非中央通知不显示
      if (!isCentral) {
        return;
      }

      elements.notificationTitle.textContent = title;
      elements.notificationMessage.textContent = message;

      // 清除之前的类和事件监听器
      elements.notification.classList.remove('active', 'central');

      // 根据isCentral参数决定是否使用中央显示
      if (isCentral) {
        elements.notification.classList.add('central');
      }

      // 先触发重排，确保样式生效
      void elements.notification.offsetHeight;

      // 显示通知 - 使用active类来触发CSS动画
      elements.notification.classList.add('active');

// 点击"知道了"按钮关闭
      function closeNotification() {
        elements.notification.classList.remove('active', 'central');
      }

// 添加事件监听器
      elements.closeNotificationButton.addEventListener('click', closeNotification);
      elements.notificationOKButton.addEventListener('click', closeNotification);

// 如果不是手动关闭模式，添加自动关闭和点击外部关闭功能
      if (!manualCloseOnly) {
        // 点击通知外部区域关闭
        document.addEventListener('click', function(e) {
          if (e.target === elements.notification) {
            closeNotification();
          }
        });

// 3秒后自动关闭
        setTimeout(() => {
          elements.notification.classList.remove('active', 'central');
        }, 3000);
      }
    }

    // 显示行动点不足提示窗口
    function showActionPointsModal() {
      const modal = document.getElementById('actionPointsModal');
      if (modal) {
        modal.style.display = 'flex';
      }
    }

    // 关闭行动点不足提示窗口
    function closeActionPointsModal() {
      const modal = document.getElementById('actionPointsModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    // 点击进入下一天并关闭提示窗口
    function endDayFromActionPointsModal() {
      closeActionPointsModal();
      // 调用结束一天的功能
      goToNextDay();
    }

// 已删除时间提示函数

// 显示购买结果弹窗
    function showPurchaseResult(title, message, isSuccess) {
      // 创建模态框
      const purchaseModal = document.createElement('div');
      purchaseModal.className = 'purchase-result-modal';
      purchaseModal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1500;
        animation: fadeIn 0.3s ease;
      `;

// 弹窗内容
      const modalContent = document.createElement('div');
      modalContent.className = 'purchase-result-content';
      modalContent.style.cssText = `
        background-color: ${isSuccess ? '#1A202C' : '#2D3748'};
        border: 2px solid ${isSuccess ? '#38A169' : '#E53E3E'};
        border-radius: 1rem;
        padding: 2rem;
        text-align: center;
        max-width: 400px;
        width: 90%;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.4), 0 10px 10px -5px rgba(0, 0, 0, 0.2);
        animation: slideIn 0.3s ease;
        background-image: linear-gradient(135deg, ${isSuccess ? '#1A202C 0%, #2D3748 100%' : '#2D3748 0%, #1A202C 100%'});
      `;

// 标题
      const modalTitle = document.createElement('h3');
      modalTitle.className = 'purchase-result-title';
      modalTitle.style.cssText = `
        font-size: 1.5rem;
        font-weight: normal;
        color: ${isSuccess ? '#38A169' : '#E53E3E'};
        margin-bottom: 1rem;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      `;
      modalTitle.textContent = title;

// 消息
      const modalMessage = document.createElement('p');
      modalMessage.className = 'purchase-result-message';
      modalMessage.style.cssText = `
        font-size: 1.1rem;
        color: #EDF2F7;
        margin-bottom: 1.5rem;
        line-height: 1.6;
      `;
      modalMessage.textContent = message;

// 图标
      const iconContainer = document.createElement('div');
      iconContainer.style.cssText = `
        font-size: 3rem;
        margin-bottom: 1rem;
      `;
      iconContainer.textContent = isSuccess ? '✓' : '✗';

// 确认按钮
      const confirmButton = document.createElement('button');
      confirmButton.className = 'purchase-result-button';
      confirmButton.style.cssText = `
        background-color: ${isSuccess ? '#38A169' : '#E53E3E'};
        color: white;
        border: none;
        border-radius: 0.5rem;
        padding: 0.75rem 2rem;
        font-size: 1rem;
        font-weight: normal;
        cursor: pointer;
        transition: all 0.3s ease;
      `;
      confirmButton.textContent = '确认';

// 添加悬停效果
      confirmButton.addEventListener('mouseover', function() {
        this.style.transform = 'translateY(-2px)';
        this.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.3)';
      });

confirmButton.addEventListener('mouseout', function() {
        this.style.transform = 'translateY(0)';
        this.style.boxShadow = 'none';
      });

// 关闭弹窗
      confirmButton.addEventListener('click', function() {
        purchaseModal.style.animation = 'fadeOut 0.3s ease';
        modalContent.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => {
          if (purchaseModal.parentNode === document.body) {
            document.body.removeChild(purchaseModal);
          }
        }, 300);
      });

// 添加点击外部关闭
      purchaseModal.addEventListener('click', function(e) {
        if (e.target === purchaseModal) {
          purchaseModal.style.animation = 'fadeOut 0.3s ease';
          modalContent.style.animation = 'slideOut 0.3s ease';
          setTimeout(() => {
            if (purchaseModal.parentNode === document.body) {
              document.body.removeChild(purchaseModal);
            }
          }, 300);
        }
      });

// 组装弹窗
      modalContent.appendChild(iconContainer);
      modalContent.appendChild(modalTitle);
      modalContent.appendChild(modalMessage);
      modalContent.appendChild(confirmButton);
      purchaseModal.appendChild(modalContent);

// 添加动画样式
      const style = document.createElement('style');
      style.textContent = `
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes fadeOut {
          from { opacity: 1; }
          to { opacity: 0; }
        }
        @keyframes slideIn {
          from { transform: translateY(-50px) scale(0.9); opacity: 0; }
          to { transform: translateY(0) scale(1); opacity: 1; }
        }
        @keyframes slideOut {
          from { transform: translateY(0) scale(1); opacity: 1; }
          to { transform: translateY(50px) scale(0.9); opacity: 0; }
        }
      `;
      document.head.appendChild(style);

// 添加到页面
      document.body.appendChild(purchaseModal);
    }

// 显示事件结果提示
    function showEventResult(title, results) {
      // 创建结果详情字符串
      let details = '';

// 添加资源变化
      if (results.resources && Object.keys(results.resources).length > 0) {
        details += '<div class="event-result-section"><ul class="event-result-list">';
        for (const [resource, amount] of Object.entries(results.resources)) {
          if (amount > 0) {
            const resourceName = gameData.resources[resource].name;
            details += `<li>+${amount} ${resourceName}</li>`;
          }
        }
        details += '</ul></div>';
      }

// 添加状态变化
      if (results.status && Object.keys(results.status).length > 0) {
        details += '<div class="event-result-section"><strong>状态变化：</strong><ul class="event-result-list">';
        const statusNames = {
          hunger: '饱食',
          cold: '寒冷',
          health: '健康',
          spirit: '精神',
          reputation: '声望'
        };

for (const [status, amount] of Object.entries(results.status)) {
          const statusName = statusNames[status] || status;
          const changeSign = amount >= 0 ? '+' : '';
          details += `<li>${statusName}: ${changeSign}${amount}%</li>`;
        }
        details += '</ul></div>';
      }

// 添加特殊效果
      if (results.effects && results.effects.length > 0) {
        details += '<div class="event-result-section"><strong>特殊效果：</strong><ul class="event-result-list">';
        for (const effect of results.effects) {
          details += `<li>${effect}</li>`;
        }
        details += '</ul></div>';

// 检查是否解锁了黑市地点，如果是，添加额外提示
        if (results.effects.includes('解锁了黑市地点')) {
          details += '<div class="event-result-section">你需要穿戴黑衣斗篷，才能进入黑市，黑衣斗篷的配方是：2个黑布加1个线团</div>';
        }
      }

// 如果没有找到任何物品且是搜寻结果，显示特定文字
      if (title === '搜寻结果' && (!results.resources || Object.keys(results.resources).length === 0)) {
        // 如果details不为空（有状态变化或特殊效果），则在其前面添加文字
        if (details) {
          details = '<div class="event-result-empty">你的运气似乎不太好哦，啥也没翻到！嘻嘻~</div><br/>' + details;
        } else {
          details = '<div class="event-result-empty">你的运气似乎不太好哦，啥也没翻到！嘻嘻~</div>';
        }
      }

// 如果没有乞讨到任何物品且是乞讨结果，显示特定文字
      if (title === '乞讨结果' && (!results.resources || Object.keys(results.resources).length === 0)) {
        // 如果details不为空（有状态变化或特殊效果），则在其前面添加文字
        if (details) {
          details = '<div class="event-result-empty">路人嫌弃的上下看了看你，紧忙往前走了！哈哈，你啥也没有讨到。</div><br/>' + details;
        } else {
          details = '<div class="event-result-empty">路人嫌弃的上下看了看你，紧忙往前走了！哈哈，你啥也没有讨到。</div>';
        }
      }

// 创建模态框
      const eventResultModal = document.createElement('div');
      eventResultModal.className = 'event-result-modal';
      eventResultModal.innerHTML = `
        <div class="event-result-modal-content ink-border">
          <div class="event-result-modal-header">
            <h3 class="event-result-modal-title ink-text">${title}</h3>
            <button class="event-result-modal-close ink-button ink-button-small">&times;</button>
          </div>
          <div class="event-result-modal-body">
            ${details}
          </div>
          <div class="event-result-modal-footer">
            <button class="event-result-modal-confirm ink-button-carved ink-button-primary">我知道了</button>
          </div>
        </div>
      `;

document.body.appendChild(eventResultModal);

// 添加关闭按钮事件
      const closeButton = eventResultModal.querySelector('.event-result-modal-close');
      closeButton.addEventListener('click', () => {
        eventResultModal.classList.add('closing');
        setTimeout(() => {
          if (eventResultModal.parentNode === document.body) {
            document.body.removeChild(eventResultModal);
          }
        }, 300);
      });

// 添加"我知道了"按钮事件
      const confirmButton = eventResultModal.querySelector('.event-result-modal-confirm');
      confirmButton.addEventListener('click', () => {
        eventResultModal.classList.add('closing');
        setTimeout(() => {
          if (eventResultModal.parentNode === document.body) {
            document.body.removeChild(eventResultModal);
          }
        }, 300);
      });

// 添加点击任意位置关闭
      eventResultModal.addEventListener('click', (e) => {
        if (e.target === eventResultModal) {
          eventResultModal.classList.add('closing');
          setTimeout(() => {
            if (eventResultModal.parentNode === document.body) {
              document.body.removeChild(eventResultModal);
            }
          }, 300);
        }
      });

// 添加active类以显示弹窗（通过setTimeout确保DOM已经准备好）
      setTimeout(() => {
        eventResultModal.classList.add('active');
      }, 10);
    }

    // 显示成就
    function showAchievement(title, description) {
      elements.achievementTitle.textContent = title;
      elements.achievementDescription.textContent = description;

elements.achievementModal.classList.add('active');

setTimeout(() => {
        elements.achievementModal.classList.remove('active');
      }, 7000);
    }

// 减少物品耐久度
    function decreaseItemDurability() {
      const results = {
        resources: {},
        status: {},
        effects: []
      };

// 遍历所有资源，减少耐久度
      for (const [id, resource] of Object.entries(gameData.resources)) {
        // 只处理有耐久度属性的物品
        if (resource.durability !== undefined && resource.amount > 0) {
          // 每天减少2点耐久度
          resource.durability -= 2;

// 如果耐久度降至0或以下，物品损坏
          if (resource.durability <= 0) {
            // 记录损坏的物品
            results.resources[id] = -resource.amount;

// 检查物品是否正在装备中
            if (resource.equipped) {
              // 移除装备效果
              applyEquipmentEffect(id, 'unequip');
              // 移除装备状态
              resource.equipped = false;
              results.effects.push(`你的${resource.name}损坏了，已自动卸下。`);
            }

// 移除损坏的物品
            if (resource && typeof resource.amount === 'number') {
              resource.amount = 0;
            } else {
              console.warn('资源对象不存在或没有 amount 属性');
            }
            resource.durability = 100; // 重置耐久度，以便下次制作时使用
          }
        }
      }

// 如果有物品损坏，显示通知
      if (Object.keys(results.resources).length > 0) {
        let message = '物品损坏：';
        for (const [resource, amount] of Object.entries(results.resources)) {
          message += `${gameData.resources[resource].name}x${Math.abs(amount)}，`;

// 更新损坏物品的显示
          updateResourceCard(resource);
        }
        message = message.slice(0, -1) + '。';

showNotification('物品损坏', message);
      }
    }

// 竹弓使用时消耗耐久度
    function decreaseBambooBowDurability() {
      const bambooBow = gameData.resources.bamboo_bow;
      if (bambooBow && bambooBow.equipped && bambooBow.durability !== undefined) {
        // 每次使用消耗2点耐久度
        bambooBow.durability -= 2;

// 如果耐久度降至0或以下，物品损坏
        if (bambooBow.durability <= 0) {
          // 移除装备效果
          applyEquipmentEffect('bamboo_bow', 'unequip');
          // 移除装备状态
          bambooBow.equipped = false;
          // 移除损坏的物品
          bambooBow.amount = 0;
          bambooBow.durability = 100; // 重置耐久度，以便下次制作时使用
          showNotification('装备损坏', '你的竹弓耐久度耗尽，已损坏并自动卸下。');
        } else if (bambooBow.durability <= 20) {
          // 耐久度低时提醒
          showNotification('耐久度警告', `竹弓耐久度已低至${bambooBow.durability}%，请注意！`);
        }

// 更新UI
        updateResourceCard('bamboo_bow');
      }
    }

// 显示钱币不足弹窗
// 制作窗口功能
    const craftingModal = document.getElementById('craftingModal');
    const craftingButton = document.getElementById('craftingButton');
    const closeCraftingModal = document.getElementById('closeCraftingButton');
    const craftingInventory = document.getElementById('craftingInventory');
    const craftingSlots = document.querySelectorAll('#craftingModal .crafting-slot');
    const craftingCombineButton = document.getElementById('craftButton');
    const craftingRecipeButton = document.getElementById('craftRecipeButton');

// 制作窗口的组合槽数据
    const craftingSlotsData = {1: null, 2: null, 3: null};

// 打开制作窗口
    craftingButton.addEventListener('click', function() {
      craftingModal.classList.add('active');
      renderCraftingInventory();
      updateCraftingSlots();
    });

// 关闭制作窗口
    closeCraftingModal.addEventListener('click', function() {
      craftingModal.classList.remove('active');
      clearCraftingSlots();
    });

// 点击窗口外部关闭
    craftingModal.addEventListener('click', function(e) {
      if (e.target === craftingModal) {
        craftingModal.classList.remove('active');
        clearCraftingSlots();
      }
    });

// 渲染制作窗口的左侧卡牌列表
    function renderCraftingInventory() {
      craftingInventory.innerHTML = '';

// 获取所有数量大于0的资源
      const ownedResources = [];
      for (const [id, resource] of Object.entries(gameData.resources)) {
        if (resource.amount > 0) {
          ownedResources.push({ id, resource });
        }
      }

// 创建卡牌元素
      ownedResources.forEach(({ id, resource }) => {
        const card = document.createElement('div');
        card.className = 'crafting-inventory-card';
        card.dataset.resourceId = id;

card.innerHTML = `
          <div class="crafting-card-image" style="background-image: url('${resource.image}');"></div>
          <div class="crafting-card-title">${resource.name}</div>
          <div class="crafting-card-count">x${resource.amount}</div>
        `;

// 添加点击事件
        card.addEventListener('click', function() {
          addToCraftingSlot(id);
        });

craftingInventory.appendChild(card);
      });
    }

// 将卡牌添加到制作窗口的组合槽
    function addToCraftingSlot(resourceId) {
      // 检查背包中是否有足够的资源
      if (gameData.resources[resourceId].amount <= 0) {
        return;
      }

// 寻找第一个空槽位
      for (const slotNumber in craftingSlotsData) {
        if (craftingSlotsData[slotNumber] === null) {
          craftingSlotsData[slotNumber] = resourceId;
          // 减少背包中的资源数量
          if (gameData.resources[resourceId] && typeof gameData.resources[resourceId].amount === 'number') {
            gameData.resources[resourceId].amount--;
          } else {
            console.warn(`资源 ${resourceId} 不存在或没有 amount 属性`);
          }
          break;
        }
      }

// 重新渲染制作窗口的左侧卡牌列表（数量变化后可能需要隐藏某些卡牌）
      renderCraftingInventory();
      updateCraftingSlots();
      checkCraftingCombination();
    }

// 更新制作窗口的组合槽显示
    function updateCraftingSlots() {
      craftingSlots.forEach(slot => {
        const slotNumber = slot.getAttribute('data-slot');
        const resourceId = craftingSlotsData[slotNumber];

slot.innerHTML = '';

if (resourceId) {
          const resource = gameData.resources[resourceId];
          const resourceCard = document.createElement('div');
          resourceCard.className = 'card resource combination-card';

resourceCard.innerHTML = `
            <div class="card-image" style="background-image: url('${resource.image}'); background-size: cover; background-position: center;">
            </div>
            <div class="card-content">
              <div class="card-title">${resource.name}</div>
            </div>
          `;

// 添加点击事件移除卡牌
          resourceCard.addEventListener('click', function(e) {
            e.stopPropagation();
            // 将资源放回背包
            gameData.resources[resourceId].amount++;
            // 清空槽位
            craftingSlotsData[slotNumber] = null;
            // 重新渲染左侧卡牌列表和右侧槽位
            renderCraftingInventory();
            updateCraftingSlots();
            checkCraftingCombination();
          });

slot.appendChild(resourceCard);
        }
      });
    }

// 更新单个资源卡牌的显示
    function updateResourceCard(resourceId) {
      const resourceCards = document.querySelectorAll('.resource-card');
      resourceCards.forEach(card => {
        if (card.getAttribute('data-resource') === resourceId) {
          const resource = gameData.resources[resourceId];
          const titleElement = card.querySelector('.card-title');
          if (titleElement) {
            titleElement.textContent = `${resource.name}x${resource.amount || 0}`;
          }
          
          // 更新已穿戴标识
          const equippedBadge = card.querySelector('.equipped-badge');
          if (resource.equipmentSlot) {
            if (resource.equipped) {
              // 如果已穿戴但标识不存在，添加标识
              if (!equippedBadge) {
                const imageContainer = card.querySelector('.card-image');
                if (imageContainer) {
                  const badge = document.createElement('div');
                  badge.className = 'equipped-badge';
                  badge.style.cssText = 'position: absolute; bottom: 0.25rem; right: 0.25rem; background-color: #38A169; color: white; border-radius: 4px; padding: 0.1rem 0.3rem; font-size: 0.6rem; font-weight: normal; font-family: "HuiWenMingChaoTi", "FangSong", "仿宋", serif !important; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2); z-index: 10;';
                  badge.textContent = '已穿戴';
                  imageContainer.appendChild(badge);
                }
              }
            } else {
              // 如果未穿戴但标识存在，移除标识
              if (equippedBadge) {
                equippedBadge.remove();
              }
            }
          } else {
            // 如果不是装备，移除标识
            if (equippedBadge) {
              equippedBadge.remove();
            }
          }
          
          // 如果数量为0，移除卡牌
          if (resource.amount <= 0 && !resource.cannotDrop) {
            card.remove();
          }
        }
      });
    }

// 检查是否可以烹饪食物
    function canCookWithFire(foodId) {
      // 检查是否有篝火
      if (!gameData.resources.fire || gameData.resources.fire.amount <= 0) {
        return false;
      }
      
      // 检查食物是否为生食
      const food = gameData.resources[foodId];
      return food && (food.isRaw === true || foodId === 'raw_meat' || foodId === 'fish');
    }
    
    // 处理篝火烹饪
    function cookWithFire(foodId) {
      if (!canCookWithFire(foodId)) {
        showNotification('烹饪失败', '你需要篝火来烹饪食物，或者该食物不能烹饪。');
        return;
      }
      
      let cookedFoodId = null;
      
      // 根据生食类型确定熟食类型
      if (foodId === 'raw_meat') {
        cookedFoodId = 'cooked_meat';
      } else if (foodId === 'fish') {
        cookedFoodId = 'grilled_fish';
      }
      
      if (!cookedFoodId) {
        showNotification('烹饪失败', '无法烹饪这种食物。');
        return;
      }
      
      // 消耗生食，获得熟食
      if (gameData.resources[foodId].amount > 0) {
        gameData.resources[foodId].amount--;
        gameData.resources[cookedFoodId].amount = (gameData.resources[cookedFoodId].amount || 0) + 1;
        
        // 更新UI
        renderResources();
        updateResourceCard(foodId);
        updateResourceCard(cookedFoodId);
        
        showNotification('烹饪成功', `你成功烹饪了${gameData.resources[cookedFoodId].name}！`);
      }
    }
    
    // 给篝火添加燃料
    function addFuelToFire() {
      // 检查是否有篝火
      if (!gameData.resources.fire || gameData.resources.fire.amount <= 0) {
        showNotification('添加燃料失败', '你没有篝火。');
        return;
      }
      
      // 检查是否有木棍
      if (!gameData.resources.stick || gameData.resources.stick.amount <= 0) {
        showNotification('添加燃料失败', '你没有木棍。');
        return;
      }
      
      // 检查燃料是否已满
      if (gameData.resources.fire.fuel >= 100) {
        showNotification('添加燃料失败', '篝火燃料已满，不需要添加更多燃料。');
        return;
      }
      
      // 消耗一个木棍，添加20%燃料
      gameData.resources.stick.amount--;
      gameData.resources.fire.fuel = Math.min(100, gameData.resources.fire.fuel + 20);
      
      // 更新UI
      renderResources();
      updateResourceCard('fire');
      
      showNotification('添加燃料成功', `你添加了一根木棍，篝火燃料增加到${gameData.resources.fire.fuel}%`);
    }
    
    // 重新点燃熄灭的篝火
    function relightFire() {
      // 检查是否有熄灭的篝火
      if (!gameData.resources.fire_extinguished || gameData.resources.fire_extinguished.amount <= 0) {
        showNotification('点燃失败', '你没有熄灭的篝火。');
        return;
      }
      
      // 检查是否有燧石
      if (!gameData.resources.flint || gameData.resources.flint.amount <= 0) {
        showNotification('点燃失败', '你没有燧石。');
        return;
      }
      
      // 记录熄灭篝火的耐久度
      const durability = gameData.resources.fire_extinguished.durability;
      
      // 消耗一个燧石，移除熄灭的篝火，添加篝火
      gameData.resources.flint.amount--;
      gameData.resources.fire_extinguished.amount = 0;
      
      // 初始化篝火（如果不存在）
      if (!gameData.resources.fire) {
        gameData.resources.fire = { name: '篝火', amount: 0, image: 'UI/篝火.jpg', durability: 100, fuel: 100 };
      }
      
      // 添加篝火，设置燃料为20%，耐久度保持不变
      gameData.resources.fire.amount = 1;
      gameData.resources.fire.fuel = 20;
      gameData.resources.fire.durability = durability;
      
      // 更新UI
      renderResources();
      
      showNotification('点燃成功', `你用燧石重新点燃了篝火，燃料为20%`);
    }

// 检查制作窗口的组合
    function checkCraftingCombination() {
      const slots = Object.values(craftingSlotsData).filter(Boolean);

if (slots.length >= 2) {
        craftingCombineButton.disabled = false;
      } else {
        craftingCombineButton.disabled = true;
      }
    }

// 制作窗口的组合功能
    craftingCombineButton.addEventListener('click', function() {
      const slots = Object.values(craftingSlotsData).filter(Boolean);

if (slots.length < 2) {
        showNotification('组合失败', '需要至少两张卡牌才能组合。');
        return;
      }

// 检查是否匹配任何配方
      let matchedRecipe = null;

for (const recipe of gameData.recipes) {
        const ingredients = Object.keys(recipe.ingredients);

// 检查配方所需的所有资源是否都在组合槽中
        let hasAllIngredients = true;
        const slotCounts = {};

// 统计槽位中每种资源的数量
        slots.forEach(resourceId => {
          slotCounts[resourceId] = (slotCounts[resourceId] || 0) + 1;
        });

// 检查每种成分是否足够
        for (const ingredientId of ingredients) {
          const requiredAmount = recipe.ingredients[ingredientId];
          const availableAmount = slotCounts[ingredientId] || 0;

if (availableAmount < requiredAmount) {
            hasAllIngredients = false;
            break;
          }
        }

if (hasAllIngredients) {
          matchedRecipe = recipe;
          break;
        }
      }

if (matchedRecipe) {
        // 保存当前配方引用，以便在回调中使用
        const currentRecipe = matchedRecipe;
        
        // 对所有匹配的配方都触发滑块游戏
        // 检查是否包含装备类物品 - 检查产物是否为装备类物品
        const hasEquipment = Object.keys(currentRecipe.result).some(resultId => gameData.resources[resultId] && gameData.resources[resultId].category === 'equipment');
        // 创建游戏配置
        const gameConfig = {
          speed: hasEquipment ? 4 : 2, // 装备类物品速度为4，非装备类物品速度为2
          targetWidth: hasEquipment ? 0.08 : 0.1, // 装备类物品目标区域宽度为0.08，非装备类物品目标区域宽度为0.1
          timeLimit: 10 // 时间限制（秒）
        };
        console.log('滑块游戏配置:', gameConfig);

// 调用滑块游戏
        startSliderGame(gameConfig, (success) => {
          if (success) {
            // 消耗材料
            for (const [ingredientId, amount] of Object.entries(currentRecipe.ingredients)) {
              let used = 0;
              for (let i = 1; i <= 3; i++) {
                if (craftingSlotsData[i] === ingredientId && used < amount) {
                  craftingSlotsData[i] = null;
                  used++;
                }
              }
            }

// 增加产物
            let firstResultId = null;
            if (currentRecipe.result) {
              // 处理result对象 - 它的结构是{ resourceId: amount }，例如{ pill: 1 }
              for (const [resultId, resultAmount] of Object.entries(currentRecipe.result)) {
                // 检查是否是资源ID还是特殊属性（排除游戏属性和非资源项）
                if (resultId === 'name' || resultId === 'description' || 
                    resultId === 'reputation' || resultId === 'begging_chance' ||
                    resultId === 'begging_level' || resultId === 'max_hunger' ||
                    resultId === 'max_thirst' || resultId === 'max_health' ||
                    resultId === 'hunger_rate' || resultId === 'thirst_rate' ||
                    resultId === 'health_rate' || resultId === 'cold' || resultId === 'health') {
                  // 这些是游戏属性，直接应用到gameData
                  if (resultId in gameData.status) {
                    gameData.status[resultId] = Math.min(100, Math.max(0, gameData.status[resultId] + resultAmount));
                  } else if (resultId in gameData) {
                    gameData[resultId] += resultAmount;
                  }
                  continue;
                }

// 记录第一个结果ID用于显示
                if (!firstResultId) firstResultId = resultId;

// 确保产物资源存在于gameData.resources中
                if (gameData.resources[resultId]) {
                  gameData.resources[resultId].amount += resultAmount;
                } else {
                  // 如果资源不存在，创建它
                  // 特殊处理一些已知资源
                  let resourceName, resourceImage;
                  switch(resultId) {
                    case 'pill':
                      resourceName = '药丸';
                      resourceImage = 'UI/药丸.jpg';
                      break;
                    case 'gold':
                      resourceName = '金子';
                      resourceImage = 'UI/金子.jpg';
                      break;
                    case 'silver_piece':
                      resourceName = '碎银子';
                      resourceImage = 'UI/碎银子.jpg';
                      break;
                    case 'black_cloak':
                      resourceName = '黑色斗篷';
                      resourceImage = 'UI/黑色斗篷.jpg';
                      break;
                    default:
                      resourceName = resultId.charAt(0).toUpperCase() + resultId.slice(1).replace('_', ' ');
                      resourceImage = `UI/${resultId}.jpg`;
                  }
                  
                  gameData.resources[resultId] = {
                    id: resultId,
                    name: resourceName,
                    amount: resultAmount,
                    image: resourceImage,
                    category: 'material' // 默认分类
                  };
                }
              }
            }

// 显示获得新卡牌的弹窗函数
            function showCardAcquiredModal(resource) {
              // 创建模态框元素
              const cardModal = document.createElement('div');
              cardModal.className = 'card-acquired-modal';
              
              // 确保图片路径正确
              let imageUrl = resource.image;
              if (!imageUrl.startsWith('UI/') && !imageUrl.startsWith('http')) {
                imageUrl = 'UI/' + imageUrl;
              }
              
              // 检查是否是装备并且已穿戴
              const isEquipped = resource.equipmentSlot && resource.equipped;
              
              cardModal.innerHTML = `
                <div class="card-acquired-modal-content">
                  <div class="card-acquired-modal-header">
                    <h3 class="card-acquired-modal-title">恭喜你，获得新的卡牌</h3>
                    <button class="card-acquired-modal-close ink-button ink-button-small">&times;</button>
                  </div>
                  <div class="card-acquired-modal-body">
                    <div class="acquired-card">
                      <div class="card-image-container">
                        <img class="card-image" src="${imageUrl}" alt="${resource.name}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                        <div class="image-fallback">
                          图片加载失败
                        </div>
                        ${isEquipped ? `<div class="equipped-badge">已穿戴</div>` : ''}
                      </div>
                      <div class="card-info">
                        <div class="card-name">${resource.name}</div>
                        <div class="card-amount">获得数量: ${resource.amount > 1 ? resource.amount : 1}</div>
                        ${resource.equipmentSlot ? `<div class="card-equipment-slot">装备槽位: ${resource.equipmentSlot}</div>` : ''}
                      </div>
                    </div>
                  </div>
                </div>
              `;

// 添加样式
              const style = document.createElement('style');
              style.textContent = `
                .card-acquired-modal {
                  position: fixed;
                  top: 0;
                  left: 0;
                  width: 100%;
                  height: 100%;
                  background-color: rgba(0, 0, 0, 0.5);
                  display: flex;
                  justify-content: center;
                  align-items: center;
                  z-index: 1500;
                  opacity: 0;
                  pointer-events: none;
                  transition: opacity 0.3s ease;
                }

.card-acquired-modal.active {
                  opacity: 1;
                  pointer-events: auto;
                }

.card-acquired-modal.closing {
                  opacity: 0;
                }

.card-acquired-modal-content {
                  background-color: white;
                  border-radius: 8px;
                  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
                  max-width: 400px;
                  width: 90%;
                  transform: translateY(-20px);
                  transition: transform 0.3s ease;
                }

.card-acquired-modal.active .card-acquired-modal-content {
                  transform: translateY(0);
                }

.card-acquired-modal.closing .card-acquired-modal-content {
                  transform: translateY(-20px);
                }

.card-acquired-modal-header {
                  padding: 16px 20px;
                  border-bottom: 1px solid #e0e0e0;
                  display: flex;
                  justify-content: space-between;
                  align-items: center;
                }

.card-acquired-modal-title {
                  font-size: 20px;
                  font-weight: normal;
                  margin: 0;
                  color: #333;
                  font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
                }

.card-acquired-modal-close {
                  background: none;
                  border: none;
                  font-size: 24px;
                  cursor: pointer;
                  color: #999;
                  line-height: 1;
                  padding: 0;
                  width: 30px;
                  height: 30px;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  border-radius: 4px;
                  transition: background-color 0.2s ease, color 0.2s ease;
                }

.card-acquired-modal-close:hover {
                  background-color: #f0f0f0;
                  color: #333;
                }

.card-acquired-modal-body {
                  padding: 20px;
                }

.acquired-card {
                  display: flex;
                  flex-direction: column;
                  align-items: center;
                }

.card-image-container {
                  width: 180px;
                  height: 250px;
                  border-radius: 8px;
                  margin-bottom: 16px;
                  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
                  background-color: #e2e8f0; /* 添加默认背景色 */
                  position: relative;
                  overflow: hidden;
                }

                .card-image {
                  width: 100%;
                  height: 100%;
                  object-fit: cover;
                  display: block;
                }

                .image-fallback {
                  position: absolute;
                  top: 0;
                  left: 0;
                  width: 100%;
                  height: 100%;
                  background-color: #e2e8f0;
                  display: none;
                  align-items: center;
                  justify-content: center;
                  color: #4a5568;
                  font-size: 0.8rem;
                  font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
                }

                .equipped-badge {
                  position: absolute;
                  bottom: 0.5rem;
                  right: 0.5rem;
                  background-color: #38A169;
                  color: white;
                  border-radius: 4px;
                  padding: 0.25rem 0.5rem;
                  font-size: 0.7rem;
                  font-weight: normal;
                  font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
                  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
                  z-index: 10;
                }

.card-info {
                  text-align: center;
                }

.card-name {
                  font-size: 18px;
                  font-weight: normal;
                  margin-bottom: 8px;
                  color: #333;
                  font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
                }

.card-amount {
                  font-size: 14px;
                  font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
                  color: #666;
                }
              `;

// 添加到DOM
              document.head.appendChild(style);
              document.body.appendChild(cardModal);

// 显示模态框
              setTimeout(() => {
                cardModal.classList.add('active');
              }, 10);

// 关闭按钮事件
              const closeButton = cardModal.querySelector('.card-acquired-modal-close');
              closeButton.addEventListener('click', closeModal);

// 点击模态框外部关闭
              cardModal.addEventListener('click', (e) => {
                if (e.target === cardModal) {
                  closeModal();
                }
              });

// 关闭模态框函数
              function closeModal() {
                cardModal.classList.add('closing');
                setTimeout(() => {
                  if (cardModal.parentNode === document.body) {
            document.body.removeChild(cardModal);
          }
          if (style.parentNode === document.head) {
            document.head.removeChild(style);
          }
                }, 300);
              }
            }

// 在滑块游戏回调内部显示获得新卡牌的弹窗
            if (firstResultId) {
              showCardAcquiredModal(gameData.resources[firstResultId]);
            }

// 更新界面
            renderResources();
            renderCraftingInventory();
            updateCraftingSlots();
            checkCraftingCombination();
          } else {
            // 游戏失败，消耗当前制作面板的卡牌
            console.log('滑块游戏失败，开始消耗制作面板的卡牌');
            console.log('当前制作槽:', craftingSlotsData);
            console.log('匹配的配方:', currentRecipe);
            
            // 消耗背包中的资源
            for (const [resource, requiredAmount] of Object.entries(currentRecipe.ingredients)) {
              if (resource in gameData.resources && !nonConsumableBowls.includes(resource)) {
                const originalAmount = gameData.resources[resource].amount;
                gameData.resources[resource].amount = Math.max(0, originalAmount - requiredAmount);
                console.log(`消耗了${requiredAmount}个${resource}，剩余${gameData.resources[resource].amount}个`);

// 检查该物品是否正在装备中
                if (gameData.resources[resource].equipped) {
                  // 如果物品数量变为0，自动卸下装备
                  if (gameData.resources[resource].amount === 0) {
                    // 移除装备效果
                    applyEquipmentEffect(resource, 'unequip');
                    // 移除装备状态
                    gameData.resources[resource].equipped = false;
                  }
                }
              } else if (nonConsumableBowls.includes(resource)) {
                console.log(`${resource}是碗类卡牌，不可消耗`);
              }
            }

// 清空制作槽（保留碗类卡牌）
            for (const slot in craftingSlotsData) {
              const resourceId = craftingSlotsData[slot];
              if (resourceId && !nonConsumableBowls.includes(resourceId)) {
                craftingSlotsData[slot] = null;
              } else if (resourceId && nonConsumableBowls.includes(resourceId)) {
                console.log(`碗类卡牌 ${resourceId} 保留在制作槽中`);
              }
            }

// 更新UI
            updateCraftingSlots();
            renderCraftingInventory();
            renderResources();
            checkCraftingCombination();

// 弹出游戏失败提示窗口
            showNotification('游戏失败', '游戏失败，未能制作出新的卡牌', 'error');
          }
        });
      } else {
        // 没有匹配的配方
        showNotification('组合失败', '没有找到匹配的配方。');
      }
    });

// 制作窗口的配方功能
    function showRecipeModal() {
      renderRecipes();
      elements.recipeModal.classList.add('active');
    }

craftingRecipeButton.addEventListener('click', function() {
      showRecipeModal();
    });

// 清空制作窗口的组合槽
    function clearCraftingSlots() {
      for (const slotNumber in craftingSlotsData) {
        const resourceId = craftingSlotsData[slotNumber];
        if (resourceId) {
          // 检查是否为碗类卡牌
          if (nonConsumableBowls.includes(resourceId)) {
            console.log('将碗类卡牌放回背包:', resourceId);
            // 将碗类卡牌放回背包
            gameData.resources[resourceId].amount++;
          } else {
            console.log('将非碗类资源放回背包:', resourceId);
            // 将非碗类资源放回背包
            gameData.resources[resourceId].amount++;
          }
          // 清空槽位
          craftingSlotsData[slotNumber] = null;
        }
      }
      // 重新渲染左侧卡牌列表和右侧槽位
      renderCraftingInventory();
      updateCraftingSlots();
      // 更新主页背包显示
      renderResources();
    }

    // 检查游戏是否失败
    function checkGameOver() {
      if (!gameData.status) return;
      
      // 检查游戏是否已经结束，避免重复触发
      if (gameData.gameOver) {
        console.log('游戏已结束，跳过检查');
        return;
      }
      
      // 测试函数是否被调用
      console.log('checkGameOver函数被调用');
      console.log('当前游戏状态:', gameData.status);
      
      // 检查饱食、精神、血量、健康、水分状态为0或体温异常
      if (gameData.status.health <= 0 || 
          gameData.status.hunger <= 0 || // 饱食度降至0
          gameData.status.spirit <= 0 || // 精神状态为0
          gameData.status.blood <= 0 || // 血量为0
          gameData.status.thirst <= 0 || // 水分耗尽（完全缺水）
          gameData.status.cold <= 34 || gameData.status.cold >= 42) { // 体温异常（低于34℃或高于42℃）
        
        // 设置游戏结束状态
        gameData.gameOver = true;
        
        // 触发游戏失败并显示具体原因
        console.log('游戏结束条件满足，显示游戏结束弹窗');
        showGameOverModal();
      }
    }

    // 显示游戏失败弹窗
    function showGameOverModal() {
      // 测试函数是否被调用
      console.log('showGameOverModal函数被调用');
      
      // 获取已存在的游戏结束模态框
      const gameOverModal = document.getElementById('gameOverModal');
      if (!gameOverModal) {
        console.error('无法找到游戏结束模态框');
        return;
      }
      
      // 确定游戏结束的具体原因
      let gameOverReason = "您的状态已达到危险水平！";
      
      if (gameData.status.health <= 0) {
        gameOverReason = "您的健康状况已严重恶化，无法继续游戏！";
      } else if (gameData.status.hunger <= 0) {
        gameOverReason = "您已经饿得无法继续前进了！";
      } else if (gameData.status.spirit <= 0) {
        gameOverReason = "您的精神状态已崩溃，无法继续游戏！";
      } else if (gameData.status.blood <= 0) {
        gameOverReason = "您失血过多，无法继续游戏！";
      } else if (gameData.status.thirst <= 0) {
        gameOverReason = "您已经严重脱水，无法继续前进了！";
      } else if (gameData.status.cold == 30 || gameData.status.cold == 50) {
        gameOverReason = gameData.status.cold <= 34 ? "您的体温过低，无法继续游戏！" : "您的体温过高，无法继续游戏！";
      }
      
      // 更新游戏结束原因
      const gameOverText = document.getElementById('gameOverText');
      if (gameOverText) {
        gameOverText.textContent = gameOverReason;
      }
      
      // 更新统计信息
      const daysSurvived = document.getElementById('daysSurvived');
      const maxReputation = document.getElementById('maxReputation');
      const resourcesCollected = document.getElementById('resourcesCollected');
      const recipesDiscovered = document.getElementById('recipesDiscovered');
      
      if (daysSurvived) daysSurvived.textContent = gameData.stats.daysSurvived || 0;
      if (maxReputation) maxReputation.textContent = (gameData.stats.maxReputation || 0) + '%';
      if (resourcesCollected) resourcesCollected.textContent = gameData.stats.resourcesCollected || 0;
      if (recipesDiscovered) recipesDiscovered.textContent = gameData.stats.recipesDiscovered || 0;
      
      // 显示模态框
      gameOverModal.classList.add('active');
    }

    // 返回开始游戏页面
    function returnToStartPage() {
      console.log('returnToStartPage函数被调用，开始重置游戏数据...');
      
      // 隐藏游戏失败弹窗
      const gameOverModal = document.querySelector('.game-over-modal');
      if (gameOverModal) {
        gameOverModal.classList.remove('active');
        console.log('游戏结束弹窗已隐藏');
      }

      // 隐藏游戏容器
      const gameContainer = document.getElementById('gameContainer');
      if (gameContainer) {
        gameContainer.style.display = 'none';
        console.log('游戏容器已隐藏');
      }

      // 显示开始游戏界面
      const startScreen = document.getElementById('startScreen');
      if (startScreen) {
        startScreen.style.display = 'flex';
        startScreen.style.opacity = '1';
        console.log('开始游戏界面已显示');
      }

      // 完整重置游戏数据
      try {
        console.log('开始重置游戏数据...');
        
        // 使用resetGame函数进行完整重置
        if (typeof resetGame === 'function') {
          try {
            console.log('调用resetGame函数重置游戏');
            resetGame();
            console.log('resetGame函数调用成功');
          } catch (resetFuncError) {
            console.error('调用resetGame函数失败:', resetFuncError);
            // 重置失败时进行手动重置
            performManualGameReset();
          }
        } else {
          console.log('resetGame函数不存在，手动重置基本数据');
          performManualGameReset();
        }
        
        // 尝试调用initGame重新初始化
        if (typeof initGame === 'function') {
          console.log('尝试调用initGame函数重新初始化游戏');
          try {
            initGame();
            console.log('initGame函数调用成功');
          } catch(initError) {
            console.warn('initGame调用失败，但不影响返回开始界面:', initError);
          }
        }
      } catch(resetError) {
        console.error('重置游戏数据时出错:', resetError);
      }
    }

    // 重置游戏数据
    function resetGameData() {
      // 重置游戏状态
      gameData.status = {
        health: 100, // 初始健康度为100（满值）
        hunger: 100, // 初始饱食度为100（满值）
        cold: 100, // 初始体温保持不变
        thirst: 100, // 初始水分为100（满值）
        spirit: 100, // 初始精神值为100（满值）
        blood: 100, // 初始血量为100（满值）
        actionPoints: 20 // 初始行动点为20（满值）
      };

      // 重置资源
      gameData.resources = {
        food: { amount: 0, equipped: false },
        stick: { amount: 0, equipped: false },
        herb: { amount: 0, equipped: false },
        money: { amount: 0, equipped: false }
      };

      // 重置技能
      gameData.skills = {
        search: { level: 0, experience: 0 },
        steal: { level: 0, experience: 0 },
        rest: { level: 0, experience: 0 },
        cook: { level: 0, experience: 0 },
        fight: { level: 0, experience: 0 },
        collect: { level: 0, experience: 0 },
        craft: { level: 0, experience: 0 }
      };

      // 重置卡牌
      gameData.cards = [];

      // 重置制作槽
      craftingSlotsData = {
        slot1: null,
        slot2: null,
        slot3: null,
        slot4: null,
        slot5: null
      };

      // 重置地点状态
      gameData.locations.forEach(location => {
        // 重置所有地点的available状态为初始值
        switch(location.id) {
          case 'black_market':
            location.available = false; // 黑市初始为不可用
            break;
          case 'prison':
            location.available = false; // 监狱初始为不可用
            location.sentenceDays = 0;
            break;
          default:
            location.available = true; // 其他地点初始为可用
        }
        location.currentLocation = false;
      });

      // 将东西市设置为初始当前地点
      const streetLocation = gameData.locations.find(loc => loc.id === 'street');
      if (streetLocation) {
        streetLocation.currentLocation = true;
      }

      // 重置解锁标志
      gameData.flags = {
        blackMarketUnlocked: false,
        gameOver: false
      };
    }

    // 撬锁游戏相关代码
    function showLockpickGame() {
      const lockpickModal = document.createElement('div');
      lockpickModal.className = 'lockpick-game-modal';
      lockpickModal.innerHTML = `
        <div class="lockpick-game-content">
          <h2>撬锁小游戏</h2>
          <div class="timer-container">
            <div class="timer-bar" id="timerBar">
              <div class="timer-bar-fill" id="timerBarFill"></div>
            </div>
            <div class="timer-text" id="timerText">剩余时间: 10秒</div>
          </div>
          <div class="lock-container">
            <canvas id="lockCanvas" width="300" height="300"></canvas>
          </div>
          <div class="lock-controls">
            <button class="unlock-btn" id="unlockBtn">开锁</button>
            <button class="give-up-btn" id="giveUpBtn">放弃</button>
          </div>
        </div>
      `;

      // 添加CSS样式
      const style = document.createElement('style');
      style.textContent = `
        .lockpick-game-modal {
          display: flex;
          justify-content: center;
          align-items: center;
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          z-index: 1000;
          animation: fadeIn 0.3s ease;
        }

        .lockpick-game-content {
          background: linear-gradient(45deg, #F8F4E8 0%, #F5EFDD 25%, #F2E9D2 50%, #F0E5CC 75%, #EDE0C5 100%);
          border: 1px solid #D6C8A5;
          border-radius: 4px;
          padding: 2rem;
          box-shadow: 0 8px 32px rgba(139, 69, 19, 0.15), 
                      0 2px 8px rgba(139, 69, 19, 0.1),
                      inset 0 1px 0 rgba(255, 255, 255, 0.3);
          text-align: center;
          max-width: 500px;
          width: 90%;
          position: relative;
          overflow: hidden;
        }

        .lockpick-game-content::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-image: 
            radial-gradient(circle at 20% 20%, rgba(210, 180, 140, 0.1) 2px, transparent 2px),
            radial-gradient(circle at 80% 80%, rgba(210, 180, 140, 0.08) 1px, transparent 1px),
            radial-gradient(circle at 40% 60%, rgba(139, 69, 19, 0.05) 3px, transparent 3px);
          background-size: 50px 50px, 30px 30px, 70px 70px;
          pointer-events: none;
        }

        .lockpick-game-content::after {
          content: '';
          position: absolute;
          top: 10px;
          left: 10px;
          right: 10px;
          bottom: 10px;
          border: 1px solid rgba(139, 69, 19, 0.1);
          border-radius: 2px;
          pointer-events: none;
        }

        .lockpick-game-content h2 {
          margin-top: 0;
          margin-bottom: 1rem;
          color: #8B4513;
          font-family: "HuiWenMingChaoTi", "FangSong", "仿宋", serif;
          font-weight: normal;
          text-shadow: 1px 1px 2px rgba(139, 69, 19, 0.2);
        }

        .timer-container {
          margin-bottom: 1rem;
        }

        .timer-bar {
          width: 100%;
          height: 20px;
          background-color: #E2E8F0;
          border-radius: 10px;
          overflow: hidden;
          margin-bottom: 0.5rem;
        }

        .timer-bar-fill {
          height: 100%;
          background-color: #48BB78;
          width: 100%;
          transition: width 0.1s linear;
        }

        .timer-text {
          font-size: 0.875rem;
          color: #4A5568;
        }

        .lock-container {
          display: flex;
          justify-content: center;
          margin: 1.5rem 0;
        }

        #lockCanvas {
          border: 1px solid #E2E8F0;
          border-radius: 50%;
          cursor: crosshair;
        }

        .lock-controls {
          display: flex;
          justify-content: center;
          gap: 1rem;
        }

        .unlock-btn {
          background-color: #48BB78;
          color: white;
          padding: 0.75rem 1.5rem;
          border-radius: 0.375rem;
          cursor: pointer;
          font-weight: normal;
          transition: background-color 0.2s;
          border: none;
          font-size: 1rem;
        }

        .unlock-btn:hover {
          background-color: #38A169;
        }

        .give-up-btn {
          background-color: #E53E3E;
          color: white;
          padding: 0.75rem 1.5rem;
          border-radius: 0.375rem;
          cursor: pointer;
          font-weight: normal;
          transition: background-color 0.2s;
          border: none;
          font-size: 1rem;
        }

        .give-up-btn:hover {
          background-color: #C53030;
        }

        @keyframes fadeIn {
          from {
            opacity: 0;
          }
          to {
            opacity: 1;
          }
        }

        @keyframes success-pulse {
          0% { transform: scale(1); }
          50% { transform: scale(1.1); }
          100% { transform: scale(1); }
        }
      `;

      document.body.appendChild(lockpickModal);
      document.head.appendChild(style);

      // 初始化撬锁游戏
      initLockpickGame();

      // 开锁按钮事件
      const unlockBtn = document.getElementById('unlockBtn');
      unlockBtn.addEventListener('click', function() {
        tryUnlock();
      });

      // 放弃按钮事件
      const giveUpBtn = document.getElementById('giveUpBtn');
      giveUpBtn.addEventListener('click', function() {
        endLockpickGame(false);
      });

      // 点击模态框外部不关闭（必须选择成功或失败）
    }

    // 撬锁游戏初始化函数
    function initLockpickGame() {
      const canvas = document.getElementById('lockCanvas');
      const ctx = canvas.getContext('2d');
      
      // 游戏状态
      window.lockpickGameState = {
        // 圆心和半径
        centerX: canvas.width / 2,
        centerY: canvas.height / 2,
        outerRadius: 100,
        innerRadius: 50,
        
        // 锁芯状态
        lockRotation: 0,
        maxLockRotation: 45,
        
        // 木棍状态
        pickAngle: 0,
        
        // 正确区域 (随机30度范围)
        correctZoneStart: Math.random() * 360,
        correctZoneEnd: 0,
        
        // 时间限制 (10秒)
        timeLimit: 10000,
        startTime: Date.now(),
        timerInterval: null,
        
        // 游戏状态
        gameActive: true,
        
        // 鼠标/触摸状态
        isDragging: false,
        
        // 画布元素和上下文
        canvas: canvas,
        ctx: ctx
      };
      
      // 计算正确区域的结束位置
      window.lockpickGameState.correctZoneEnd = 
        (window.lockpickGameState.correctZoneStart + 30) % 360;
      
      // 设置定时器
      window.lockpickGameState.timerInterval = setInterval(updateTimer, 100);
      
      // 绘制初始状态
      drawLockpickGame();
      
      // 添加鼠标事件监听器
      canvas.addEventListener('click', handleMouseClick);
      canvas.addEventListener('mousemove', handleMouseMove);
      
      // 添加全局鼠标移动事件监听器，这样即使鼠标移出画布也能控制
      document.addEventListener('mousemove', handleGlobalMouseMove);
      
      // 添加触摸事件监听器
      canvas.addEventListener('touchstart', handleTouchStart);
      canvas.addEventListener('touchmove', handleTouchMove);
      canvas.addEventListener('touchend', handleTouchEnd);
      
      // 添加全局触摸事件监听器
      document.addEventListener('touchmove', handleGlobalTouchMove);
      document.addEventListener('touchend', handleGlobalTouchEnd);
    }
    
    // 更新计时器
    function updateTimer() {
      if (!window.lockpickGameState || !window.lockpickGameState.gameActive) return;
      
      const elapsed = Date.now() - window.lockpickGameState.startTime;
      const remaining = Math.max(0, window.lockpickGameState.timeLimit - elapsed);
      
      const percentage = (remaining / window.lockpickGameState.timeLimit) * 100;
      const timerBarFill = document.getElementById('timerBarFill');
      const timerText = document.getElementById('timerText');
      
      timerBarFill.style.width = `${percentage}%`;
      timerText.textContent = `剩余时间: ${(remaining / 1000).toFixed(1)}秒`;
      
      // 时间快用完时变红色
      if (percentage < 30) {
        timerBarFill.style.backgroundColor = '#E53E3E';
      }
      
      // 时间用完
      if (remaining <= 0) {
        endLockpickGame(false);
      }
    }
    
    // 绘制游戏界面
    function drawLockpickGame() {
      if (!window.lockpickGameState) return;
      
      const { centerX, centerY, outerRadius, innerRadius, lockRotation, pickAngle } = window.lockpickGameState;
      const ctx = window.lockpickGameState.ctx;
      const canvas = window.lockpickGameState.canvas;
      
      // 清空画布
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 绘制外圆 (大圆)
      ctx.beginPath();
      ctx.arc(centerX, centerY, outerRadius, 0, 2 * Math.PI);
      ctx.strokeStyle = '#CBD5E0';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // 绘制内圆 (小圆)
      ctx.beginPath();
      ctx.arc(centerX, centerY, innerRadius, 0, 2 * Math.PI);
      ctx.strokeStyle = '#A0AEC0';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // 绘制锁芯 (中心)
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate((lockRotation * Math.PI) / 180);
      
      // 锁芯主体
      ctx.fillStyle = '#718096';
      ctx.fillRect(-15, -15, 30, 30);
      
      // 锁芯装饰
      ctx.fillStyle = '#4A5568';
      ctx.fillRect(-10, -10, 20, 20);
      
      ctx.restore();
      
      // 绘制木棍 (从中心延伸)
      const pickLength = outerRadius - 10;
      const pickEndX = centerX + Math.cos((pickAngle * Math.PI) / 180) * pickLength;
      const pickEndY = centerY + Math.sin((pickAngle * Math.PI) / 180) * pickLength;
      
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(pickEndX, pickEndY);
      ctx.strokeStyle = '#8B4513';
      ctx.lineWidth = 4;
      ctx.stroke();
      
      // 木棍末端
      ctx.beginPath();
      ctx.arc(pickEndX, pickEndY, 6, 0, 2 * Math.PI);
      ctx.fillStyle = '#8B4513';
      ctx.fill();
      
      // 绘制锁芯旋转指示器
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate((lockRotation * Math.PI) / 180);
      
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(20, 0);
      ctx.strokeStyle = '#E53E3E';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      ctx.restore();
    }
    
    // 处理鼠标点击 - 执行开锁操作
    function handleMouseClick(e) {
      if (!window.lockpickGameState || !window.lockpickGameState.gameActive) return;
      e.preventDefault();
      tryUnlock();
    }
    
    // 处理鼠标移动 - 直接控制木棍旋转
    function handleMouseMove(e) {
      if (!window.lockpickGameState || !window.lockpickGameState.gameActive) return;
      
      // 鼠标移动直接更新木棍角度
      updatePickAngle(e);
    }
    
    // 处理触摸开始
    function handleTouchStart(e) {
      if (!window.lockpickGameState || !window.lockpickGameState.gameActive) return;
      e.preventDefault();
      window.lockpickGameState.isDragging = true;
      updatePickAngleTouch(e);
    }
    
    // 处理触摸移动 - 无论是否开始都更新角度
    function handleTouchMove(e) {
      if (!window.lockpickGameState || !window.lockpickGameState.gameActive) return;
      e.preventDefault();
      
      // 触摸时总是更新角度
      updatePickAngleTouch(e);
      window.lockpickGameState.isDragging = true;
    }
    
    // 处理触摸结束
    function handleTouchEnd(e) {
      if (!window.lockpickGameState) return;
      e.preventDefault();
      window.lockpickGameState.isDragging = false;
    }
    
    // 处理全局鼠标移动
    function handleGlobalMouseMove(e) {
      if (!window.lockpickGameState || !window.lockpickGameState.gameActive) return;
      
      // 鼠标移动直接更新木棍角度
      updatePickAngle(e);
    }
    
    // 处理全局触摸移动
    function handleGlobalTouchMove(e) {
      if (!window.lockpickGameState || !window.lockpickGameState.gameActive || !window.lockpickGameState.isDragging) return;
      e.preventDefault();
      
      // 触摸时总是更新角度
      updatePickAngleTouch(e);
    }
    
    // 处理全局触摸结束
    function handleGlobalTouchEnd(e) {
      if (!window.lockpickGameState) return;
      e.preventDefault();
      window.lockpickGameState.isDragging = false;
    }
    
    // 根据鼠标位置更新木棍角度
    function updatePickAngle(e) {
      if (!window.lockpickGameState) return;
      
      const canvas = window.lockpickGameState.canvas;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // 计算从中心到鼠标点的角度
      const dx = x - window.lockpickGameState.centerX;
      const dy = y - window.lockpickGameState.centerY;
      let angle = Math.atan2(dy, dx) * (180 / Math.PI);
      
      // 确保角度在0-360范围内
      if (angle < 0) angle += 360;
      
      window.lockpickGameState.pickAngle = angle;
      drawLockpickGame();
    }
    
    // 根据触摸位置更新木棍角度
    function updatePickAngleTouch(e) {
      if (!window.lockpickGameState || e.touches.length === 0) return;
      
      const touch = e.touches[0];
      const canvas = window.lockpickGameState.canvas;
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      
      // 计算从中心到触摸点的角度
      const dx = x - window.lockpickGameState.centerX;
      const dy = y - window.lockpickGameState.centerY;
      let angle = Math.atan2(dy, dx) * (180 / Math.PI);
      
      // 确保角度在0-360范围内
      if (angle < 0) angle += 360;
      
      window.lockpickGameState.pickAngle = angle;
      drawLockpickGame();
    }
    
    // 尝试开锁
    function tryUnlock() {
      if (!window.lockpickGameState || !window.lockpickGameState.gameActive) return;
      
      const { pickAngle, correctZoneStart, correctZoneEnd, maxLockRotation } = window.lockpickGameState;
      
      // 检查木棍是否在正确区域内
      let isInRange = false;
      
      if (correctZoneStart < correctZoneEnd) {
        // 不跨越360度的情况
        isInRange = pickAngle >= correctZoneStart && pickAngle <= correctZoneEnd;
      } else {
        // 跨越360度的情况
        isInRange = pickAngle >= correctZoneStart || pickAngle <= correctZoneEnd;
      }
      
      if (isInRange) {
        // 完全正确，锁芯旋转45度
        window.lockpickGameState.lockRotation = maxLockRotation;
        
        // 动画显示开锁成功
        showLockpickSuccess();
        
        // 游戏成功
        setTimeout(() => {
          endLockpickGame(true);
        }, 1000);
      } else {
        // 计算离正确区域的距离
        let distance = calculateAngleDistance(pickAngle, correctZoneStart, correctZoneEnd);
        
        // 根据距离决定锁芯旋转角度
        // 距离越近，旋转角度越大，但不超过45度
        const rotationRatio = 1 - Math.min(distance / 180, 1);
        const rotationAmount = rotationRatio * maxLockRotation;
        
        // 更新锁芯旋转
        window.lockpickGameState.lockRotation = rotationAmount;
        drawLockpickGame();
        
        // 短暂回弹
        setTimeout(() => {
          if (window.lockpickGameState) {
            window.lockpickGameState.lockRotation = 0;
            drawLockpickGame();
          }
        }, 300);
      }
    }
    
    // 计算角度到正确区域的距离
    function calculateAngleDistance(angle, zoneStart, zoneEnd) {
      // 计算角度到区间起点的距离
      let distance1 = Math.min(Math.abs(angle - zoneStart), 360 - Math.abs(angle - zoneStart));
      
      // 计算角度到区间终点的距离
      let distance2 = Math.min(Math.abs(angle - zoneEnd), 360 - Math.abs(angle - zoneEnd));
      
      // 返回最小距离
      return Math.min(distance1, distance2);
    }
    
    // 显示开锁成功动画
    function showLockpickSuccess() {
      const canvas = window.lockpickGameState.canvas;
      canvas.style.animation = 'success-pulse 0.5s ease';
      
      setTimeout(() => {
        canvas.style.animation = '';
      }, 500);
    }
    
    // 显示开锁成功自定义提示
    function showLockpickSuccessModal(rewardName) {
      // 计算获得的技能经验值
      const experienceGain = 2;
      
      const modal = document.createElement('div');
      modal.className = 'lockpick-result-modal';
      modal.innerHTML = `
        <div class="lockpick-result-content success">
          <h2>太厉害了，开锁成功！</h2>
          <div class="rewards-container">
            <div class="reward-icon">
              <img src="${gameData.resources[rewardName]?.image || ''}" alt="${rewardName}" onerror="this.style.display='none'">
            </div>
            <div class="rewards-text">
              <p class="reward-text">你获得了 1 个 ${gameData.resources[rewardName]?.name || rewardName}！</p>
              <p class="experience-text">偷窃技能经验 +${experienceGain}</p>
            </div>
          </div>
          <button class="confirm-btn">确定</button>
        </div>
      `;
      
      // 添加样式
      const style = document.createElement('style');
      style.textContent = `
        .lockpick-result-modal {
          display: flex;
          justify-content: center;
          align-items: center;
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          z-index: 2000;
          animation: fadeIn 0.3s ease;
        }
        
        .lockpick-result-content {
          background: linear-gradient(45deg, #F8F4E8 0%, #F5EFDD 25%, #F2E9D2 50%, #F0E5CC 75%, #EDE0C5 100%);
          border: 1px solid #D6C8A5;
          border-radius: 4px;
          padding: 2rem;
          box-shadow: 0 8px 32px rgba(139, 69, 19, 0.15), 
                      0 2px 8px rgba(139, 69, 19, 0.1),
                      inset 0 1px 0 rgba(255, 255, 255, 0.3);
          text-align: center;
          max-width: 400px;
          width: 90%;
          position: relative;
          overflow: hidden;
        }

        .lockpick-result-content::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-image: 
            radial-gradient(circle at 20% 20%, rgba(210, 180, 140, 0.1) 2px, transparent 2px),
            radial-gradient(circle at 80% 80%, rgba(210, 180, 140, 0.08) 1px, transparent 1px),
            radial-gradient(circle at 40% 60%, rgba(139, 69, 19, 0.05) 3px, transparent 3px);
          background-size: 50px 50px, 30px 30px, 70px 70px;
          pointer-events: none;
        }

        .lockpick-result-content::after {
          content: '';
          position: absolute;
          top: 10px;
          left: 10px;
          right: 10px;
          bottom: 10px;
          border: 1px solid rgba(139, 69, 19, 0.1);
          border-radius: 2px;
          pointer-events: none;
        }
        
        .lockpick-result-content.success {
          border-left: 5px solid #48BB78;
        }
        
        .lockpick-result-content.failure {
          border-left: 5px solid #E53E3E;
        }
        
        .lockpick-result-content h2 {
          margin-top: 0;
          margin-bottom: 1.5rem;
        }
        
        .lockpick-result-content.success h2 {
          color: #38A169;
        }
        
        .lockpick-result-content.failure h2 {
          color: #E53E3E;
        }
        
        .rewards-container {
          display: flex;
          flex-direction: column;
          align-items: center;
          margin-bottom: 1.5rem;
        }
        
        .reward-icon {
          margin-bottom: 1rem;
        }
        
        .reward-icon img {
          width: 80px;
          height: 80px;
          object-fit: contain;
        }
        
        .rewards-text {
          text-align: center;
        }
        
        .reward-text {
          font-size: 1.1rem;
          color: #4A5568;
          margin-bottom: 0.5rem;
        }
        
        .experience-text {
          font-size: 1rem;
          color: #38A169;
          font-weight: normal;
        }
        
        .confirm-btn {
          background-color: #4299E1;
          color: white;
          padding: 0.75rem 1.5rem;
          border-radius: 0.375rem;
          cursor: pointer;
          font-weight: normal;
          transition: background-color 0.2s;
          border: none;
          font-size: 1rem;
        }
        
        .confirm-btn:hover {
          background-color: #3182CE;
        }
      `;
      
      document.body.appendChild(modal);
      document.head.appendChild(style);
      
      // 添加点击事件
      const confirmBtn = modal.querySelector('.confirm-btn');
      confirmBtn.addEventListener('click', () => {
        document.body.removeChild(modal);
      });
    }
    
    // 显示开锁失败自定义提示
    function showLockpickFailureModal() {
      const modal = document.createElement('div');
      modal.className = 'lockpick-result-modal';
      modal.innerHTML = `
        <div class="lockpick-result-content failure">
          <h2>很遗憾，开锁失败</h2>
          <div class="rewards-container">
            <div class="reward-icon">
              <span style="font-size: 3rem; color: #E53E3E;">🚨</span>
            </div>
            <div class="rewards-text">
              <p class="reward-text">你被巡逻士兵发现并抓进大牢</p>
            </div>
          </div>
          <button class="confirm-btn">确定</button>
        </div>
      `;
      
      // 添加样式（如果样式已存在，则跳过）
      if (!document.querySelector('style[data-lockpick-failure]')) {
        const style = document.createElement('style');
        style.setAttribute('data-lockpick-failure', 'true');
        style.textContent = `
          .lockpick-result-modal {
            display: flex;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            animation: fadeIn 0.3s ease;
          }
          
          .lockpick-result-content {
            background: 
              linear-gradient(45deg, #F8F4E8 0%, #F5EFDD 25%, #F2E9D2 50%, #F0E5CC 75%, #EDE0C5 100%),
              url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 300"><defs><filter id="shadow" x="-50%" y="-50%" width="200%" height="200%"><feGaussianBlur in="SourceAlpha" stdDeviation="3" result="blur"/><feOffset in="blur" dx="2" dy="2" result="offsetBlur"/><feFlood flood-color="%238B4513" flood-opacity="0.1" result="offsetColor"/><feComposite in="offsetColor" in2="offsetBlur" operator="in" result="offsetBlur"/><feMerge><feMergeNode in="offsetBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><path d="M50,250 Q100,200 150,220 Q200,240 250,230 Q300,220 350,250" stroke="%23A0522D" stroke-width="2" fill="none" opacity="0.3" filter="url(%23shadow)"/><path d="M30,200 Q80,180 120,190 Q160,200 200,185 Q240,170 280,180 Q320,190 370,200" stroke="%23966F33" stroke-width="1.5" fill="none" opacity="0.2"/><path d="M100,100 Q150,80 200,90 Q250,100 300,85" stroke="%23CD853F" stroke-width="1" fill="none" opacity="0.15"/><path d="M50,150 C100,120 150,130 200,140 C250,150 300,145 350,150" stroke="%23DEB887" stroke-width="0.8" fill="none" opacity="0.1"/></svg>');
            background-size: cover, 100% 100%;
            background-blend-mode: multiply;
            border: 1px solid #D6C8A5;
            border-radius: 4px;
            padding: 2rem;
            box-shadow: 0 8px 32px rgba(139, 69, 19, 0.15), 
                        0 2px 8px rgba(139, 69, 19, 0.1),
                        inset 0 1px 0 rgba(255, 255, 255, 0.3);
            text-align: center;
            max-width: 400px;
            width: 90%;
            position: relative;
            overflow: hidden;
          }

          .lockpick-result-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
              radial-gradient(circle at 20% 20%, rgba(210, 180, 140, 0.1) 2px, transparent 2px),
              radial-gradient(circle at 80% 80%, rgba(210, 180, 140, 0.08) 1px, transparent 1px),
              radial-gradient(circle at 40% 60%, rgba(139, 69, 19, 0.05) 3px, transparent 3px);
            background-size: 50px 50px, 30px 30px, 70px 70px;
            pointer-events: none;
          }

          .lockpick-result-content::after {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border: 1px solid rgba(139, 69, 19, 0.1);
            border-radius: 2px;
            pointer-events: none;
          }
          
          .lockpick-result-content.failure {
            border-left: 5px solid #E53E3E;
          }
          
          .lockpick-result-content h2 {
            margin-top: 0;
            margin-bottom: 1.5rem;
            color: #E53E3E;
          }
          
          .rewards-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 1.5rem;
          }
          
          .reward-icon {
            margin-bottom: 1rem;
          }
          
          .reward-icon span {
            font-size: 3rem;
          }
          
          .reward-text {
            font-size: 1.1rem;
            color: #4A5568;
            margin-bottom: 0.5rem;
          }
          
          .confirm-btn {
            background-color: #4299E1;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-weight: normal;
            transition: background-color 0.2s;
            border: none;
            font-size: 1rem;
          }
          
          .confirm-btn:hover {
            background-color: #3182CE;
          }
          
          @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
          }
        `;
        document.head.appendChild(style);
      }
      
      document.body.appendChild(modal);
      
      // 添加点击事件
      const confirmBtn = modal.querySelector('.confirm-btn');
      confirmBtn.addEventListener('click', () => {
        document.body.removeChild(modal);
        // 弹窗关闭后显示地图切换
        showLocationImageModal('牢房', 'UI/牢房.jpg', () => {
          // 地图切换完成后可以执行其他逻辑
          console.log('已切换到牢房场景');
        });
      });
    }
    
    // 结束撬锁游戏
    function endLockpickGame(success) {
      if (!window.lockpickGameState) return;
      
      // 清理计时器
      if (window.lockpickGameState.timerInterval) {
        clearInterval(window.lockpickGameState.timerInterval);
      }
      
      // 标记游戏结束
      window.lockpickGameState.gameActive = false;
      
      // 获取画布和清理事件监听器
      const canvas = window.lockpickGameState.canvas;
      if (canvas) {
        canvas.removeEventListener('click', handleMouseClick);
        canvas.removeEventListener('mousemove', handleMouseMove);
        canvas.removeEventListener('touchstart', handleTouchStart);
        canvas.removeEventListener('touchmove', handleTouchMove);
        canvas.removeEventListener('touchend', handleTouchEnd);
      }
      
      // 清理全局事件监听器
      document.removeEventListener('mousemove', handleGlobalMouseMove);
      document.removeEventListener('touchmove', handleGlobalTouchMove);
      document.removeEventListener('touchend', handleGlobalTouchEnd);
      
      // 获取模态框
      const modal = document.querySelector('.lockpick-game-modal');
      if (!modal) return;
      
      // 显示结果
      if (success) {
        // 开锁成功，随机选择奖励物品
        const rewards = [
          { resource: 'gold_bar', name: '金条' },
          { resource: 'gold', name: '金子' },
          { resource: 'silver_piece', name: '碎银子' }
        ];
        
        // 随机选择一个奖励
        const reward = rewards[Math.floor(Math.random() * rewards.length)];
        
        // 确保资源对象存在
        if (!gameData.resources[reward.resource]) {
          gameData.resources[reward.resource] = { 
            name: reward.name, 
            amount: 0, 
            image: `UI/${reward.name}.jpg`,
            category: 'material'
          };
        }
        
        // 添加奖励到玩家资源
        if (typeof gameData.resources[reward.resource].amount === 'number') {
          gameData.resources[reward.resource].amount += 1;
        } else {
          gameData.resources[reward.resource].amount = 1;
        }
        
        // 增加偷窃技能经验
        if (gameData.skills.steal) {
          const experienceGain = 2;
          gameData.skills.steal.experience = (gameData.skills.steal.experience || 0) + experienceGain;
          
          // 检查是否需要升级
          checkSkillLevelUp('steal');
          
          // 更新技能显示
          updateSkillDisplay();
        }
        
        // 更新游戏数据
        updateGameData();
        
        // 更新背包栏显示
        if (typeof renderResources === 'function') {
          renderResources();
        }
        
        // 显示成功自定义提示
        showLockpickSuccessModal(reward.resource);
      } else {
        // 开锁失败
        // 将玩家送往牢房
        sendToPrison();
        
        // 显示失败自定义提示
        showLockpickFailureModal();
      }
      
      // 移除模态框
      setTimeout(() => {
        if (document.body.contains(modal)) {
          document.body.removeChild(modal);
        }
      }, 500);
      
      // 清理游戏状态
      window.lockpickGameState = null;
    }

    // 翻找游戏相关代码
    function showGarbageGame() {
      const garbageModal = document.createElement('div');
      garbageModal.className = 'garbage-game-modal';
      garbageModal.innerHTML = `
        <div class="garbage-game-content">
          <div class="garbage-grid-container">
            <div class="garbage-grid" id="garbageGrid"></div>
          </div>
          <button class="garbage-game-end-btn" id="garbageGameEndBtn">结束翻垃圾</button>
        </div>
      `;

      // 添加CSS样式
      const style = document.createElement('style');
      style.textContent = `
        .garbage-game-modal {
          display: flex;
          justify-content: center;
          align-items: center;
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          z-index: 1000;
          animation: fadeIn 0.3s ease;
        }

        .garbage-game-content {
          background-color: #FFFDF7;
          border: 2px solid #8D6E63;
          border-radius: 0.25rem;
          padding: 1.5rem;
          box-shadow: 0 0 15px rgba(141, 110, 99, 0.2);
          text-align: center;
          max-width: 400px;
          width: 90%;
          position: relative;
        }

        .garbage-game-content::before {
          content: '';
          position: absolute;
          top: -3px;
          left: -3px;
          right: -3px;
          bottom: -3px;
          border: 1px solid #8D6E63;
          border-radius: 0.375rem;
          z-index: -1;
          opacity: 0.5;
        }
        
        .garbage-game-content::after {
          content: '◆';
          position: absolute;
          top: -12px;
          left: 50%;
          transform: translateX(-50%);
          color: #8D6E63;
          font-size: 16px;
          background-color: #FFFDF7;
          padding: 0 8px;
          z-index: 1;
        }

.garbage-grid-container {
          display: flex;
          justify-content: center;
          margin-bottom: 2rem;
        }

        .garbage-grid {
          display: grid;
          grid-template-columns: repeat(5, 1fr);
          grid-template-rows: repeat(5, 1fr);
          gap: 0;
          width: 300px;
          height: 300px;
        }

        .garbage-grid-item {
          background-color: #E2E8F0;
          border: 1px solid #CBD5E0;
          border-radius: 0.375rem;
          cursor: pointer;
          display: flex;
          justify-content: center;
          align-items: center;
          font-size: 1.5rem;
          font-weight: normal;
          transition: all 0.2s ease;
          position: relative;
          overflow: hidden;
        }

        .loot-grid-item:hover {
          background-color: #CBD5E0;
          transform: translateY(-2px);
        }

        .garbage-grid-item.flipped {
          background-color: #FFFFFF;
          cursor: default;
          transform: scale(0.95);
        }

        /* 当前选中格子的绿色边框和阴影效果 */
        .garbage-grid-item.current {
          border: 2px solid #48BB78;
          box-shadow: 0 0 10px rgba(72, 187, 120, 0.7);
          transform: scale(1.05);
        }

/* 红色边框阴影警示样式 */
        .garbage-grid-item.danger-tip {
          box-shadow: 0 0 10px 3px red, inset 0 0 10px 3px rgba(255, 0, 0, 0.3) !important;
          border: 3px solid red !important;
          animation: danger-pulse 1.5s infinite !important;
          z-index: 10 !important;
        }

/* 危险警示动画效果 */
        @keyframes danger-pulse {
          0% { box-shadow: 0 0 10px 3px red, inset 0 0 10px 3px rgba(255, 0, 0, 0.3) !important; }
          50% { box-shadow: 0 0 15px 5px red, inset 0 0 15px 5px rgba(255, 0, 0, 0.5) !important; }
          100% { box-shadow: 0 0 10px 3px red, inset 0 0 10px 3px rgba(255, 0, 0, 0.3) !important; }
        }

        .garbage-grid-item.flipped .item-content {
          animation: flipIn 0.3s ease;
        }

        .garbage-game-end-btn {
          background: linear-gradient(135deg, #8D6E63 0%, #6D4C41 100%) !important;
          border: 2px solid #5D4037 !important;
          border-radius: 16px !important;
          padding: 0.75rem 1.5rem;
          font-size: 1rem;
          font-weight: normal !important;
          cursor: pointer;
          transition: all 0.3s ease;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
          color: white !important;
          text-shadow: none !important;
          letter-spacing: 1px !important;
          overflow: hidden !important;
          box-shadow: 
            0 0 25px rgba(141, 110, 99, 0.5),
            0 4px 12px rgba(139, 69, 19, 0.3),
            inset 0 1px 3px rgba(255, 255, 255, 0.4),
            inset 0 -2px 4px rgba(0, 0, 0, 0.2) !important;
          margin-top: 2rem;
          margin-bottom: 1.5rem;
        }

        .garbage-game-end-btn:hover {
          background: linear-gradient(135deg, #7D6E63 0%, #5D4037 100%) !important;
          transform: translateY(-2px) !important;
          box-shadow: 
            0 0 35px rgba(141, 110, 99, 0.7),
            0 6px 16px rgba(139, 69, 19, 0.4),
            inset 0 1px 4px rgba(255, 255, 255, 0.5),
            inset 0 -3px 6px rgba(0, 0, 0, 0.3) !important;
          border-radius: 18px !important;
        }

        .garbage-game-end-btn:active {
          transform: translateY(0) !important;
          box-shadow: 
            0 0 15px rgba(141, 110, 99, 0.3),
        }

        .notification-button {
          background: linear-gradient(135deg, #8D6E63 0%, #6D4C41 100%) !important;
          border: 2px solid #5D4037 !important;
          border-radius: 16px !important;
          padding: 0.5rem 1.5rem !important;
          font-size: 0.875rem !important;
          font-weight: normal !important;
          cursor: pointer !important;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
          color: white !important;
          text-shadow: none !important;
          letter-spacing: 1px !important;
          overflow: hidden !important;
          box-shadow: 
            0 0 25px rgba(141, 110, 99, 0.5),
            0 4px 12px rgba(139, 69, 19, 0.3),
            inset 0 1px 3px rgba(255, 255, 255, 0.4),
            inset 0 -2px 4px rgba(0, 0, 0, 0.2) !important;
          transition: all 0.3s ease !important;
        }

        .notification-button:hover {
          background: linear-gradient(135deg, #7D6E63 0%, #5D4037 100%) !important;
          transform: translateY(-2px) !important;
          box-shadow: 
            0 0 35px rgba(141, 110, 99, 0.7),
            0 6px 16px rgba(139, 69, 19, 0.4),
            inset 0 1px 4px rgba(255, 255, 255, 0.5),
            inset 0 -3px 6px rgba(0, 0, 0, 0.3) !important;
          border-radius: 18px !important;
        }

        .notification-button:active {
          transform: translateY(0) !important;
          box-shadow: 
            0 0 15px rgba(141, 110, 99, 0.3),
        }

            0 2px 6px rgba(139, 69, 19, 0.2),
            inset 0 1px 2px rgba(255, 255, 255, 0.2),
            inset 0 -1px 3px rgba(0, 0, 0, 0.2) !important;
        }

/* 物品卡片样式 */
        .item-card {
          background-color: white;
          border-radius: 0.25rem;
          padding: 0.25rem;
          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
          width: 100%;
          height: 100%;
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
        }

        /* 非空卡牌特殊样式 - 增加宽度以适应格子并移除边框 */
        .garbage-grid-item.flipped .item-card:not(:has(.loot-item-neutral)) {
          padding: 0.125rem;
          width: 100%;
          height: 100%;
          border: none;
          box-shadow: none;
        }

        /* 非空卡牌图片样式 - 调整大小以适应更大的卡牌 */
        .garbage-grid-item.flipped .item-card:not(:has(.loot-item-neutral)) img {
          width: 32px;
          height: 32px;
          margin-bottom: 0.125rem;
        }

        /* 空卡牌特殊样式 - 不显示边框，仅放大字体 */
        .item-card .item-name.loot-item-neutral {
          font-size: 1.5rem; /* 放大字体大小以适应格子 */
        }

        /* 空卡牌的item-card不显示边框 */
        .garbage-grid-item.flipped .item-card:has(.loot-item-neutral) {
          border: none;
          box-shadow: none;
          padding: 0;
        }

.item-card .item-name {
          font-size: 0.75rem;
          font-weight: normal;
          text-align: center;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          margin-bottom: 0;
        }

        .item-card .item-effect {
          font-size: 0.75rem;
          color: #4A5568;
        }

        /* 动画 */
        @keyframes fadeIn {
          from {
            opacity: 0;
          }
          to {
            opacity: 1;
          }
        }

        @keyframes flipIn {
          from {
            transform: rotateY(90deg);
            opacity: 0;
          }
          to {
            transform: rotateY(0deg);
            opacity: 1;
          }
        }

        /* 不同类型物品的样式 */
        .loot-item-positive {
          color: #38A169;
        }

        .loot-item-negative {
          color: #E53E3E;
        }

        .loot-item-neutral {
          color: #718096;
        }
      `;

      document.body.appendChild(garbageModal);
      document.head.appendChild(style);

      // 初始化翻找游戏
      initGarbageGame();

      // 游戏结束按钮事件
      const garbageGameEndBtn = document.getElementById('garbageGameEndBtn');
      garbageGameEndBtn.addEventListener('click', function() {
        endGarbageGame();
      });

      // 点击模态框外部关闭
      garbageModal.addEventListener('click', function(e) {
        if (e.target === garbageModal) {
          endGarbageGame();
        }
      });

      // 键盘控制功能
      // 添加键盘事件监听器
      let currentSelectedRow = 0;
      let currentSelectedCol = 0;

// 初始化当前位置为中心
      function initializePosition() {
        const garbageGrid = document.getElementById('garbageGrid');
        const allItems = garbageGrid.querySelectorAll('.garbage-grid-item');
        const gridSize = Math.sqrt(allItems.length);
        const centerRow = Math.floor(gridSize / 2);
        const centerCol = Math.floor(gridSize / 2);

currentSelectedRow = centerRow;
        currentSelectedCol = centerCol;

// 为初始位置添加绿色边框和阴影
        const centerItem = Array.from(allItems).find(item => {
          return parseInt(item.dataset.row) === centerRow && parseInt(item.dataset.col) === centerCol;
        });

if (centerItem) {
          // 移除所有格子的current类
          allItems.forEach(item => item.classList.remove('current'));
          // 为中心格子添加current类
          centerItem.classList.add('current');
        }
      }

// 初始化位置
      initializePosition();

// 键盘事件处理函数
      function handleKeyboard(event) {
        const garbageGrid = document.getElementById('garbageGrid');
        const allItems = garbageGrid.querySelectorAll('.garbage-grid-item');
        const gridSize = Math.sqrt(allItems.length);

// 计算新位置
        let newRow = currentSelectedRow;
        let newCol = currentSelectedCol;

switch (event.key.toLowerCase()) {
          case 'w': // 上
            newRow = currentSelectedRow > 0 ? currentSelectedRow - 1 : currentSelectedRow;
            break;
          case 'a': // 左
            newCol = currentSelectedCol > 0 ? currentSelectedCol - 1 : currentSelectedCol;
            break;
          case 's': // 下
            newRow = currentSelectedRow < gridSize - 1 ? currentSelectedRow + 1 : currentSelectedRow;
            break;
          case 'd': // 右
            newCol = currentSelectedCol < gridSize - 1 ? currentSelectedCol + 1 : currentSelectedCol;
            break;
          default:
            return;
        }

// 如果位置没有变化，直接返回
        if (newRow === currentSelectedRow && newCol === currentSelectedCol) {
          return;
        }

// 检查是否可以移动到新位置（与已翻开的格子相邻）
        const canMove = checkCanFlip(newRow, newCol);

if (!canMove) {
          console.log('键盘控制：无法移动到该位置，必须与已翻开的格子相邻');
          return;
        }

// 找到新位置的格子
        const targetItem = Array.from(allItems).find(item => {
          return parseInt(item.dataset.row) === newRow && parseInt(item.dataset.col) === newCol;
        });

if (!targetItem) return;

// 获取格子物品数据
        const item = JSON.parse(targetItem.dataset.item);

// 检查是否是危险物品
        const isDanger = item.name === '受伤' || item.name === '呕吐';

// 检查是否已显示警示
        const hasWarning = targetItem.classList.contains('danger-tip');

// 检查是否是首次访问该格子
        const firstVisit = targetItem.dataset.firstVisit === 'false';

// 检查是否可以显示警示（根据已显示的警示数量和最大警示数量）
        const canShowWarning = window.garbageGameWarningCount < window.garbageGameMaxWarningCount;

console.log('键盘处理格子:', newRow, newCol, '物品:', item.name, '危险:', isDanger, '已警示:', hasWarning, '可显示警示:', canShowWarning, '首次访问:', firstVisit);

// 如果是危险物品且尚未显示警示且是首次访问
        if (isDanger && !hasWarning && firstVisit) {
          // 标记为已访问
          targetItem.dataset.firstVisit = 'true';

// 如果允许显示警示，则显示警示
          if (canShowWarning) {
            // 增加警示计数
            window.garbageGameWarningCount++;
            console.log('当前警示计数:', window.garbageGameWarningCount, '最大警示数量:', window.garbageGameMaxWarningCount);

// 显示警示
            targetItem.classList.add('danger-tip');

console.log('键盘预览：即将移动到危险格子', newRow, newCol, '物品:', item.name, '已显示警示');
          } else {
            // 不允许显示警示，直接执行翻牌
            console.log('键盘控制：不允许显示警示，直接执行翻牌');
            // 实际移动到新位置
            currentSelectedRow = newRow;
            currentSelectedCol = newCol;

// 更新所有格子的当前选中样式
            const allGridItems = document.querySelectorAll('.garbage-grid-item');
            allGridItems.forEach(item => item.classList.remove('current'));
            targetItem.classList.add('current');

// 检查是否移动到已翻开的受伤或呕吐卡牌
            if (targetItem.classList.contains('flipped') && (item.name === '受伤' || item.name === '呕吐')) {
              // 扣除健康度
              if (item.name === '受伤') {
                gameData.status.health -= 3;
              } else if (item.name === '呕吐') {
                gameData.status.health -= 2;
              }

// 确保健康度不低于0
              if (gameData.status.health < 0) {
                gameData.status.health = 0;
              }

// 检查游戏是否失败
              checkGameOver();

// 更新健康度显示
              elements.healthPercentage.textContent = `${gameData.status.health}%`;
              elements.healthBar.style.width = `${gameData.status.health}%`;

// 更新游戏数据
              updateGameData();

console.log('键盘移动到已翻开的危险卡牌，健康度减少:', item.name === '受伤' ? 3 : 2, '当前健康度:', gameData.status.health);
            }

// 执行翻牌逻辑
            flipCurrentPosition();
          }
        }
        // 如果已显示警示或不是危险物品
        else {
          // 移除警示样式（如果有）
          targetItem.classList.remove('danger-tip');

// 实际移动到新位置
          currentSelectedRow = newRow;
          currentSelectedCol = newCol;

// 更新所有格子的当前选中样式
          const allGridItems = document.querySelectorAll('.garbage-grid-item');
          allGridItems.forEach(item => item.classList.remove('current'));
          targetItem.classList.add('current');

// 检查是否移动到已翻开的受伤或呕吐卡牌
          if (targetItem.classList.contains('flipped') && (item.name === '受伤' || item.name === '呕吐')) {
            // 扣除健康度
            if (item.name === '受伤') {
              gameData.status.health -= 3;
            } else if (item.name === '呕吐') {
              gameData.status.health -= 2;
            }

// 确保健康度不低于0
            if (gameData.status.health < 0) {
              gameData.status.health = 0;
            }

// 检查游戏是否失败
            checkGameOver();

// 更新健康度显示
          elements.healthPercentage.textContent = `${gameData.status.health}%`;
          elements.healthBar.style.width = `${gameData.status.health}%`;

// 更新游戏数据
            updateGameData();

console.log('键盘移动到已翻开的危险卡牌，健康度减少:', item.name === '受伤' ? 3 : 2, '当前健康度:', gameData.status.health);
          }

// 执行翻牌逻辑
          flipCurrentPosition();
        }

// 防止默认行为
        event.preventDefault();
      }

// 处理格子点击的函数
      function handleGridItemClick(gridItem) {
        // 获取格子的行和列
        const itemRow = parseInt(gridItem.dataset.row);
        const itemCol = parseInt(gridItem.dataset.col);

// 获取格子物品数据
        const item = JSON.parse(gridItem.dataset.item);

// 检查是否点击了已翻开的受伤或呕吐卡牌
        if (gridItem.classList.contains('flipped') && (item.name === '受伤' || item.name === '呕吐')) {
          // 扣除健康度
          if (item.name === '受伤') {
            gameData.status.health -= 3;
          } else if (item.name === '呕吐') {
            gameData.status.health -= 2;
          }

// 确保健康度不低于0
          if (gameData.status.health < 0) {
            gameData.status.health = 0;
          }

// 检查游戏是否失败
          checkGameOver();

// 更新健康度显示
            elements.healthPercentage.textContent = `${gameData.status.health}%`;
            elements.healthBar.style.width = `${gameData.status.health}%`;

// 更新游戏数据
          updateGameData();

console.log('点击已翻开的危险卡牌，健康度减少:', item.name === '受伤' ? 3 : 2, '当前健康度:', gameData.status.health);
          return; // 点击已翻开的危险卡牌不需要检查相邻位置
        }

// 检查是否是危险物品
        const isDanger = item.name === '受伤' || item.name === '呕吐';

// 检查是否已显示警示
        const hasWarning = gridItem.classList.contains('danger-tip');

// 检查是否是首次访问该格子（初始值为false表示未访问过）
        const firstVisit = gridItem.dataset.firstVisit === 'false';

// 检查是否可以显示警示（根据已显示的警示数量和最大警示数量）
        const canShowWarning = window.garbageGameWarningCount < window.garbageGameMaxWarningCount;

console.log('处理格子点击:', itemRow, itemCol, '物品:', item.name, '危险:', isDanger, '已警示:', hasWarning, '可显示警示:', canShowWarning, '首次访问:', firstVisit);

// 检查是否可以点击该位置（与已翻开的格子相邻）
        const canClick = checkCanFlip(itemRow, itemCol);

if (!canClick) {
          console.log('点击控制：无法点击该位置，必须与已翻开的格子相邻');
          return;
        }

// 移除所有格子的当前选中样式
        const allGridItems = document.querySelectorAll('.garbage-grid-item');
        allGridItems.forEach(item => item.classList.remove('current'));

// 为当前点击的格子添加当前选中样式
        gridItem.classList.add('current');

// 如果是危险物品且尚未显示警示且是首次访问
        if (isDanger && !hasWarning && firstVisit) {
          // 标记为已访问
          gridItem.dataset.firstVisit = 'true';

// 如果允许显示警示，则显示警示
          if (canShowWarning) {
            console.log('显示危险警示:', item.name);
            // 增加警示计数
            window.garbageGameWarningCount++;
            console.log('当前警示计数:', window.garbageGameWarningCount, '最大警示数量:', window.garbageGameMaxWarningCount);
            // 添加红色边框阴影警示类
            gridItem.classList.add('danger-tip');
          } else {
            // 不允许显示警示，直接执行翻牌
            console.log('不允许显示警示，直接执行翻牌');
            // 移除警示样式（如果有）
            gridItem.classList.remove('danger-tip');
            // 执行翻牌逻辑
            flipItem(gridItem);
          }
        }
        // 如果已显示警示或不是危险物品
        else {
          // 移除警示样式（如果有）
          gridItem.classList.remove('danger-tip');

          console.log('执行翻牌:', item.name);
          // 执行翻牌逻辑
          flipItem(gridItem);
        }
      }

// 检查是否可以翻牌
      function checkCanFlip(itemRow, itemCol) {
        const garbageGrid = document.getElementById('garbageGrid');
        const allItems = garbageGrid.querySelectorAll('.garbage-grid-item');
        const gridSize = Math.sqrt(allItems.length);

// 找到所有已翻开的格子
        const flippedItems = Array.from(allItems).filter(gridItem => gridItem.classList.contains('flipped'));

// 如果没有已翻开的格子，则检查是否是中心格子
        if (flippedItems.length === 0) {
          const centerRow = Math.floor(gridSize / 2);
          const centerCol = Math.floor(gridSize / 2);
          return itemRow === centerRow && itemCol === centerCol;
        }

// 检查是否与任何已翻开的格子上下左右相邻
        for (const gridItem of flippedItems) {
          const gridRow = parseInt(gridItem.dataset.row);
          const gridCol = parseInt(gridItem.dataset.col);

// 检查是否上下左右相邻
          const isAdjacent = 
            (Math.abs(gridRow - itemRow) === 1 && gridCol === itemCol) ||
            (Math.abs(gridCol - itemCol) === 1 && gridRow === itemRow);

if (isAdjacent) {
            return true;
          }
        }

return false;
      }

// 翻牌当前位置的函数
      function flipCurrentPosition() {
        const garbageGrid = document.getElementById('garbageGrid');
        const allItems = garbageGrid.querySelectorAll('.garbage-grid-item');

// 移除所有格子的current类
        allItems.forEach(item => item.classList.remove('current'));

// 找到当前位置的格子
        const targetItem = Array.from(allItems).find(item => {
          return parseInt(item.dataset.row) === currentSelectedRow && parseInt(item.dataset.col) === currentSelectedCol;
        });

if (targetItem) {
          // 为当前格子添加绿色边框和阴影
          targetItem.classList.add('current');

console.log('键盘控制：移动到格子', currentSelectedRow, currentSelectedCol);
          // 调用点击处理函数
          handleGridItemClick(targetItem);
        }
      }

// 添加键盘事件监听器
      document.addEventListener('keydown', handleKeyboard);

// 保存监听器，以便在结束游戏时移除
      window.currentGarbageGameKeyboardListener = handleKeyboard;

      // 初始化翻垃圾游戏的函数
      function initGarbageGame() {
        // 随机选择3x3或5x5网格
        const gridSize = Math.random() > 0.5 ? 3 : 5;
        const garbageGrid = document.getElementById('garbageGrid');
        garbageGrid.innerHTML = '';

        // 设置网格大小
        garbageGrid.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
        garbageGrid.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;

        // 创建物品池
        const items = generateGarbageItems(gridSize * gridSize);

        // 打乱物品顺序
        shuffleArray(items);

        // 创建网格项
        const gridItems = [];
        items.forEach((item, index) => {
          const gridItem = document.createElement('div');
          gridItem.className = 'garbage-grid-item';
          gridItem.dataset.item = JSON.stringify(item);
          gridItem.dataset.index = index;
          gridItem.dataset.row = Math.floor(index / gridSize);
          gridItem.dataset.col = index % gridSize;
          gridItem.dataset.flipped = 'false';
          gridItem.dataset.firstVisit = 'false'; // 添加首次访问标记

          // 计算是否是中心位置
          const centerRow = Math.floor(gridSize / 2);
          const centerCol = Math.floor(gridSize / 2);
          const isCenter = Math.floor(index / gridSize) === centerRow && index % gridSize === centerCol;

          // 如果是中心位置，直接翻开
          if (isCenter) {
            flipItem(gridItem, true);
          }

          // 为每个格子添加点击事件
          gridItem.addEventListener('click', function() {
            handleGridItemClick(this);
          });

          garbageGrid.appendChild(gridItem);
          gridItems.push(gridItem);
        });

        // 保存危险格子列表，以便后续使用
        const dangerItems = gridItems.filter(item => {
          const itemData = JSON.parse(item.dataset.item);
          return itemData.name === '受伤' || itemData.name === '呕吐';
        });

// 根据搜寻技能等级确定可提示的危险格子数量
        let maxWarningCount = 0;
        const searchSkill = gameData.skills.search || { level: 0 };
        const searchLevel = searchSkill.level || 0;

if (searchLevel >= 0 && searchLevel <= 4) {
          maxWarningCount = 1;
        } else if (searchLevel >= 5 && searchLevel <= 8) {
          maxWarningCount = 2;
        } else if (searchLevel >= 9) {
          maxWarningCount = 3;
        }

// 添加调试日志
        console.log('危险格子总数:', dangerItems.length);
        console.log('搜寻技能等级:', searchLevel);
        console.log('最大警示数量:', maxWarningCount);

// 保存危险格子信息和最大警示数量到全局变量
        window.garbageGameDangerItems = dangerItems;
        window.garbageGameMaxWarningCount = maxWarningCount;
        window.garbageGameWarningCount = 0; // 跟踪已经显示的警示数量
      }

      // 生成翻垃圾物品
      function generateGarbageItems(totalItems) {
        const items = [];

        // 有价值的物品卡牌
        const valuableItems = [
          { type: 'positive', name: '窝窝头', effect: '+1窝窝头' },
          { type: 'positive', name: '木棍', effect: '+1木棍' },
          { type: 'positive', name: '草药', effect: '+1草药' },
          { type: 'positive', name: '钱币', effect: '+1钱币' }
        ];

        // 有害的物品卡牌
        const harmfulItems = [
          { type: 'negative', name: '受伤', effect: '获得受伤状态' },
          { type: 'negative', name: '呕吐', effect: '获得呕吐状态' }
        ];

        // 空区域
        const emptyItem = { type: 'neutral', name: '空', effect: '无' };

        // 计算至少需要的奖励物品和危险物品数量（20%，向上取整）
        const minPositiveItems = Math.ceil(totalItems * 0.2);
        const minNegativeItems = Math.ceil(totalItems * 0.2);

        // 第一步：填充至少数量的奖励物品
        for (let i = 0; i < minPositiveItems; i++) {
          items.push(randomChoice(valuableItems));
        }

        // 第二步：填充至少数量的危险物品
        for (let i = 0; i < minNegativeItems; i++) {
          items.push(randomChoice(harmfulItems));
        }

        // 第三步：用剩余的物品填充数组（可以是任意类型）
        const remainingItems = totalItems - minPositiveItems - minNegativeItems;
        for (let i = 0; i < remainingItems; i++) {
          const random = Math.random();
          if (random < 0.3) {
            // 有价值的物品
            items.push(randomChoice(valuableItems));
          } else if (random < 0.6) {
            // 有害的物品
            items.push(randomChoice(harmfulItems));
          } else {
            // 空区域
            items.push(emptyItem);
          }
        }

        // 打乱数组，确保物品随机分布
        shuffleArray(items);

        return items;
      }

      // 随机选择函数
      function randomChoice(array) {
        return array[Math.floor(Math.random() * array.length)];
      }

      // 打乱数组函数
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }

// 翻垃圾物品
      function flipItem(itemElement, isCenter = false) {
        if (itemElement.classList.contains('flipped')) {
          return;
        }

        // 获取格子的行和列
        const itemRow = parseInt(itemElement.dataset.row);
        const itemCol = parseInt(itemElement.dataset.col);

// 检查是否可以翻牌（除了中心格子，其他情况由调用方检查）
        if (!isCenter && !checkCanFlip(itemRow, itemCol)) {
          return;
        }

        // 执行翻牌操作
        const item = JSON.parse(itemElement.dataset.item);
        itemElement.classList.add('flipped');
        // 移除警示样式（如果有）
        itemElement.classList.remove('danger-tip');

// 移除之前添加的感叹号卡牌内容（如果存在）
        const existingContent = itemElement.querySelector('.item-content');
        if (existingContent) {
          itemElement.removeChild(existingContent);
        }

        // 添加物品内容
        const itemContent = document.createElement('div');
        itemContent.className = 'item-content';

// 添加图片显示
        let itemImage = '';
        // 为有价值物品和有害物品添加对应卡牌图片
        if (item.type !== 'neutral') {
          // 根据物品名称获取对应的卡牌图片
          let imageName = item.name;
          if (item.name === '食物') {
            // 食物使用窝窝头作为默认图片
            imageName = '窝窝头';
          }
          itemImage = `<img src="UI/${imageName}.jpg" alt="${item.name}" style="width: 25px; height: 25px; object-fit: cover; margin-bottom: 0.25rem;">`;
        }

itemContent.innerHTML = `
          <div class="item-card">
            ${itemImage}
            <div class="item-name loot-item-${item.type}">${item.name}</div>
          </div>
        `;

        itemElement.appendChild(itemContent);

        // 应用物品效果
        applyItemEffect(item);
      }

      // 应用物品效果
      function applyItemEffect(item) {
        switch (item.name) {
          case '窝窝头':
            // 不再立即添加到背包，等待游戏结束时统一添加
            break;
          case '木棍':
            // 不再立即添加到背包，等待游戏结束时统一添加
            break;
          case '草药':
            // 不再立即添加到背包，等待游戏结束时统一添加
            break;
          case '钱币':
            // 不再立即添加到背包，等待游戏结束时统一添加
            break;
          case '受伤':
            // 检查游戏数据中是否有卡牌系统
            if (gameData.cards && Array.isArray(gameData.cards)) {
              // 添加受伤卡牌
              gameData.cards.push('受伤');
            } else if (gameData.status) {
              // 如果没有卡牌系统，直接减少健康值
              gameData.status.health -= 10;
              checkGameOver(); // 检查游戏是否失败
            }
            break;
          case '呕吐':
            // 检查游戏数据中是否有卡牌系统
            if (gameData.cards && Array.isArray(gameData.cards)) {
              // 添加呕吐卡牌
              gameData.cards.push('呕吐');
            } else if (gameData.status) {
              // 如果没有卡牌系统，直接减少健康值
              gameData.status.health -= 5;
              checkGameOver(); // 检查游戏是否失败
            }
            break;
          // 空区域不需要处理
        }

        // 更新游戏数据
        updateGameData();
        
        // 检查游戏状态是否失败
        checkGameOver();
      }



      // 结束翻垃圾游戏
      function endGarbageGame() {
        // 防止重复调用
        if (window.garbageGameEnded) return;
        window.garbageGameEnded = true;

        // 移除键盘事件监听器
        if (window.currentGarbageGameKeyboardListener) {
          document.removeEventListener('keydown', window.currentGarbageGameKeyboardListener);
          delete window.currentGarbageGameKeyboardListener;
        }

// 收集结果并显示弹窗
        showLootResultsModal();

        // 关闭翻垃圾游戏窗口
        const garbageModal = document.querySelector('.garbage-game-modal');
        const style = document.querySelector('style[innerText*="garbage-game-modal"]');
        if (garbageModal) {
          garbageModal.classList.add('closing');
          setTimeout(() => {
            if (garbageModal.parentNode) {
              garbageModal.parentNode.removeChild(garbageModal);
            }
            if (style && style.parentNode) {
              style.parentNode.removeChild(style);
            }
            // 重置标志，允许下次游戏
            window.garbageGameEnded = false;
          }, 300);
        }
      }

      // 显示翻垃圾结果弹窗
      function showLootResultsModal() {
        const flippedItems = document.querySelectorAll('.garbage-grid-item.flipped');
        const results = [];

        flippedItems.forEach(item => {
          const itemData = JSON.parse(item.dataset.item);
          results.push(itemData);
        });

        // 统计结果 - 只统计有价值的物品
        const valuableItems = results.filter(item => item.type === 'positive');

// 计算各种有价值物品的数量
        const itemCounts = {};

valuableItems.forEach(item => {
          // 根据物品名称获取对应的资源ID
          const resourceId = Object.keys(gameData.resources).find(id => gameData.resources[id].name === item.name);

// 将物品添加到背包中
          if (resourceId) {
            gameData.resources[resourceId].amount += 1;
          }

// 统计数量
          itemCounts[item.name] = (itemCounts[item.name] || 0) + 1;
        });

// 更新背包UI
        renderResources();

        // 创建结果弹窗
        const resultsModal = document.createElement('div');
        resultsModal.className = 'loot-results-modal';

// 添加点击任意位置关闭功能
        resultsModal.addEventListener('click', function(e) {
          // 如果点击的是模态框本身而不是内容区域，则关闭
          if (e.target === resultsModal) {
            resultsModal.remove();
          }
          // 阻止事件冒泡，防止重复处理
          e.stopPropagation();
        });

// 生成结果HTML
        let resultHTML = `
          <div class="loot-results-content">
            <h3 class="loot-results-title">翻垃圾收获</h3>
            <div class="loot-results-items">
        `;

if (valuableItems.length > 0) {
          Object.entries(itemCounts).forEach(([itemName, count]) => {
            // 确定物品图片
            let imageName = itemName;

resultHTML += `
              <div class="loot-result-item">
                <img src="UI/${imageName}.jpg" alt="${itemName}" class="loot-result-image">
                <div class="loot-result-info">
                  <div class="loot-result-name">${itemName}</div>
                  <div class="loot-result-count">× ${count}</div>
                </div>
              </div>
            `;
          });
        } else {
          resultHTML += `
            <div class="loot-no-results">
              <p>没有找到任何有价值的物品。</p>
            </div>
          `;
        }

resultHTML += `
            </div>
            <button class="loot-results-close" onclick="this.closest('.loot-results-modal').remove()">确定</button>
          </div>
        `;

resultsModal.innerHTML = resultHTML;

// 添加结果弹窗CSS
        const resultsStyle = document.createElement('style');
        resultsStyle.textContent = `
          .loot-results-modal {
            display: flex;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1001;
            animation: fadeIn 0.3s ease;
          }

.loot-results-content {
            background-color: #FFFDF7;
            border: 2px solid #8D6E63;
            border-radius: 0.25rem;
            padding: 1rem;
            box-shadow: 0 0 15px rgba(141, 110, 99, 0.2);
            text-align: center;
            max-width: 400px;
            width: 90%;
            max-height: 70vh;
            overflow-y: auto;
            position: relative;
          }

.loot-results-content::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border: 1px solid #8D6E63;
            border-radius: 0.375rem;
            z-index: -1;
            opacity: 0.5;
          }
          
          .loot-results-content::after {
            content: '◆';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            color: #8D6E63;
            font-size: 16px;
            background-color: #FFFDF7;
            padding: 0 8px;
            z-index: 1;
          }

/* Webkit滚动条样式 */
          .loot-results-content::-webkit-scrollbar {
            width: 8px;
          }

.loot-results-content::-webkit-scrollbar-track {
            background: #f7fafc;
            border-radius: 4px;
          }

.loot-results-content::-webkit-scrollbar-thumb {
            background-color: #cbd5e0;
            border-radius: 4px;
          }

.loot-results-content::-webkit-scrollbar-thumb:hover {
            background-color: #a0aec0;
          }

.loot-results-title {
            color: #5D4037;
            font-size: 1.25rem;
            font-weight: normal;
            margin-bottom: 1rem;
            position: relative;
            display: inline-block;
          }
          
          .loot-results-title::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: #8D6E63;
            transform: scaleX(0.8) translateX(10%);
            opacity: 0.7;
          }

.loot-results-items {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
          }

.loot-result-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background-color: #EDF2F7;
            border-radius: 0.375rem;
            border-left: 3px solid #8D6E63;
          }

.loot-result-image {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 0.25rem;
          }

.loot-result-info {
            flex: 1;
            text-align: left;
          }

.loot-result-name {
            color: #5D4037;
            font-size: 1rem;
            font-weight: normal;
            margin-bottom: 0.25rem;
          }

.loot-result-count {
            color: #7D6E63;
            font-size: 0.75rem;
          }

.loot-no-results {
            padding: 1.5rem;
            color: #7D6E63;
            font-size: 0.875rem;
          }

.loot-results-close {
            background: linear-gradient(135deg, #8D6E63 0%, #6D4C41 100%) !important;
            border: 2px solid #5D4037 !important;
            border-radius: 16px !important;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: normal !important;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
            color: white !important;
            text-shadow: none !important;
            letter-spacing: 1px !important;
            overflow: hidden !important;
            box-shadow: 
              0 0 25px rgba(141, 110, 99, 0.5),
              0 4px 12px rgba(139, 69, 19, 0.3),
              inset 0 1px 3px rgba(255, 255, 255, 0.4),
              inset 0 -2px 4px rgba(0, 0, 0, 0.2) !important;
          }

        .ink-button {
          background: linear-gradient(135deg, #8D6E63 0%, #6D4C41 100%) !important;
          border: 2px solid #5D4037 !important;
          border-radius: 16px !important;
          padding: 0.75rem 1.5rem;
          font-size: 1rem;
          font-weight: normal !important;
          cursor: pointer;
          transition: all 0.3s ease;
          font-family: 'HuiWenMingChaoTi', 'FangSong', '仿宋', serif !important;
          color: white !important;
          text-shadow: none !important;
          letter-spacing: 1px !important;
          overflow: hidden !important;
          box-shadow: 
            0 0 25px rgba(141, 110, 99, 0.5),
            0 4px 12px rgba(139, 69, 19, 0.3),
            inset 0 1px 3px rgba(255, 255, 255, 0.4),
            inset 0 -2px 4px rgba(0, 0, 0, 0.2) !important;
        }
.loot-results-close:hover {
            background: linear-gradient(135deg, #7D6E63 0%, #5D4037 100%) !important;
            transform: translateY(-2px) !important;
            box-shadow: 
              0 0 35px rgba(141, 110, 99, 0.7),
              0 6px 16px rgba(139, 69, 19, 0.4),
              inset 0 1px 4px rgba(255, 255, 255, 0.5),
              inset 0 -3px 6px rgba(0, 0, 0, 0.3) !important;
            border-radius: 18px !important;
          }
          
          .loot-results-close:active {
            transform: translateY(0) !important;
            box-shadow: 
              0 0 15px rgba(141, 110, 99, 0.3),
              0 2px 6px rgba(139, 69, 19, 0.2),
              inset 0 1px 2px rgba(255, 255, 255, 0.2),
              inset 0 -1px 3px rgba(0, 0, 0, 0.2) !important;
          }
        `;

// 将弹窗和样式添加到页面
        document.body.appendChild(resultsStyle);
        document.body.appendChild(resultsModal);
      }
    }

    // 更新行动点显示
    function updateActionPointsDisplay() {
        // 更新A/B格式的行动点显示
        const actionPointsValueElement = document.getElementById('actionPointsValue');
        if (actionPointsValueElement) {
            actionPointsValueElement.textContent = `(行动点 ${gameData.status.actionPoints}/20)`;
        }
    }

    // 获取时间段中文文本
    function getTimeOfDayText(timeOfDay) {
        const timeMap = {
            'early_morning': '清晨',
            'morning': '上午',
            'afternoon': '下午',
            'evening': '傍晚',
            'night': '夜晚'
        };
        return timeMap[timeOfDay] || '清晨';
    }

    // 根据天数计算季节的函数
    function calculateSeason(day) {
        // 计算天数在40天周期中的位置（从0开始）
        const cycleDay = (day - 1) % 40;
        
        // 定义季节范围
        if (cycleDay >= 0 && cycleDay < 10) {
            return 'spring'; // 第1-10天：春季
        } else if (cycleDay >= 10 && cycleDay < 20) {
            return 'summer'; // 第11-20天：夏季
        } else if (cycleDay >= 20 && cycleDay < 30) {
            return 'autumn'; // 第21-30天：秋季
        } else { // cycleDay >= 30 && cycleDay < 40
            return 'winter'; // 第31-40天：冬季
        }
    }

    // 进入下一天函数
    function goToNextDay() {
        // 计算还剩下几个时间段到第二天，并减去相应的数值
        const timeOrder = ['early_morning', 'morning', 'afternoon', 'evening', 'night'];
        const currentTimeIndex = timeOrder.indexOf(gameData.timeOfDay);
        const remainingPeriods = 5 - currentTimeIndex - 1; // 计算剩余时间段数量
        
        if (remainingPeriods > 0) {
            // 每个剩余时间段，饱食、水分、精神值下降5
            const decreaseAmount = remainingPeriods * 5;
            gameData.status.hunger = Math.max(0, gameData.status.hunger - decreaseAmount);
            gameData.status.thirst = Math.max(0, gameData.status.thirst - decreaseAmount); // 减少水分值（水分消耗）
            gameData.status.spirit = Math.max(0, gameData.status.spirit - decreaseAmount);
            
            // 篝火燃料根据剩余时间段消耗（每个时间段减少5）
            if (gameData.resources.fire && gameData.resources.fire.amount > 0) {
                const fuelDecrease = remainingPeriods * 5;
                gameData.resources.fire.fuel = Math.max(0, gameData.resources.fire.fuel - fuelDecrease);
                
                // 如果燃料耗尽，篝火熄灭
                if (gameData.resources.fire.fuel <= 0) {
                    // 记录耐久度
                    const durability = gameData.resources.fire.durability;
                    // 移除篝火
                    gameData.resources.fire.amount = 0;
                    // 添加熄灭的篝火
                    if (!gameData.resources.fire_extinguished) {
                        gameData.resources.fire_extinguished = { name: '篝火（灭）', amount: 0, image: 'UI/篝火（灭）.jpg', durability: durability, category: 'material' };
                    }
                    gameData.resources.fire_extinguished.amount = 1;
                    gameData.resources.fire_extinguished.durability = durability;
                    
                    showNotification('篝火熄灭', '你的篝火燃料已经耗尽，篝火熄灭了。');
                }
            }
            
            // 检查游戏是否失败
            checkGameOver();
            
            // 更新状态显示
            updateGameData();
            
            // 更新资源显示（如果篝火燃料有变化）
            if (gameData.resources.fire && gameData.resources.fire.amount > 0) {
                renderResources();
            }
        }
        
        // 增加天数
        gameData.day++;
        
        // 重置时间段为清晨
        gameData.timeOfDay = 'early_morning';
        
        // 重置行动点为满值
        gameData.status.actionPoints = 20;
        
        // 根据当前天数计算季节并检查是否需要处理季节变化
        const previousSeason = calculateSeason(gameData.day - 1);
        gameData.season = calculateSeason(gameData.day);
        
        // 如果季节发生变化，显示通知并重置新季节的统计数据
        if (previousSeason !== gameData.season) {
            // 确保季节统计数据存在
            if (!gameData.seasonWeatherStats) {
                gameData.seasonWeatherStats = {
                    spring: { rainyDays: 0, totalDays: 0 },
                    summer: { rainyDays: 0, totalDays: 0 },
                    autumn: { rainyDays: 0, totalDays: 0 },
                    winter: { snowyDays: 0, totalDays: 0 }
                };
            }
            
            // 重置新季节的统计数据
            if (!gameData.seasonWeatherStats[gameData.season]) {
                gameData.seasonWeatherStats[gameData.season] = { rainyDays: 0, totalDays: 0, snowyDays: 0 };
            } else {
                gameData.seasonWeatherStats[gameData.season].rainyDays = 0;
                gameData.seasonWeatherStats[gameData.season].snowyDays = 0;
                gameData.seasonWeatherStats[gameData.season].totalDays = 0;
            }
            
            // 定义季节名称映射（英文到中文）
            const seasonNames = {
                'spring': '春季',
                'summer': '夏季', 
                'autumn': '秋季',
                'winter': '冬季'
            };
            showNotification(`季节变更为${seasonNames[gameData.season]}，资源获取效率可能会变化。`, 'info');
        }
        
        // 更新UI显示
        const dayNumberElement = document.getElementById('dayNumber');
        if (dayNumberElement) dayNumberElement.textContent = gameData.day;
        
        const timeOfDayElement = document.getElementById('timeOfDay');
        if (timeOfDayElement) timeOfDayElement.textContent = getTimeOfDayText(gameData.timeOfDay);
        
        // 更新行动点显示
        updateActionPointsDisplay();
        
        // 更新季节显示
        updateGameData();
        
        // 生成新一天的天气
        generateWeather();
        
        // 减少装备耐久度
        decreaseItemDurability();
        
        // 显示进入新一天的通知
        showNotification('新的一天开始了！行动点已恢复满值。', 'info');
        
        // 检查是否在牢房中
        if (gameData.currentLocation === 'cell') {
            // 每日减少刑期
            gameData.status.prisonSentence = Math.max(0, gameData.status.prisonSentence - 1);
            
            // 牢房中的惩罚：健康和精神值减少
            gameData.status.health = Math.max(0, gameData.status.health - 5);
            gameData.status.spirit = Math.max(0, gameData.status.spirit - 5);
            
            updateGameData();
            
            if (gameData.status.prisonSentence === 0) {
                showNotification('刑期已满，你被释放了！', 'success');
                gameData.currentLocation = 'street';
                showLocation('street');
            } else {
                showNotification(`牢狱生活艰苦... 健康和精神都受到了折磨。还需服刑${gameData.status.prisonSentence}天。`, 'danger');
            }
        } else {
            // 非牢房环境的每日消耗
            if (gameData.season === 'winter') {
                // 冬季额外消耗
                gameData.status.health = Math.max(0, gameData.status.health - 3);
                checkGameOver(); // 检查游戏是否失败
                showNotification('寒冷的冬季，健康值有所下降。', 'warning');
            }
        }
    }

    // 自定义滚动条功能
    function initializeResourceScrollbar() {
        const resourceContainer = document.querySelector('.resource-container');
        const resourceGrid = document.getElementById('resourceGrid');
        const scrollbar = document.querySelector('.resource-scrollbar');
        const scrollbarThumb = document.querySelector('.resource-scrollbar-thumb');

        if (!resourceGrid || !scrollbar || !scrollbarThumb) return;

        // 更新滚动条位置
        function updateScrollBar() {
            const maxScrollLeft = resourceGrid.scrollWidth - resourceGrid.clientWidth;
            const scrollPercent = resourceGrid.scrollLeft / maxScrollLeft;
            const thumbWidth = scrollbar.clientWidth * (resourceGrid.clientWidth / resourceGrid.scrollWidth);
            
            scrollbarThumb.style.width = `${thumbWidth}px`;
            scrollbarThumb.style.left = `${scrollPercent * (scrollbar.clientWidth - thumbWidth)}px`;
        }

        // 初始化滚动条
        updateScrollBar();

        // 监听滚动事件
        resourceGrid.addEventListener('scroll', updateScrollBar);

        // 监听窗口大小变化
        window.addEventListener('resize', updateScrollBar);

        // 点击滚动条轨道
        scrollbar.addEventListener('click', function(e) {
            const clickX = e.clientX - scrollbar.getBoundingClientRect().left;
            const scrollbarWidth = scrollbar.clientWidth;
            const thumbWidth = scrollbarThumb.clientWidth;
            
            const maxScrollLeft = resourceGrid.scrollWidth - resourceGrid.clientWidth;
            const scrollPercent = clickX / scrollbarWidth;
            
            resourceGrid.scrollLeft = scrollPercent * maxScrollLeft;
        });

        // 拖拽滚动条拇指
        let isDragging = false;
        let startX = 0;
        let startScrollLeft = 0;
        let startThumbLeft = 0;

        scrollbarThumb.addEventListener('mousedown', function(e) {
            isDragging = true;
            startX = e.clientX;
            startScrollLeft = resourceGrid.scrollLeft;
            startThumbLeft = parseFloat(scrollbarThumb.style.left) || 0;
            
            // 添加拖拽样式
            scrollbarThumb.classList.add('dragging');
            document.body.style.userSelect = 'none';
        });

        document.addEventListener('mousemove', function(e) {
            if (!isDragging) return;
            
            const deltaX = e.clientX - startX;
            const scrollbarWidth = scrollbar.clientWidth;
            const thumbWidth = scrollbarThumb.clientWidth;
            const maxThumbLeft = scrollbarWidth - thumbWidth;
            const maxScrollLeft = resourceGrid.scrollWidth - resourceGrid.clientWidth;
            
            const newThumbLeft = Math.max(0, Math.min(maxThumbLeft, startThumbLeft + deltaX));
            const scrollPercent = newThumbLeft / maxThumbLeft;
            
            resourceGrid.scrollLeft = scrollPercent * maxScrollLeft;
        });

        document.addEventListener('mouseup', function() {
            if (!isDragging) return;
            
            isDragging = false;
            scrollbarThumb.classList.remove('dragging');
            document.body.style.userSelect = '';
        });
    }

    // 当页面加载完成后初始化滚动条
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeResourceScrollbar);
    } else {
        initializeResourceScrollbar();
    }
  </script>
</body>
</html>
